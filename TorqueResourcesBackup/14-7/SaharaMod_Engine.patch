--- source/lighting/advanced/hlsl/advancedLightingFeaturesHLSL.cpp	Tue Jan 20 00:26:36 1970
+++ source/lighting/advanced/hlsl/advancedLightingFeaturesHLSL.cpp	Tue Jan 20 00:26:36 1970
@@ -1,712 +1,642 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2012 GarageGames, LLC
-//
-// Permission is hereby granted, free of charge, to any person obtaining a copy
-// of this software and associated documentation files (the "Software"), to
-// deal in the Software without restriction, including without limitation the
-// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
-// sell copies of the Software, and to permit persons to whom the Software is
-// furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-// IN THE SOFTWARE.
-//-----------------------------------------------------------------------------
-
-#include "platform/platform.h"
-#include "lighting/advanced/hlsl/advancedLightingFeaturesHLSL.h"
-
-#include "lighting/advanced/advancedLightBinManager.h"
-#include "shaderGen/langElement.h"
-#include "shaderGen/shaderOp.h"
-#include "shaderGen/conditionerFeature.h"
-#include "renderInstance/renderPrePassMgr.h"
-#include "materials/processedMaterial.h"
-#include "materials/materialFeatureTypes.h"
-
-
-void DeferredRTLightingFeatHLSL::processPixMacros( Vector<GFXShaderMacro> &macros, 
-                                                   const MaterialFeatureData &fd  )
-{
-   // Skip deferred features, and use forward shading instead
-   if ( fd.features[MFT_ForwardShading] )
-   {
-      Parent::processPixMacros( macros, fd );
-      return;
-   }
-
-   // Pull in the uncondition method for the light info buffer
-   NamedTexTarget *texTarget = NamedTexTarget::find( AdvancedLightBinManager::smBufferName );
-   if ( texTarget && texTarget->getConditioner() )
-   {
-      ConditionerMethodDependency *unconditionMethod = texTarget->getConditioner()->getConditionerMethodDependency(ConditionerFeature::UnconditionMethod);
-      unconditionMethod->createMethodMacro( String::ToLower( AdvancedLightBinManager::smBufferName ) + "Uncondition", macros );
-      addDependency(unconditionMethod);
-   }
-}
-
-void DeferredRTLightingFeatHLSL::processVert(   Vector<ShaderComponent*> &componentList, 
-                                                const MaterialFeatureData &fd )
-{
-   // Skip deferred features, and use forward shading instead
-   if ( fd.features[MFT_ForwardShading] )
-   {
-      Parent::processVert( componentList, fd );
-      return;
-   }
-
-   // Pass screen space position to pixel shader to compute a full screen buffer uv
-   ShaderConnector *connectComp = dynamic_cast<ShaderConnector *>( componentList[C_CONNECTOR] );
-   Var *ssPos = connectComp->getElement( RT_TEXCOORD );
-   ssPos->setName( "screenspacePos" );
-   ssPos->setStructName( "OUT" );
-   ssPos->setType( "float4" );
-
-   Var *outPosition = (Var*) LangElement::find( "hpos" );
-   AssertFatal( outPosition, "No hpos, ohnoes." );
-
-   output = new GenOp( "   @ = @;\r\n", ssPos, outPosition );
-}
-
-void DeferredRTLightingFeatHLSL::processPix( Vector<ShaderComponent*> &componentList,
-                                             const MaterialFeatureData &fd )
-{
-   // Skip deferred features, and use forward shading instead
-   if ( fd.features[MFT_ForwardShading] )
-   {
-      Parent::processPix( componentList, fd );
-      return;
-   }
-
-   MultiLine *meta = new MultiLine;
-
-   ShaderConnector *connectComp = dynamic_cast<ShaderConnector *>( componentList[C_CONNECTOR] );
-   Var *ssPos = connectComp->getElement( RT_TEXCOORD );
-   ssPos->setName( "screenspacePos" );
-   ssPos->setStructName( "IN" );
-   ssPos->setType( "float4" );
-
-   Var *uvScene = new Var;
-   uvScene->setType( "float2" );
-   uvScene->setName( "uvScene" );
-   LangElement *uvSceneDecl = new DecOp( uvScene );
-
-   String rtParamName = String::ToString( "rtParams%d", mLastTexIndex );
-   Var *rtParams = (Var*) LangElement::find( rtParamName );
-   if( !rtParams )
-   {
-      rtParams = new Var;
-      rtParams->setType( "float4" );
-      rtParams->setName( rtParamName );
-      rtParams->uniform = true;
-      rtParams->constSortPos = cspPass;
-   }
-
-   meta->addStatement( new GenOp( "   @ = @.xy / @.w;\r\n", uvSceneDecl, ssPos, ssPos ) ); // get the screen coord... its -1 to +1
-   meta->addStatement( new GenOp( "   @ = ( @ + 1.0 ) / 2.0;\r\n", uvScene, uvScene ) ); // get the screen coord to 0 to 1
-   meta->addStatement( new GenOp( "   @.y = 1.0 - @.y;\r\n", uvScene, uvScene ) ); // flip the y axis 
-   meta->addStatement( new GenOp( "   @ = ( @ * @.zw ) + @.xy;\r\n", uvScene, uvScene, rtParams, rtParams) ); // scale it down and offset it to the rt size
-
-   Var *lightInfoSamp = new Var;
-   lightInfoSamp->setType( "float4" );
-   lightInfoSamp->setName( "lightInfoSample" );
-
-   // create texture var
-   Var *lightInfoBuffer = new Var;
-   lightInfoBuffer->setType( "sampler2D" );
-   lightInfoBuffer->setName( "lightInfoBuffer" );
-   lightInfoBuffer->uniform = true;
-   lightInfoBuffer->sampler = true;
-   lightInfoBuffer->constNum = Var::getTexUnitNum();     // used as texture unit num here
-
-   // Declare the RTLighting variables in this feature, they will either be assigned
-   // in this feature, or in the tonemap/lightmap feature
-   Var *d_lightcolor = new Var( "d_lightcolor", "float3" );
-   meta->addStatement( new GenOp( "   @;\r\n", new DecOp( d_lightcolor ) ) );
-
-   Var *d_NL_Att = new Var( "d_NL_Att", "float" );
-   meta->addStatement( new GenOp( "   @;\r\n", new DecOp( d_NL_Att ) ) );
-
-   Var *d_specular = new Var( "d_specular", "float" );
-   meta->addStatement( new GenOp( "   @;\r\n", new DecOp( d_specular ) ) );
-   
-
-   // Perform the uncondition here.
-   String unconditionLightInfo = String::ToLower( AdvancedLightBinManager::smBufferName ) + "Uncondition";
-   meta->addStatement( new GenOp( avar( "   %s(tex2D(@, @), @, @, @);\r\n", 
-      unconditionLightInfo.c_str() ), lightInfoBuffer, uvScene, d_lightcolor, d_NL_Att, d_specular ) );
-
-   // If this has an interlaced pre-pass, do averaging here
-   if( fd.features[MFT_InterlacedPrePass] )
-   {
-      Var *oneOverTargetSize = (Var*) LangElement::find( "oneOverTargetSize" );
-      if( !oneOverTargetSize )
-      {
-         oneOverTargetSize = new Var;
-         oneOverTargetSize->setType( "float2" );
-         oneOverTargetSize->setName( "oneOverTargetSize" );
-         oneOverTargetSize->uniform = true;
-         oneOverTargetSize->constSortPos = cspPass;
-      }
-
-      meta->addStatement( new GenOp( "   float id_NL_Att, id_specular;\r\n   float3 id_lightcolor;\r\n" ) );
-      meta->addStatement( new GenOp( avar( "   %s(tex2D(@, @ + float2(0.0, @.y)), id_lightcolor, id_NL_Att, id_specular);\r\n", 
-         unconditionLightInfo.c_str() ), lightInfoBuffer, uvScene, oneOverTargetSize ) );
-
-      meta->addStatement( new GenOp("   @ = lerp(@, id_lightcolor, 0.5);\r\n", d_lightcolor, d_lightcolor ) );
-      meta->addStatement( new GenOp("   @ = lerp(@, id_NL_Att, 0.5);\r\n", d_NL_Att, d_NL_Att ) );
-      meta->addStatement( new GenOp("   @ = lerp(@, id_specular, 0.5);\r\n", d_specular, d_specular ) );
-   }
-
-   // This is kind of weak sauce
-   if( !fd.features[MFT_VertLit] && !fd.features[MFT_ToneMap] && !fd.features[MFT_LightMap] && !fd.features[MFT_SubSurface] )
-      meta->addStatement( new GenOp( "   @;\r\n", assignColor( new GenOp( "float4(@, 1.0)", d_lightcolor ), Material::Mul ) ) );
-
-   output = meta;
-}
-
-ShaderFeature::Resources DeferredRTLightingFeatHLSL::getResources( const MaterialFeatureData &fd )
-{
-   // Skip deferred features, and use forward shading instead
-   if ( fd.features[MFT_ForwardShading] )
-      return Parent::getResources( fd );
-
-   // HACK: See DeferredRTLightingFeatHLSL::setTexData.
-   mLastTexIndex = 0;
-
-   Resources res; 
-   res.numTex = 1;
-   res.numTexReg = 1;
-   return res;
-}
-
-void DeferredRTLightingFeatHLSL::setTexData( Material::StageData &stageDat,
-                                             const MaterialFeatureData &fd, 
-                                             RenderPassData &passData, 
-                                             U32 &texIndex )
-{
-   // Skip deferred features, and use forward shading instead
-   if ( fd.features[MFT_ForwardShading] )
-   {
-      Parent::setTexData( stageDat, fd, passData, texIndex );
-      return;
-   }
-
-   NamedTexTarget *texTarget = NamedTexTarget::find( AdvancedLightBinManager::smBufferName );
-   if( texTarget )
-   {
-      // HACK: We store this for use in DeferredRTLightingFeatHLSL::processPix()
-      // which cannot deduce the texture unit itself.
-      mLastTexIndex = texIndex;
-
-      passData.mTexType[ texIndex ] = Material::TexTarget;
-      passData.mTexSlot[ texIndex++ ].texTarget = texTarget;
-   }
-}
-
-
-void DeferredBumpFeatHLSL::processVert(   Vector<ShaderComponent*> &componentList, 
-                                          const MaterialFeatureData &fd )
-{
-   if( fd.features[MFT_PrePassConditioner] )
-   {
-      // There is an output conditioner active, so we need to supply a transform
-      // to the pixel shader. 
-      MultiLine *meta = new MultiLine;
-
-      // We need the view to tangent space transform in the pixel shader.
-      getOutViewToTangent( componentList, meta, fd );
-
-      // Make sure there are texcoords
-      if( !fd.features[MFT_Parallax] && !fd.features[MFT_DiffuseMap] )
-      {
-         const bool useTexAnim = fd.features[MFT_TexAnim];
-
-         getOutTexCoord(   "texCoord", 
-                           "float2", 
-                           true, 
-                           useTexAnim, 
-                           meta, 
-                           componentList );
-
-         if ( fd.features.hasFeature( MFT_DetailNormalMap ) )
-            addOutDetailTexCoord( componentList, 
-                                  meta,
-                                  useTexAnim );
-      }
-
-      output = meta;
-   }
-   else if (   fd.materialFeatures[MFT_NormalsOut] || 
-               fd.features[MFT_ForwardShading] || 
-               !fd.features[MFT_RTLighting] )
-   {
-      Parent::processVert( componentList, fd );
-      return;
-   }
-   else
-   {
-      output = NULL;
-   }
-}
-
-void DeferredBumpFeatHLSL::processPix( Vector<ShaderComponent*> &componentList, 
-                                       const MaterialFeatureData &fd )
-{
-   // NULL output in case nothing gets handled
-   output = NULL;
-
-   if( fd.features[MFT_PrePassConditioner] )
-   {
-      MultiLine *meta = new MultiLine;
-
-      Var *viewToTangent = getInViewToTangent( componentList );
-
-      // create texture var
-      Var *bumpMap = getNormalMapTex();
-      Var *texCoord = getInTexCoord( "texCoord", "float2", true, componentList );
-      LangElement *texOp = new GenOp( "tex2D(@, @)", bumpMap, texCoord );
-
-      // create bump normal
-      Var *bumpNorm = new Var;
-      bumpNorm->setName( "bumpNormal" );
-      bumpNorm->setType( "float4" );
-
-      LangElement *bumpNormDecl = new DecOp( bumpNorm );
-      meta->addStatement( expandNormalMap( texOp, bumpNormDecl, bumpNorm, fd ) );
-
-      // If we have a detail normal map we add the xy coords of
-      // it to the base normal map.  This gives us the effect we
-      // want with few instructions and minial artifacts.
-      if ( fd.features.hasFeature( MFT_DetailNormalMap ) )
-      {
-         bumpMap = new Var;
-         bumpMap->setType( "sampler2D" );
-         bumpMap->setName( "detailBumpMap" );
-         bumpMap->uniform = true;
-         bumpMap->sampler = true;
-         bumpMap->constNum = Var::getTexUnitNum();
-
-         texCoord = getInTexCoord( "detCoord", "float2", true, componentList );
-         texOp = new GenOp( "tex2D(@, @)", bumpMap, texCoord );
-
-         Var *detailBump = new Var;
-         detailBump->setName( "detailBump" );
-         detailBump->setType( "float4" );
-         meta->addStatement( expandNormalMap( texOp, new DecOp( detailBump ), detailBump, fd ) );
-
-         Var *detailBumpScale = new Var;
-         detailBumpScale->setType( "float" );
-         detailBumpScale->setName( "detailBumpStrength" );
-         detailBumpScale->uniform = true;
-         detailBumpScale->constSortPos = cspPass;
-         meta->addStatement( new GenOp( "   @.xy += @.xy * @;\r\n", bumpNorm, detailBump, detailBumpScale ) );
-      }
-
-      // This var is read from GBufferConditionerHLSL and 
-      // used in the prepass output.
-      //
-      // By using the 'half' type here we get a bunch of partial
-      // precision optimized code on further operations on the normal
-      // which helps alot on older Geforce cards.
-      //
-      Var *gbNormal = new Var;
-      gbNormal->setName( "gbNormal" );
-      gbNormal->setType( "half3" );
-      LangElement *gbNormalDecl = new DecOp( gbNormal );
-
-      // Normalize is done later... 
-      // Note: The reverse mul order is intentional. Affine matrix.
-      meta->addStatement( new GenOp( "   @ = (half3)mul( @.xyz, @ );\r\n", gbNormalDecl, bumpNorm, viewToTangent ) );
-
-      output = meta;
-      return;
-   }
-   else if (fd.features[MFT_AccuMap]) 
-   {
-      Var *bumpSample = (Var *)LangElement::find( "bumpSample" );
-      if( bumpSample == NULL )
-      {
-         MultiLine *meta = new MultiLine;
-
-         Var *texCoord = getInTexCoord( "texCoord", "float2", true, componentList );
-
-         Var *bumpMap = getNormalMapTex();
-
-         bumpSample = new Var;
-         bumpSample->setType( "float4" );
-         bumpSample->setName( "bumpSample" );
-         LangElement *bumpSampleDecl = new DecOp( bumpSample );
-
-         meta->addStatement( new GenOp( "   @ = tex2D(@, @);\r\n", bumpSampleDecl, bumpMap, texCoord ) );
-
-         if ( fd.features.hasFeature( MFT_DetailNormalMap ) )
-         {
-            Var *bumpMap = (Var*)LangElement::find( "detailBumpMap" );
-            if ( !bumpMap ) {
-               bumpMap = new Var;
-               bumpMap->setType( "sampler2D" );
-               bumpMap->setName( "detailBumpMap" );
-               bumpMap->uniform = true;
-               bumpMap->sampler = true;
-               bumpMap->constNum = Var::getTexUnitNum();
-            }
-
-            texCoord = getInTexCoord( "detCoord", "float2", true, componentList );
-            LangElement *texOp = new GenOp( "tex2D(@, @)", bumpMap, texCoord );
-
-            Var *detailBump = new Var;
-            detailBump->setName( "detailBump" );
-            detailBump->setType( "float4" );
-            meta->addStatement( expandNormalMap( texOp, new DecOp( detailBump ), detailBump, fd ) );
-
-            Var *detailBumpScale = new Var;
-            detailBumpScale->setType( "float" );
-            detailBumpScale->setName( "detailBumpStrength" );
-            detailBumpScale->uniform = true;
-            detailBumpScale->constSortPos = cspPass;
-            meta->addStatement( new GenOp( "   @.xy += @.xy * @;\r\n", bumpSample, detailBump, detailBumpScale ) );
-         }
-
-         output = meta;
-
-         return;
-      }
-   } 
-   else if (   fd.materialFeatures[MFT_NormalsOut] || 
-               fd.features[MFT_ForwardShading] || 
-               !fd.features[MFT_RTLighting] )
-   {
-      Parent::processPix( componentList, fd );
-      return;
-   }
-   else if ( fd.features[MFT_PixSpecular] && !fd.features[MFT_SpecularMap] )
-   {
-      Var *bumpSample = (Var *)LangElement::find( "bumpSample" );
-      if( bumpSample == NULL )
-      {
-         Var *texCoord = getInTexCoord( "texCoord", "float2", true, componentList );
-
-         Var *bumpMap = getNormalMapTex();
-
-         bumpSample = new Var;
-         bumpSample->setType( "float4" );
-         bumpSample->setName( "bumpSample" );
-         LangElement *bumpSampleDecl = new DecOp( bumpSample );
-
-         output = new GenOp( "   @ = tex2D(@, @);\r\n", bumpSampleDecl, bumpMap, texCoord );
-         return;
-      }
-   }
-
-   output = NULL;
-}
-
-ShaderFeature::Resources DeferredBumpFeatHLSL::getResources( const MaterialFeatureData &fd )
-{
-   if (  fd.materialFeatures[MFT_NormalsOut] || 
-         fd.features[MFT_ForwardShading] || 
-         fd.features[MFT_Parallax] ||
-         !fd.features[MFT_RTLighting] )
-      return Parent::getResources( fd );
-
-   Resources res; 
-   if(!fd.features[MFT_SpecularMap])
-   {
-      res.numTex = 1;
-      res.numTexReg = 1;
-
-      if (  fd.features[MFT_PrePassConditioner] &&
-            fd.features.hasFeature( MFT_DetailNormalMap ) )
-      {
-         res.numTex += 1;
-         if ( !fd.features.hasFeature( MFT_DetailMap ) )
-            res.numTexReg += 1;
-      }
-   }
-
-   return res;
-}
-
-void DeferredBumpFeatHLSL::setTexData( Material::StageData &stageDat,
-                                       const MaterialFeatureData &fd, 
-                                       RenderPassData &passData, 
-                                       U32 &texIndex )
-{
-   if (  fd.materialFeatures[MFT_NormalsOut] || 
-         fd.features[MFT_ForwardShading] || 
-         !fd.features[MFT_RTLighting] )
-   {
-      Parent::setTexData( stageDat, fd, passData, texIndex );
-      return;
-   }
-
-   if (  !fd.features[MFT_PrePassConditioner] && fd.features[MFT_AccuMap] )
-   {
-      passData.mTexType[ texIndex ] = Material::Bump;
-      passData.mTexSlot[ texIndex++ ].texObject = stageDat.getTex( MFT_NormalMap );
-
-      if (  fd.features.hasFeature( MFT_DetailNormalMap ) )
-      {
-         passData.mTexType[ texIndex ] = Material::DetailBump;
-         passData.mTexSlot[ texIndex++ ].texObject = stageDat.getTex( MFT_DetailNormalMap );
-      }
-   } else if (  !fd.features[MFT_Parallax] && !fd.features[MFT_SpecularMap] &&
-         ( fd.features[MFT_PrePassConditioner] ||
-           fd.features[MFT_PixSpecular] ) )
-   {
-      passData.mTexType[ texIndex ] = Material::Bump;
-      passData.mTexSlot[ texIndex++ ].texObject = stageDat.getTex( MFT_NormalMap );
-
-      if (  fd.features[MFT_PrePassConditioner] &&
-            fd.features.hasFeature( MFT_DetailNormalMap ) )
-      {
-         passData.mTexType[ texIndex ] = Material::DetailBump;
-         passData.mTexSlot[ texIndex++ ].texObject = stageDat.getTex( MFT_DetailNormalMap );
-      }
-   }
-}
-
-
-void DeferredPixelSpecularHLSL::processVert( Vector<ShaderComponent*> &componentList, 
-                                             const MaterialFeatureData &fd )
-{
-   if( fd.features[MFT_ForwardShading] || !fd.features[MFT_RTLighting] )
-   {
-      Parent::processVert( componentList, fd );
-      return;
-   }
-   output = NULL;
-}
-
-void DeferredPixelSpecularHLSL::processPix(  Vector<ShaderComponent*> &componentList, 
-                                             const MaterialFeatureData &fd )
-{
-   if( fd.features[MFT_ForwardShading] || !fd.features[MFT_RTLighting] )
-   {
-      Parent::processPix( componentList, fd );
-      return;
-   }
-
-   MultiLine *meta = new MultiLine;
-
-   Var *specular = new Var;
-   specular->setType( "float" );
-   specular->setName( "specular" );
-   LangElement * specDecl = new DecOp( specular );
-
-   Var *specCol = (Var*)LangElement::find( "specularColor" );
-   if(specCol == NULL)
-   {
-      specCol = new Var;
-      specCol->setType( "float4" );
-      specCol->setName( "specularColor" );
-      specCol->uniform = true;
-      specCol->constSortPos = cspPotentialPrimitive;
-   }
-
-   Var *specPow = new Var;
-   specPow->setType( "float" );
-   specPow->setName( "specularPower" );
-
-   // If the gloss map flag is set, than the specular power is in the alpha
-   // channel of the specular map
-   if( fd.features[ MFT_GlossMap ] )
-      meta->addStatement( new GenOp( "   @ = @.a * 255;\r\n", new DecOp( specPow ), specCol ) );
-   else
-   {
-      specPow->uniform = true;
-      specPow->constSortPos = cspPotentialPrimitive;
-   }
-
-   Var *specStrength = new Var;
-   specStrength->setType( "float" );
-   specStrength->setName( "specularStrength" );
-   specStrength->uniform = true;
-   specStrength->constSortPos = cspPotentialPrimitive;
-
-   Var *lightInfoSamp = (Var *)LangElement::find( "lightInfoSample" );
-   Var *d_specular = (Var*)LangElement::find( "d_specular" );
-   Var *d_NL_Att = (Var*)LangElement::find( "d_NL_Att" );
-
-   AssertFatal( lightInfoSamp && d_specular && d_NL_Att,
-      "DeferredPixelSpecularHLSL::processPix - Something hosed the deferred features!" );
-
-   if (fd.features[ MFT_AccuMap ]) {
-      // change specularity where the accu texture is applied
-      Var *accuPlc = (Var*) LangElement::find( "plc" );
-      Var *accuSpecular = (Var*)LangElement::find( "accuSpecular" );
-      if(accuPlc != NULL && accuSpecular != NULL)
-         //d_specular = clamp(lerp( d_specular, accuSpecular * d_specular, plc.a), 0, 1)
-         meta->addStatement( new GenOp( "   @ = clamp( lerp( @, @ * @, @.a), 0, 1);\r\n", d_specular, d_specular, accuSpecular, d_specular, accuPlc ) );
-   }
-	  
-   // (a^m)^n = a^(m*n)
-   meta->addStatement( new GenOp( "   @ = pow( abs(@), max((@ / AL_ConstantSpecularPower),1.0f)) * @;\r\n", 
-      specDecl, d_specular, specPow, specStrength ) );
-
-   LangElement *specMul = new GenOp( "float4( @.rgb, 0 ) * @", specCol, specular );
-   LangElement *final = specMul;
-
-   // We we have a normal map then mask the specular 
-   if( !fd.features[MFT_SpecularMap] && fd.features[MFT_NormalMap] )
-   {
-      Var *bumpSample = (Var*)LangElement::find( "bumpSample" );
-      final = new GenOp( "@ * @.a", final, bumpSample );
-   }
-
-   // add to color
-   meta->addStatement( new GenOp( "   @;\r\n", assignColor( final, Material::Add ) ) );
-
-   output = meta;
-}
-
-ShaderFeature::Resources DeferredPixelSpecularHLSL::getResources( const MaterialFeatureData &fd )
-{
-   if( fd.features[MFT_ForwardShading] || !fd.features[MFT_RTLighting] )
-      return Parent::getResources( fd );
-
-   Resources res; 
-   return res;
-}
-
-
-ShaderFeature::Resources DeferredMinnaertHLSL::getResources( const MaterialFeatureData &fd )
-{
-   Resources res;
-   if( !fd.features[MFT_ForwardShading] && fd.features[MFT_RTLighting] )
-   {
-      res.numTex = 1;
-      res.numTexReg = 1;
-   }
-   return res;
-}
-
-void DeferredMinnaertHLSL::setTexData( Material::StageData &stageDat,
-                                       const MaterialFeatureData &fd, 
-                                       RenderPassData &passData, 
-                                       U32 &texIndex )
-{
-   if( !fd.features[MFT_ForwardShading] && fd.features[MFT_RTLighting] )
-   {
-      NamedTexTarget *texTarget = NamedTexTarget::find(RenderPrePassMgr::BufferName);
-      if ( texTarget )
-      {
-         passData.mTexType[ texIndex ] = Material::TexTarget;
-         passData.mTexSlot[ texIndex++ ].texTarget = texTarget;
-      }
-   }
-}
-
-void DeferredMinnaertHLSL::processPixMacros( Vector<GFXShaderMacro> &macros, 
-                                             const MaterialFeatureData &fd  )
-{
-   if( !fd.features[MFT_ForwardShading] && fd.features[MFT_RTLighting] )
-   {
-      // Pull in the uncondition method for the g buffer
-      NamedTexTarget *texTarget = NamedTexTarget::find( RenderPrePassMgr::BufferName );
-      if ( texTarget && texTarget->getConditioner() )
-      {
-         ConditionerMethodDependency *unconditionMethod = texTarget->getConditioner()->getConditionerMethodDependency(ConditionerFeature::UnconditionMethod);
-         unconditionMethod->createMethodMacro( String::ToLower(RenderPrePassMgr::BufferName) + "Uncondition", macros );
-         addDependency(unconditionMethod);
-      }
-   }
-}
-
-void DeferredMinnaertHLSL::processVert(   Vector<ShaderComponent*> &componentList,
-                                          const MaterialFeatureData &fd )
-{
-   // If there is no deferred information, bail on this feature
-   if( fd.features[MFT_ForwardShading] || !fd.features[MFT_RTLighting] )
-   {
-      output = NULL;
-      return;
-   }
-
-   // Make sure we pass the world space position to the
-   // pixel shader so we can calculate a view vector.
-   MultiLine *meta = new MultiLine;
-   addOutWsPosition( componentList, fd.features[MFT_UseInstancing], meta );
-   output = meta;
-}
-
-void DeferredMinnaertHLSL::processPix( Vector<ShaderComponent*> &componentList, 
-                                       const MaterialFeatureData &fd )
-{
-   // If there is no deferred information, bail on this feature
-   if( fd.features[MFT_ForwardShading] || !fd.features[MFT_RTLighting] )
-   {
-      output = NULL;
-      return;
-   }
-
-   Var *minnaertConstant = new Var;
-   minnaertConstant->setType( "float" );
-   minnaertConstant->setName( "minnaertConstant" );
-   minnaertConstant->uniform = true;
-   minnaertConstant->constSortPos = cspPotentialPrimitive;
-
-   // create texture var
-   Var *prepassBuffer = new Var;
-   prepassBuffer->setType( "sampler2D" );
-   prepassBuffer->setName( "prepassBuffer" );
-   prepassBuffer->uniform = true;
-   prepassBuffer->sampler = true;
-   prepassBuffer->constNum = Var::getTexUnitNum();     // used as texture unit num here
-
-   // Texture coord
-   Var *uvScene = (Var*) LangElement::find( "uvScene" );
-   AssertFatal(uvScene != NULL, "Unable to find UVScene, no RTLighting feature?");
-
-   MultiLine *meta = new MultiLine;
-
-   // Get the world space view vector.
-   Var *wsViewVec = getWsView( getInWsPosition( componentList ), meta );
-
-   String unconditionPrePassMethod = String::ToLower(RenderPrePassMgr::BufferName) + "Uncondition";
-
-   Var *d_NL_Att = (Var*)LangElement::find( "d_NL_Att" );
-
-   meta->addStatement( new GenOp( avar( "   float4 normalDepth = %s(@, @);\r\n", unconditionPrePassMethod.c_str() ), prepassBuffer, uvScene ) );
-   meta->addStatement( new GenOp( "   float vDotN = dot(normalDepth.xyz, @);\r\n", wsViewVec ) );
-   meta->addStatement( new GenOp( "   float Minnaert = pow( @, @) * pow(vDotN, 1.0 - @);\r\n", d_NL_Att, minnaertConstant, minnaertConstant ) );
-   meta->addStatement( new GenOp( "   @;\r\n", assignColor( new GenOp( "float4(Minnaert, Minnaert, Minnaert, 1.0)" ), Material::Mul ) ) );
-
-   output = meta;
-}
-
-
-void DeferredSubSurfaceHLSL::processPix(  Vector<ShaderComponent*> &componentList, 
-                                          const MaterialFeatureData &fd )
-{
-   // If there is no deferred information, bail on this feature
-   if( fd.features[MFT_ForwardShading] || !fd.features[MFT_RTLighting] )
-   {
-      output = NULL;
-      return;
-   }
-
-   Var *subSurfaceParams = new Var;
-   subSurfaceParams->setType( "float4" );
-   subSurfaceParams->setName( "subSurfaceParams" );
-   subSurfaceParams->uniform = true;
-   subSurfaceParams->constSortPos = cspPotentialPrimitive;
-
-   Var *d_lightcolor = (Var*)LangElement::find( "d_lightcolor" );
-   Var *d_NL_Att = (Var*)LangElement::find( "d_NL_Att" );
-
-   MultiLine *meta = new MultiLine;
-   meta->addStatement( new GenOp( "   float subLamb = smoothstep(-@.a, 1.0, @) - smoothstep(0.0, 1.0, @);\r\n", subSurfaceParams, d_NL_Att, d_NL_Att ) );
-   meta->addStatement( new GenOp( "   subLamb = max(0.0, subLamb);\r\n" ) );
-   meta->addStatement( new GenOp( "   @;\r\n", assignColor( new GenOp( "float4(@ + (subLamb * @.rgb), 1.0)", d_lightcolor, subSurfaceParams ), Material::Mul ) ) );
-
-   output = meta;
-}
+//-----------------------------------------------------------------------------
+// Copyright (c) 2012 GarageGames, LLC
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to
+// deal in the Software without restriction, including without limitation the
+// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+// sell copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+// IN THE SOFTWARE.
+//-----------------------------------------------------------------------------
+
+#include "platform/platform.h"
+#include "lighting/advanced/hlsl/advancedLightingFeaturesHLSL.h"
+
+#include "lighting/advanced/advancedLightBinManager.h"
+#include "shaderGen/langElement.h"
+#include "shaderGen/shaderOp.h"
+#include "shaderGen/conditionerFeature.h"
+#include "renderInstance/renderPrePassMgr.h"
+#include "materials/processedMaterial.h"
+#include "materials/materialFeatureTypes.h"
+
+
+void DeferredRTLightingFeatHLSL::processPixMacros( Vector<GFXShaderMacro> &macros, 
+                                                   const MaterialFeatureData &fd  )
+{
+   // Skip deferred features, and use forward shading instead
+   if ( fd.features[MFT_ForwardShading] )
+   {
+      Parent::processPixMacros( macros, fd );
+      return;
+   }
+
+   // Pull in the uncondition method for the light info buffer
+   NamedTexTarget *texTarget = NamedTexTarget::find( AdvancedLightBinManager::smBufferName );
+   if ( texTarget && texTarget->getConditioner() )
+   {
+      ConditionerMethodDependency *unconditionMethod = texTarget->getConditioner()->getConditionerMethodDependency(ConditionerFeature::UnconditionMethod);
+      unconditionMethod->createMethodMacro( String::ToLower( AdvancedLightBinManager::smBufferName ) + "Uncondition", macros );
+      addDependency(unconditionMethod);
+   }
+}
+
+void DeferredRTLightingFeatHLSL::processVert(   Vector<ShaderComponent*> &componentList, 
+                                                const MaterialFeatureData &fd )
+{
+   // Skip deferred features, and use forward shading instead
+   if ( fd.features[MFT_ForwardShading] )
+   {
+      Parent::processVert( componentList, fd );
+      return;
+   }
+
+   // Pass screen space position to pixel shader to compute a full screen buffer uv
+   ShaderConnector *connectComp = dynamic_cast<ShaderConnector *>( componentList[C_CONNECTOR] );
+   Var *ssPos = connectComp->getElement( RT_TEXCOORD );
+   ssPos->setName( "screenspacePos" );
+   ssPos->setStructName( "OUT" );
+   ssPos->setType( "float4" );
+
+   Var *outPosition = (Var*) LangElement::find( "hpos" );
+   AssertFatal( outPosition, "No hpos, ohnoes." );
+
+   output = new GenOp( "   @ = @;\r\n", ssPos, outPosition );
+}
+
+void DeferredRTLightingFeatHLSL::processPix( Vector<ShaderComponent*> &componentList,
+                                             const MaterialFeatureData &fd )
+{
+   // Skip deferred features, and use forward shading instead
+   if ( fd.features[MFT_ForwardShading] )
+   {
+      Parent::processPix( componentList, fd );
+      return;
+   }
+
+   MultiLine *meta = new MultiLine;
+
+   ShaderConnector *connectComp = dynamic_cast<ShaderConnector *>( componentList[C_CONNECTOR] );
+   Var *ssPos = connectComp->getElement( RT_TEXCOORD );
+   ssPos->setName( "screenspacePos" );
+   ssPos->setStructName( "IN" );
+   ssPos->setType( "float4" );
+
+   Var *uvScene = new Var;
+   uvScene->setType( "float2" );
+   uvScene->setName( "uvScene" );
+   LangElement *uvSceneDecl = new DecOp( uvScene );
+
+   String rtParamName = String::ToString( "rtParams%d", mLastTexIndex );
+   Var *rtParams = (Var*) LangElement::find( rtParamName );
+   if( !rtParams )
+   {
+      rtParams = new Var;
+      rtParams->setType( "float4" );
+      rtParams->setName( rtParamName );
+      rtParams->uniform = true;
+      rtParams->constSortPos = cspPass;
+   }
+
+   meta->addStatement( new GenOp( "   @ = @.xy / @.w;\r\n", uvSceneDecl, ssPos, ssPos ) ); // get the screen coord... its -1 to +1
+   meta->addStatement( new GenOp( "   @ = ( @ + 1.0 ) / 2.0;\r\n", uvScene, uvScene ) ); // get the screen coord to 0 to 1
+   meta->addStatement( new GenOp( "   @.y = 1.0 - @.y;\r\n", uvScene, uvScene ) ); // flip the y axis 
+   meta->addStatement( new GenOp( "   @ = ( @ * @.zw ) + @.xy;\r\n", uvScene, uvScene, rtParams, rtParams) ); // scale it down and offset it to the rt size
+
+   Var *lightInfoSamp = new Var;
+   lightInfoSamp->setType( "float4" );
+   lightInfoSamp->setName( "lightInfoSample" );
+
+   // create texture var
+   Var *lightInfoBuffer = new Var;
+   lightInfoBuffer->setType( "sampler2D" );
+   lightInfoBuffer->setName( "lightInfoBuffer" );
+   lightInfoBuffer->uniform = true;
+   lightInfoBuffer->sampler = true;
+   lightInfoBuffer->constNum = Var::getTexUnitNum();     // used as texture unit num here
+
+   // Declare the RTLighting variables in this feature, they will either be assigned
+   // in this feature, or in the tonemap/lightmap feature
+   Var *d_lightcolor = new Var( "d_lightcolor", "float3" );
+   meta->addStatement( new GenOp( "   @;\r\n", new DecOp( d_lightcolor ) ) );
+
+   Var *d_NL_Att = new Var( "d_NL_Att", "float" );
+   meta->addStatement( new GenOp( "   @;\r\n", new DecOp( d_NL_Att ) ) );
+
+   Var *d_specular = new Var( "d_specular", "float" );
+   meta->addStatement( new GenOp( "   @;\r\n", new DecOp( d_specular ) ) );
+   
+
+   // Perform the uncondition here.
+   String unconditionLightInfo = String::ToLower( AdvancedLightBinManager::smBufferName ) + "Uncondition";
+   meta->addStatement( new GenOp( avar( "   %s(tex2D(@, @), @, @, @);\r\n", 
+      unconditionLightInfo.c_str() ), lightInfoBuffer, uvScene, d_lightcolor, d_NL_Att, d_specular ) );
+
+   // If this has an interlaced pre-pass, do averaging here
+   if( fd.features[MFT_InterlacedPrePass] )
+   {
+      Var *oneOverTargetSize = (Var*) LangElement::find( "oneOverTargetSize" );
+      if( !oneOverTargetSize )
+      {
+         oneOverTargetSize = new Var;
+         oneOverTargetSize->setType( "float2" );
+         oneOverTargetSize->setName( "oneOverTargetSize" );
+         oneOverTargetSize->uniform = true;
+         oneOverTargetSize->constSortPos = cspPass;
+      }
+
+      meta->addStatement( new GenOp( "   float id_NL_Att, id_specular;\r\n   float3 id_lightcolor;\r\n" ) );
+      meta->addStatement( new GenOp( avar( "   %s(tex2D(@, @ + float2(0.0, @.y)), id_lightcolor, id_NL_Att, id_specular);\r\n", 
+         unconditionLightInfo.c_str() ), lightInfoBuffer, uvScene, oneOverTargetSize ) );
+
+      meta->addStatement( new GenOp("   @ = lerp(@, id_lightcolor, 0.5);\r\n", d_lightcolor, d_lightcolor ) );
+      meta->addStatement( new GenOp("   @ = lerp(@, id_NL_Att, 0.5);\r\n", d_NL_Att, d_NL_Att ) );
+      meta->addStatement( new GenOp("   @ = lerp(@, id_specular, 0.5);\r\n", d_specular, d_specular ) );
+   }
+
+   // This is kind of weak sauce
+   if( !fd.features[MFT_VertLit] && !fd.features[MFT_ToneMap] && !fd.features[MFT_LightMap] && !fd.features[MFT_SubSurface] )
+      meta->addStatement( new GenOp( "   @;\r\n", assignColor( new GenOp( "float4(@, 1.0)", d_lightcolor ), Material::Mul ) ) );
+
+   output = meta;
+}
+
+ShaderFeature::Resources DeferredRTLightingFeatHLSL::getResources( const MaterialFeatureData &fd )
+{
+   // Skip deferred features, and use forward shading instead
+   if ( fd.features[MFT_ForwardShading] )
+      return Parent::getResources( fd );
+
+   // HACK: See DeferredRTLightingFeatHLSL::setTexData.
+   mLastTexIndex = 0;
+
+   Resources res; 
+   res.numTex = 1;
+   res.numTexReg = 1;
+   return res;
+}
+
+void DeferredRTLightingFeatHLSL::setTexData( Material::StageData &stageDat,
+                                             const MaterialFeatureData &fd, 
+                                             RenderPassData &passData, 
+                                             U32 &texIndex )
+{
+   // Skip deferred features, and use forward shading instead
+   if ( fd.features[MFT_ForwardShading] )
+   {
+      Parent::setTexData( stageDat, fd, passData, texIndex );
+      return;
+   }
+
+   NamedTexTarget *texTarget = NamedTexTarget::find( AdvancedLightBinManager::smBufferName );
+   if( texTarget )
+   {
+      // HACK: We store this for use in DeferredRTLightingFeatHLSL::processPix()
+      // which cannot deduce the texture unit itself.
+      mLastTexIndex = texIndex;
+
+      passData.mTexType[ texIndex ] = Material::TexTarget;
+      passData.mTexSlot[ texIndex++ ].texTarget = texTarget;
+   }
+}
+
+
+void DeferredBumpFeatHLSL::processVert(   Vector<ShaderComponent*> &componentList, 
+                                          const MaterialFeatureData &fd )
+{
+   if( fd.features[MFT_PrePassConditioner] )
+   {
+      // There is an output conditioner active, so we need to supply a transform
+      // to the pixel shader. 
+      MultiLine *meta = new MultiLine;
+
+      // We need the view to tangent space transform in the pixel shader.
+      getOutViewToTangent( componentList, meta, fd );
+
+      // Make sure there are texcoords
+      if( !fd.features[MFT_Parallax] && !fd.features[MFT_DiffuseMap] )
+      {
+         const bool useTexAnim = fd.features[MFT_TexAnim];
+
+         getOutTexCoord(   "texCoord", 
+                           "float2", 
+                           true, 
+                           useTexAnim, 
+                           meta, 
+                           componentList );
+
+         if ( fd.features.hasFeature( MFT_DetailNormalMap ) )
+            addOutDetailTexCoord( componentList, 
+                                  meta,
+                                  useTexAnim );
+      }
+
+      output = meta;
+   }
+   else if (   fd.materialFeatures[MFT_NormalsOut] || 
+               fd.features[MFT_ForwardShading] || 
+               !fd.features[MFT_RTLighting] )
+   {
+      Parent::processVert( componentList, fd );
+      return;
+   }
+   else
+   {
+      output = NULL;
+   }
+}
+
+void DeferredBumpFeatHLSL::processPix( Vector<ShaderComponent*> &componentList, 
+                                       const MaterialFeatureData &fd )
+{
+   // NULL output in case nothing gets handled
+   output = NULL;
+
+   if( fd.features[MFT_PrePassConditioner] )
+   {
+      MultiLine *meta = new MultiLine;
+
+      Var *viewToTangent = getInViewToTangent( componentList );
+
+      // create texture var
+      Var *bumpMap = getNormalMapTex();
+      Var *texCoord = getInTexCoord( "texCoord", "float2", true, componentList );
+      LangElement *texOp = new GenOp( "tex2D(@, @)", bumpMap, texCoord );
+
+      // create bump normal
+      Var *bumpNorm = new Var;
+      bumpNorm->setName( "bumpNormal" );
+      bumpNorm->setType( "float4" );
+
+      LangElement *bumpNormDecl = new DecOp( bumpNorm );
+      meta->addStatement( expandNormalMap( texOp, bumpNormDecl, bumpNorm, fd ) );
+
+      // If we have a detail normal map we add the xy coords of
+      // it to the base normal map.  This gives us the effect we
+      // want with few instructions and minial artifacts.
+      if ( fd.features.hasFeature( MFT_DetailNormalMap ) )
+      {
+         bumpMap = new Var;
+         bumpMap->setType( "sampler2D" );
+         bumpMap->setName( "detailBumpMap" );
+         bumpMap->uniform = true;
+         bumpMap->sampler = true;
+         bumpMap->constNum = Var::getTexUnitNum();
+
+         texCoord = getInTexCoord( "detCoord", "float2", true, componentList );
+         texOp = new GenOp( "tex2D(@, @)", bumpMap, texCoord );
+
+         Var *detailBump = new Var;
+         detailBump->setName( "detailBump" );
+         detailBump->setType( "float4" );
+         meta->addStatement( expandNormalMap( texOp, new DecOp( detailBump ), detailBump, fd ) );
+
+         Var *detailBumpScale = new Var;
+         detailBumpScale->setType( "float" );
+         detailBumpScale->setName( "detailBumpStrength" );
+         detailBumpScale->uniform = true;
+         detailBumpScale->constSortPos = cspPass;
+         meta->addStatement( new GenOp( "   @.xy += @.xy * @;\r\n", bumpNorm, detailBump, detailBumpScale ) );
+      }
+
+      // This var is read from GBufferConditionerHLSL and 
+      // used in the prepass output.
+      //
+      // By using the 'half' type here we get a bunch of partial
+      // precision optimized code on further operations on the normal
+      // which helps alot on older Geforce cards.
+      //
+      Var *gbNormal = new Var;
+      gbNormal->setName( "gbNormal" );
+      gbNormal->setType( "half3" );
+      LangElement *gbNormalDecl = new DecOp( gbNormal );
+
+      // Normalize is done later... 
+      // Note: The reverse mul order is intentional. Affine matrix.
+      meta->addStatement( new GenOp( "   @ = (half3)mul( @.xyz, @ );\r\n", gbNormalDecl, bumpNorm, viewToTangent ) );
+
+      output = meta;
+      return;
+   }
+   else if (   fd.materialFeatures[MFT_NormalsOut] || 
+               fd.features[MFT_ForwardShading] || 
+               !fd.features[MFT_RTLighting] )
+   {
+      Parent::processPix( componentList, fd );
+      return;
+   }
+   else if ( fd.features[MFT_PixSpecular] && !fd.features[MFT_SpecularMap] )
+   {
+      Var *bumpSample = (Var *)LangElement::find( "bumpSample" );
+      if( bumpSample == NULL )
+      {
+         Var *texCoord = getInTexCoord( "texCoord", "float2", true, componentList );
+
+         Var *bumpMap = getNormalMapTex();
+
+         bumpSample = new Var;
+         bumpSample->setType( "float4" );
+         bumpSample->setName( "bumpSample" );
+         LangElement *bumpSampleDecl = new DecOp( bumpSample );
+
+         output = new GenOp( "   @ = tex2D(@, @);\r\n", bumpSampleDecl, bumpMap, texCoord );
+         return;
+      }
+   }
+
+   output = NULL;
+}
+
+ShaderFeature::Resources DeferredBumpFeatHLSL::getResources( const MaterialFeatureData &fd )
+{
+   if (  fd.materialFeatures[MFT_NormalsOut] || 
+         fd.features[MFT_ForwardShading] || 
+         fd.features[MFT_Parallax] ||
+         !fd.features[MFT_RTLighting] )
+      return Parent::getResources( fd );
+
+   Resources res; 
+   if(!fd.features[MFT_SpecularMap])
+   {
+      res.numTex = 1;
+      res.numTexReg = 1;
+
+      if (  fd.features[MFT_PrePassConditioner] &&
+            fd.features.hasFeature( MFT_DetailNormalMap ) )
+      {
+         res.numTex += 1;
+         if ( !fd.features.hasFeature( MFT_DetailMap ) )
+            res.numTexReg += 1;
+      }
+   }
+
+   return res;
+}
+
+void DeferredBumpFeatHLSL::setTexData( Material::StageData &stageDat,
+                                       const MaterialFeatureData &fd, 
+                                       RenderPassData &passData, 
+                                       U32 &texIndex )
+{
+   if (  fd.materialFeatures[MFT_NormalsOut] || 
+         fd.features[MFT_ForwardShading] || 
+         !fd.features[MFT_RTLighting] )
+   {
+      Parent::setTexData( stageDat, fd, passData, texIndex );
+      return;
+   }
+
+   if (  !fd.features[MFT_Parallax] && !fd.features[MFT_SpecularMap] &&
+         ( fd.features[MFT_PrePassConditioner] ||
+           fd.features[MFT_PixSpecular] ) )
+   {
+      passData.mTexType[ texIndex ] = Material::Bump;
+      passData.mTexSlot[ texIndex++ ].texObject = stageDat.getTex( MFT_NormalMap );
+
+      if (  fd.features[MFT_PrePassConditioner] &&
+            fd.features.hasFeature( MFT_DetailNormalMap ) )
+      {
+         passData.mTexType[ texIndex ] = Material::DetailBump;
+         passData.mTexSlot[ texIndex++ ].texObject = stageDat.getTex( MFT_DetailNormalMap );
+      }
+   }
+}
+
+
+void DeferredPixelSpecularHLSL::processVert( Vector<ShaderComponent*> &componentList, 
+                                             const MaterialFeatureData &fd )
+{
+   if( fd.features[MFT_ForwardShading] || !fd.features[MFT_RTLighting] )
+   {
+      Parent::processVert( componentList, fd );
+      return;
+   }
+   output = NULL;
+}
+
+void DeferredPixelSpecularHLSL::processPix(  Vector<ShaderComponent*> &componentList, 
+                                             const MaterialFeatureData &fd )
+{
+   if( fd.features[MFT_ForwardShading] || !fd.features[MFT_RTLighting] )
+   {
+      Parent::processPix( componentList, fd );
+      return;
+   }
+
+   MultiLine *meta = new MultiLine;
+
+   Var *specular = new Var;
+   specular->setType( "float" );
+   specular->setName( "specular" );
+   LangElement * specDecl = new DecOp( specular );
+
+   Var *specCol = (Var*)LangElement::find( "specularColor" );
+   if(specCol == NULL)
+   {
+      specCol = new Var;
+      specCol->setType( "float4" );
+      specCol->setName( "specularColor" );
+      specCol->uniform = true;
+      specCol->constSortPos = cspPotentialPrimitive;
+   }
+
+   Var *specPow = new Var;
+   specPow->setType( "float" );
+   specPow->setName( "specularPower" );
+
+   // If the gloss map flag is set, than the specular power is in the alpha
+   // channel of the specular map
+   if( fd.features[ MFT_GlossMap ] )
+      meta->addStatement( new GenOp( "   @ = @.a * 255;\r\n", new DecOp( specPow ), specCol ) );
+   else
+   {
+      specPow->uniform = true;
+      specPow->constSortPos = cspPotentialPrimitive;
+   }
+
+   Var *specStrength = new Var;
+   specStrength->setType( "float" );
+   specStrength->setName( "specularStrength" );
+   specStrength->uniform = true;
+   specStrength->constSortPos = cspPotentialPrimitive;
+
+   Var *lightInfoSamp = (Var *)LangElement::find( "lightInfoSample" );
+   Var *d_specular = (Var*)LangElement::find( "d_specular" );
+   Var *d_NL_Att = (Var*)LangElement::find( "d_NL_Att" );
+
+   AssertFatal( lightInfoSamp && d_specular && d_NL_Att,
+      "DeferredPixelSpecularHLSL::processPix - Something hosed the deferred features!" );
+
+   // (a^m)^n = a^(m*n)
+   meta->addStatement( new GenOp( "   @ = pow( abs(@), max((@ / AL_ConstantSpecularPower),1.0f)) * @;\r\n", 
+      specDecl, d_specular, specPow, specStrength ) );
+
+   LangElement *specMul = new GenOp( "float4( @.rgb, 0 ) * @", specCol, specular );
+   LangElement *final = specMul;
+
+   // We we have a normal map then mask the specular 
+   if( !fd.features[MFT_SpecularMap] && fd.features[MFT_NormalMap] )
+   {
+      Var *bumpSample = (Var*)LangElement::find( "bumpSample" );
+      final = new GenOp( "@ * @.a", final, bumpSample );
+   }
+
+   // add to color
+   meta->addStatement( new GenOp( "   @;\r\n", assignColor( final, Material::Add ) ) );
+
+   output = meta;
+}
+
+ShaderFeature::Resources DeferredPixelSpecularHLSL::getResources( const MaterialFeatureData &fd )
+{
+   if( fd.features[MFT_ForwardShading] || !fd.features[MFT_RTLighting] )
+      return Parent::getResources( fd );
+
+   Resources res; 
+   return res;
+}
+
+
+ShaderFeature::Resources DeferredMinnaertHLSL::getResources( const MaterialFeatureData &fd )
+{
+   Resources res;
+   if( !fd.features[MFT_ForwardShading] && fd.features[MFT_RTLighting] )
+   {
+      res.numTex = 1;
+      res.numTexReg = 1;
+   }
+   return res;
+}
+
+void DeferredMinnaertHLSL::setTexData( Material::StageData &stageDat,
+                                       const MaterialFeatureData &fd, 
+                                       RenderPassData &passData, 
+                                       U32 &texIndex )
+{
+   if( !fd.features[MFT_ForwardShading] && fd.features[MFT_RTLighting] )
+   {
+      NamedTexTarget *texTarget = NamedTexTarget::find(RenderPrePassMgr::BufferName);
+      if ( texTarget )
+      {
+         passData.mTexType[ texIndex ] = Material::TexTarget;
+         passData.mTexSlot[ texIndex++ ].texTarget = texTarget;
+      }
+   }
+}
+
+void DeferredMinnaertHLSL::processPixMacros( Vector<GFXShaderMacro> &macros, 
+                                             const MaterialFeatureData &fd  )
+{
+   if( !fd.features[MFT_ForwardShading] && fd.features[MFT_RTLighting] )
+   {
+      // Pull in the uncondition method for the g buffer
+      NamedTexTarget *texTarget = NamedTexTarget::find( RenderPrePassMgr::BufferName );
+      if ( texTarget && texTarget->getConditioner() )
+      {
+         ConditionerMethodDependency *unconditionMethod = texTarget->getConditioner()->getConditionerMethodDependency(ConditionerFeature::UnconditionMethod);
+         unconditionMethod->createMethodMacro( String::ToLower(RenderPrePassMgr::BufferName) + "Uncondition", macros );
+         addDependency(unconditionMethod);
+      }
+   }
+}
+
+void DeferredMinnaertHLSL::processVert(   Vector<ShaderComponent*> &componentList,
+                                          const MaterialFeatureData &fd )
+{
+   // If there is no deferred information, bail on this feature
+   if( fd.features[MFT_ForwardShading] || !fd.features[MFT_RTLighting] )
+   {
+      output = NULL;
+      return;
+   }
+
+   // Make sure we pass the world space position to the
+   // pixel shader so we can calculate a view vector.
+   MultiLine *meta = new MultiLine;
+   addOutWsPosition( componentList, fd.features[MFT_UseInstancing], meta );
+   output = meta;
+}
+
+void DeferredMinnaertHLSL::processPix( Vector<ShaderComponent*> &componentList, 
+                                       const MaterialFeatureData &fd )
+{
+   // If there is no deferred information, bail on this feature
+   if( fd.features[MFT_ForwardShading] || !fd.features[MFT_RTLighting] )
+   {
+      output = NULL;
+      return;
+   }
+
+   Var *minnaertConstant = new Var;
+   minnaertConstant->setType( "float" );
+   minnaertConstant->setName( "minnaertConstant" );
+   minnaertConstant->uniform = true;
+   minnaertConstant->constSortPos = cspPotentialPrimitive;
+
+   // create texture var
+   Var *prepassBuffer = new Var;
+   prepassBuffer->setType( "sampler2D" );
+   prepassBuffer->setName( "prepassBuffer" );
+   prepassBuffer->uniform = true;
+   prepassBuffer->sampler = true;
+   prepassBuffer->constNum = Var::getTexUnitNum();     // used as texture unit num here
+
+   // Texture coord
+   Var *uvScene = (Var*) LangElement::find( "uvScene" );
+   AssertFatal(uvScene != NULL, "Unable to find UVScene, no RTLighting feature?");
+
+   MultiLine *meta = new MultiLine;
+
+   // Get the world space view vector.
+   Var *wsViewVec = getWsView( getInWsPosition( componentList ), meta );
+
+   String unconditionPrePassMethod = String::ToLower(RenderPrePassMgr::BufferName) + "Uncondition";
+
+   Var *d_NL_Att = (Var*)LangElement::find( "d_NL_Att" );
+
+   meta->addStatement( new GenOp( avar( "   float4 normalDepth = %s(@, @);\r\n", unconditionPrePassMethod.c_str() ), prepassBuffer, uvScene ) );
+   meta->addStatement( new GenOp( "   float vDotN = dot(normalDepth.xyz, @);\r\n", wsViewVec ) );
+   meta->addStatement( new GenOp( "   float Minnaert = pow( @, @) * pow(vDotN, 1.0 - @);\r\n", d_NL_Att, minnaertConstant, minnaertConstant ) );
+   meta->addStatement( new GenOp( "   @;\r\n", assignColor( new GenOp( "float4(Minnaert, Minnaert, Minnaert, 1.0)" ), Material::Mul ) ) );
+
+   output = meta;
+}
+
+
+void DeferredSubSurfaceHLSL::processPix(  Vector<ShaderComponent*> &componentList, 
+                                          const MaterialFeatureData &fd )
+{
+   // If there is no deferred information, bail on this feature
+   if( fd.features[MFT_ForwardShading] || !fd.features[MFT_RTLighting] )
+   {
+      output = NULL;
+      return;
+   }
+
+   Var *subSurfaceParams = new Var;
+   subSurfaceParams->setType( "float4" );
+   subSurfaceParams->setName( "subSurfaceParams" );
+   subSurfaceParams->uniform = true;
+   subSurfaceParams->constSortPos = cspPotentialPrimitive;
+
+   Var *d_lightcolor = (Var*)LangElement::find( "d_lightcolor" );
+   Var *d_NL_Att = (Var*)LangElement::find( "d_NL_Att" );
+
+   MultiLine *meta = new MultiLine;
+   meta->addStatement( new GenOp( "   float subLamb = smoothstep(-@.a, 1.0, @) - smoothstep(0.0, 1.0, @);\r\n", subSurfaceParams, d_NL_Att, d_NL_Att ) );
+   meta->addStatement( new GenOp( "   subLamb = max(0.0, subLamb);\r\n" ) );
+   meta->addStatement( new GenOp( "   @;\r\n", assignColor( new GenOp( "float4(@ + (subLamb * @.rgb), 1.0)", d_lightcolor, subSurfaceParams ), Material::Mul ) ) );
+
+   output = meta;
+}
--- source/materials/materialDefinition.cpp	Tue Jan 20 00:26:36 1970
+++ source/materials/materialDefinition.cpp	Tue Jan 20 00:26:36 1970
@@ -1,696 +1,672 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2012 GarageGames, LLC
-//
-// Permission is hereby granted, free of charge, to any person obtaining a copy
-// of this software and associated documentation files (the "Software"), to
-// deal in the Software without restriction, including without limitation the
-// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
-// sell copies of the Software, and to permit persons to whom the Software is
-// furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-// IN THE SOFTWARE.
-//-----------------------------------------------------------------------------
-
-#include "platform/platform.h"
-#include "materials/materialDefinition.h"
-
-#include "console/consoleTypes.h"
-#include "math/mathTypes.h"
-#include "materials/materialManager.h"
-#include "sceneData.h"
-#include "gfx/sim/cubemapData.h"
-#include "gfx/gfxCubemap.h"
-#include "math/mathIO.h"
-#include "materials/matInstance.h"
-#include "sfx/sfxTrack.h"
-#include "sfx/sfxTypes.h"
-#include "core/util/safeDelete.h"
-
-
-IMPLEMENT_CONOBJECT( Material );
-
-ConsoleDocClass( Material,
-	"@brief A material in Torque 3D is a data structure that describes a surface.\n\n"
-
-	"It contains many different types of information for rendering properties. "
-	"Torque 3D generates shaders from Material definitions. The shaders are compiled "
-	"at runtime and output into the example/shaders directory. Any errors or warnings "
-	"generated from compiling the procedurally generated shaders are output to the console "
-	"as well as the output window in the Visual C IDE.\n\n"
-
-	"@tsexample\n"
-	"singleton Material(DECAL_scorch)\n"
-	"{\n"
-	"	baseTex[0] = \"./scorch_decal.png\";\n"
-	"	vertColor[ 0 ] = true;\n\n"
-	"	translucent = true;\n"
-	"	translucentBlendOp = None;\n"
-	"	translucentZWrite = true;\n"
-	"	alphaTest = true;\n"
-	"	alphaRef = 84;\n"
-	"};\n"
-	"@endtsexample\n\n"
-
-	"@see Rendering\n"
-	"@see ShaderData\n"
-
-	"@ingroup GFX\n");
-
-ImplementBitfieldType( MaterialAnimType,
-   "The type of animation effect to apply to this material.\n"
-   "@ingroup GFX\n\n")
-   { Material::Scroll, "Scroll", "Scroll the material along the X/Y axis.\n" },
-   { Material::Rotate, "Rotate" , "Rotate the material around a point.\n"},
-   { Material::Wave, "Wave" , "Warps the material with an animation using Sin, Triangle or Square mathematics.\n"},
-   { Material::Scale, "Scale", "Scales the material larger and smaller with a pulsing effect.\n" },
-   { Material::Sequence, "Sequence", "Enables the material to have multiple frames of animation in its imagemap.\n" }
-EndImplementBitfieldType;
-
-ImplementEnumType( MaterialBlendOp,
-   "The type of graphical blending operation to apply to this material\n"
-   "@ingroup GFX\n\n")
-   { Material::None,         "None", "Disable blending for this material." },
-   { Material::Mul,          "Mul", "Multiplicative blending." },
-   { Material::Add,          "Add", "Adds the color of the material to the frame buffer with full alpha for each pixel." },
-   { Material::AddAlpha,     "AddAlpha", "The color is modulated by the alpha channel before being added to the frame buffer." },
-   { Material::Sub,          "Sub", "Subtractive Blending. Reverses the color model, causing dark colors to have a stronger visual effect." },
-   { Material::LerpAlpha,    "LerpAlpha", "Linearly interpolates between Material color and frame buffer color based on alpha." }
-EndImplementEnumType;
-
-ImplementEnumType( MaterialWaveType,
-   "When using the Wave material animation, one of these Wave Types will be used to determine the type of wave to display.\n" 
-   "@ingroup GFX\n")
-   { Material::Sin,          "Sin", "Warps the material along a curved Sin Wave." },
-   { Material::Triangle,     "Triangle", "Warps the material along a sharp Triangle Wave." },
-   { Material::Square,       "Square", "Warps the material along a wave which transitions between two oppposite states. As a Square Wave, the transition is quick and sudden." },
-EndImplementEnumType;
-
-
-bool Material::sAllowTextureTargetAssignment = false;
-
-GFXCubemap * Material::GetNormalizeCube()
-{
-   if(smNormalizeCube)
-      return smNormalizeCube;
-   smNormalizeCube = GFX->createCubemap();
-   smNormalizeCube->initNormalize(64);
-   return smNormalizeCube;
-}
-
-GFXCubemapHandle Material::smNormalizeCube;
-
-Material::Material()
-{
-   for( U32 i=0; i<MAX_STAGES; i++ )
-   {
-      mDiffuse[i].set( 1.0f, 1.0f, 1.0f, 1.0f );
-      mSpecular[i].set( 1.0f, 1.0f, 1.0f, 1.0f );
-
-      mSpecularPower[i] = 8.0f;
-      mSpecularStrength[i] = 1.0f;
-      mPixelSpecular[i] = false;
-
-      mAccuScale[i]     = 1.0f;
-      mAccuDirection[i] = 1.0f;
-      mAccuStrength[i]  = 0.6f;
-      mAccuCoverage[i]  = 0.9f;
-      mAccuSpecular[i]  = 16.0f;
-	  
-      mParallaxScale[i] = 0.0f;
-
-      mVertLit[i] = false;
-      mVertColor[ i ] = false;
-
-      mGlow[i] = false;
-      mEmissive[i] = false;
-
-      mDetailScale[i].set( 2.0f, 2.0f );
-      
-      mDetailNormalMapStrength[i] = 1.0f;
-
-      mMinnaertConstant[i] = -1.0f;
-      mSubSurface[i] = false;
-      mSubSurfaceColor[i].set( 1.0f, 0.2f, 0.2f, 1.0f );
-      mSubSurfaceRolloff[i] = 0.2f;
-      
-      mAnimFlags[i] = 0;
-
-      mScrollDir[i].set( 0.0f, 0.0f );
-      mScrollSpeed[i] = 0.0f;
-      mScrollOffset[i].set( 0.0f, 0.0f );
-      
-      mRotSpeed[i] = 0.0f;
-      mRotPivotOffset[i].set( 0.0f, 0.0f );
-      mRotPos[i] = 0.0f;
-
-      mWavePos[i] = 0.0f;
-      mWaveFreq[i] = 0.0f;
-      mWaveAmp[i] = 0.0f;
-      mWaveType[i] = 0;
-
-      mSeqFramePerSec[i] = 0.0f;
-      mSeqSegSize[i] = 0.0f;
-   }
-
-   dMemset(mCellIndex, 0, sizeof(mCellIndex));
-   dMemset(mCellLayout, 0, sizeof(mCellLayout));
-   dMemset(mCellSize, 0, sizeof(mCellSize));
-   dMemset(mNormalMapAtlas, 0, sizeof(mNormalMapAtlas));
-   dMemset(mUseAnisotropic, 0, sizeof(mUseAnisotropic));
-
-   mImposterLimits = Point4F::Zero;
-
-   mDoubleSided = false;
-
-   mTranslucent = false;
-   mTranslucentBlendOp = LerpAlpha;
-   mTranslucentZWrite = false;
-
-   mAlphaTest = false;
-   mAlphaRef = 1;
-
-   mCastShadows = true;
-
-   mPlanarReflection = false;
-
-   mCubemapData = NULL;
-   mDynamicCubemap = NULL;
-
-   mLastUpdateTime = 0;
-
-   mAutoGenerated = false;
-
-   mShowDust = false;
-   mShowFootprints = true;
-
-   dMemset( mEffectColor,     0, sizeof( mEffectColor ) );
-
-   mFootstepSoundId = -1;     mImpactSoundId = -1;
-   mFootstepSoundCustom = 0;  mImpactSoundCustom = 0;
-   mFriction = 0.0;
-   
-   mDirectSoundOcclusion = 1.f;
-   mReverbSoundOcclusion = 1.0;
-}
-
-void Material::initPersistFields()
-{
-   addField("mapTo", TypeRealString, Offset(mMapTo, Material),
-      "Used to map this material to the material name used by TSShape." );
-
-   addArray( "Stages", MAX_STAGES );
-
-      addField("diffuseColor", TypeColorF, Offset(mDiffuse, Material), MAX_STAGES,
-         "This color is multiplied against the diffuse texture color.  If no diffuse texture "
-         "is present this is the material color." );
-
-      addField("diffuseMap", TypeImageFilename, Offset(mDiffuseMapFilename, Material), MAX_STAGES,
-         "The diffuse color texture map." );
-
-      addField("overlayMap", TypeImageFilename, Offset(mOverlayMapFilename, Material), MAX_STAGES,
-         "A secondary diffuse color texture map which will use the second texcoord of a mesh." );
-
-      addField("lightMap", TypeImageFilename, Offset(mLightMapFilename, Material), MAX_STAGES,
-         "The lightmap texture used with pureLight." );
-
-      addField("toneMap", TypeImageFilename, Offset(mToneMapFilename, Material), MAX_STAGES,
-         "The tonemap texture used with pureLight.");
-
-      addField("detailMap", TypeImageFilename, Offset(mDetailMapFilename, Material), MAX_STAGES,
-         "A typically greyscale detail texture additively blended into the material." );
-
-      addField("detailScale", TypePoint2F, Offset(mDetailScale, Material), MAX_STAGES,
-         "The scale factor for the detail map." );
-
-      addField( "normalMap", TypeImageFilename, Offset(mNormalMapFilename, Material), MAX_STAGES,
-         "The normal map texture.  You can use the DXTnm format only when per-pixel "
-         "specular highlights are disabled, or a specular map is in use." );
-
-      addField( "detailNormalMap", TypeImageFilename, Offset(mDetailNormalMapFilename, Material), MAX_STAGES,
-         "A second normal map texture applied at the detail scale.  You can use the DXTnm "
-         "format only when per-pixel specular highlights are disabled." );
-
-      addField( "detailNormalMapStrength", TypeF32, Offset(mDetailNormalMapStrength, Material), MAX_STAGES,
-         "Used to scale the strength of the detail normal map when blended with the base normal map." );
-
-      addField("specular", TypeColorF, Offset(mSpecular, Material), MAX_STAGES,
-         "The color of the specular highlight when not using a specularMap." );
-
-      addField("specularPower", TypeF32, Offset(mSpecularPower, Material), MAX_STAGES,
-         "The hardness of the specular highlight when not using a specularMap." );
-
-		addField("specularStrength", TypeF32, Offset(mSpecularStrength, Material), MAX_STAGES,
-         "The strength of the specular highlight when not using a specularMap." );
-
-      addField("pixelSpecular", TypeBool, Offset(mPixelSpecular, Material), MAX_STAGES, 
-         "This enables per-pixel specular highlights controlled by the alpha channel of the "
-         "normal map texture.  Note that if pixel specular is enabled the DXTnm format will not "
-         "work with your normal map, unless you are also using a specular map." );
-		 
-      addField("accuMap",        TypeImageFilename,   Offset(mAccuMapFilename, Material), MAX_STAGES,
-         "The accu map texture. It should be used much like a diffuse texture - except it is only placed in carefully chosen spots on the model.");
-		 
-      addField("accuScale",      TypeF32, Offset(mAccuScale, Material), MAX_STAGES,
-         "The scale that is applied to the accu map texture. You can use this to fit the texture to smaller or larger objects.");
-		 
-      addField("accuDirection",  TypeF32, Offset(mAccuDirection, Material), MAX_STAGES,
-         "The direction of the accumulation. Chose whether you want the accu map to go from top to bottom (ie. snow) or upwards (ie. mold).");
-		 
-      addField("accuStrength",   TypeF32, Offset(mAccuStrength, Material), MAX_STAGES,
-         "The strength of the accu map. This changes the transparency of the accu map texture. Make it subtle or add more contrast.");
-		 
-      addField("accuCoverage",   TypeF32, Offset(mAccuCoverage, Material), MAX_STAGES,
-         "The coverage ratio of the accu map texture. Use this to make the entire shape pick up some of the accu map texture or none at all.");
-		 
-      addField("accuSpecular",   TypeF32, Offset(mAccuSpecular, Material), MAX_STAGES,
-         "Changes specularity to this value where the accumulated material is present.");
-
-      addField( "specularMap", TypeImageFilename, Offset(mSpecularMapFilename, Material), MAX_STAGES,
-         "The specular map texture. The RGB channels of this texture provide a per-pixel replacement for the 'specular' parameter on the material. "
-         "If this texture contains alpha information, the alpha channel of the texture will be used as the gloss map. "
-         "This provides a per-pixel replacement for the 'specularPower' on the material" );
-
-      addField( "parallaxScale", TypeF32, Offset(mParallaxScale, Material), MAX_STAGES,
-         "Enables parallax mapping and defines the scale factor for the parallax effect.  Typically "
-         "this value is less than 0.4 else the effect breaks down." );
-      
-      addField( "useAnisotropic", TypeBool, Offset(mUseAnisotropic, Material), MAX_STAGES,
-         "Use anisotropic filtering for the textures of this stage." );
-
-      addField("envMap", TypeImageFilename, Offset(mEnvMapFilename, Material), MAX_STAGES,
-         "The name of an environment map cube map to apply to this material." );
-
-      addField("vertLit", TypeBool, Offset(mVertLit, Material), MAX_STAGES,
-         "If true the vertex color is used for lighting." );
-
-      addField( "vertColor", TypeBool, Offset( mVertColor, Material ), MAX_STAGES,
-         "If enabled, vertex colors are premultiplied with diffuse colors." );
-
-      addField("minnaertConstant", TypeF32, Offset(mMinnaertConstant, Material), MAX_STAGES,
-         "The Minnaert shading constant value.  Must be greater than 0 to enable the effect." );
-
-      addField("subSurface", TypeBool, Offset(mSubSurface, Material), MAX_STAGES,
-         "Enables the subsurface scattering approximation." );
-
-      addField("subSurfaceColor", TypeColorF, Offset(mSubSurfaceColor, Material), MAX_STAGES,
-         "The color used for the subsurface scattering approximation." );
-
-      addField("subSurfaceRolloff", TypeF32, Offset(mSubSurfaceRolloff, Material), MAX_STAGES,
-         "The 0 to 1 rolloff factor used in the subsurface scattering approximation." );
-
-      addField("glow", TypeBool, Offset(mGlow, Material), MAX_STAGES,
-         "Enables rendering this material to the glow buffer." );
-
-      addField("emissive", TypeBool, Offset(mEmissive, Material), MAX_STAGES,
-         "Enables emissive lighting for the material." );
-
-      addField("doubleSided", TypeBool, Offset(mDoubleSided, Material),
-         "Disables backface culling casing surfaces to be double sided. "
-         "Note that the lighting on the backside will be a mirror of the front "
-         "side of the surface."  );
-
-      addField("animFlags", TYPEID< AnimType >(), Offset(mAnimFlags, Material), MAX_STAGES,
-         "The types of animation to play on this material." );
-
-      addField("scrollDir", TypePoint2F, Offset(mScrollDir, Material), MAX_STAGES,
-         "The scroll direction in UV space when scroll animation is enabled." );
-
-      addField("scrollSpeed", TypeF32, Offset(mScrollSpeed, Material), MAX_STAGES,
-         "The speed to scroll the texture in UVs per second when scroll animation is enabled." );
-
-      addField("rotSpeed", TypeF32, Offset(mRotSpeed, Material), MAX_STAGES,
-         "The speed to rotate the texture in degrees per second when rotation animation is enabled." );
-
-      addField("rotPivotOffset", TypePoint2F, Offset(mRotPivotOffset, Material), MAX_STAGES,
-         "The piviot position in UV coordinates to center the rotation animation." );
-
-      addField("waveType", TYPEID< WaveType >(), Offset(mWaveType, Material), MAX_STAGES,
-         "The type of wave animation to perform when wave animation is enabled." );
-
-      addField("waveFreq", TypeF32, Offset(mWaveFreq, Material), MAX_STAGES,
-         "The wave frequency when wave animation is enabled." );
-
-      addField("waveAmp", TypeF32, Offset(mWaveAmp, Material), MAX_STAGES,
-         "The wave amplitude when wave animation is enabled." );
-
-      addField("sequenceFramePerSec", TypeF32, Offset(mSeqFramePerSec, Material), MAX_STAGES,
-         "The number of frames per second for frame based sequence animations if greater than zero." );
-
-      addField("sequenceSegmentSize", TypeF32, Offset(mSeqSegSize, Material), MAX_STAGES,
-         "The size of each frame in UV units for sequence animations." );
-
-      // Texture atlasing
-      addField("cellIndex", TypePoint2I, Offset(mCellIndex, Material), MAX_STAGES,
-         "@internal" );
-      addField("cellLayout", TypePoint2I, Offset(mCellLayout, Material), MAX_STAGES,
-         "@internal");
-      addField("cellSize", TypeS32, Offset(mCellSize, Material), MAX_STAGES,
-         "@internal");
-      addField("bumpAtlas", TypeBool, Offset(mNormalMapAtlas, Material), MAX_STAGES,
-         "@internal");
-
-      // For backwards compatibility.  
-      //
-      // They point at the new 'map' fields, but reads always return
-      // an empty string and writes only apply if the value is not empty.
-      //
-      addProtectedField("baseTex",        TypeImageFilename,   Offset(mDiffuseMapFilename, Material), 
-         defaultProtectedSetNotEmptyFn, emptyStringProtectedGetFn, MAX_STAGES, 
-         "For backwards compatibility.\n@see diffuseMap\n" ); 
-      addProtectedField("detailTex",      TypeImageFilename,   Offset(mDetailMapFilename, Material), 
-         defaultProtectedSetNotEmptyFn, emptyStringProtectedGetFn, MAX_STAGES, 
-         "For backwards compatibility.\n@see detailMap\n"); 
-      addProtectedField("overlayTex",     TypeImageFilename,   Offset(mOverlayMapFilename, Material),
-         defaultProtectedSetNotEmptyFn, emptyStringProtectedGetFn, MAX_STAGES, 
-         "For backwards compatibility.\n@see overlayMap\n"); 
-      addProtectedField("bumpTex",        TypeImageFilename,   Offset(mNormalMapFilename, Material),
-         defaultProtectedSetNotEmptyFn, emptyStringProtectedGetFn, MAX_STAGES, 
-         "For backwards compatibility.\n@see normalMap\n"); 
-      addProtectedField("envTex",         TypeImageFilename,   Offset(mEnvMapFilename, Material),
-         defaultProtectedSetNotEmptyFn, emptyStringProtectedGetFn, MAX_STAGES,
-         "For backwards compatibility.\n@see envMap\n"); 
-      addProtectedField("colorMultiply",  TypeColorF,          Offset(mDiffuse, Material),
-         defaultProtectedSetNotEmptyFn, emptyStringProtectedGetFn, MAX_STAGES,
-         "For backwards compatibility.\n@see diffuseColor\n"); 
-
-   endArray( "Stages" );
-
-   addField( "castShadows", TypeBool, Offset(mCastShadows, Material),
-      "If set to false the lighting system will not cast shadows from this material." );
-
-   addField("planarReflection", TypeBool, Offset(mPlanarReflection, Material), "@internal" );
-
-   addField("translucent", TypeBool, Offset(mTranslucent, Material),
-      "If true this material is translucent blended." );
-
-   addField("translucentBlendOp", TYPEID< BlendOp >(), Offset(mTranslucentBlendOp, Material),
-      "The type of blend operation to use when the material is translucent." );
-
-   addField("translucentZWrite", TypeBool, Offset(mTranslucentZWrite, Material),
-      "If enabled and the material is translucent it will write into the depth buffer." );
-
-   addField("alphaTest", TypeBool, Offset(mAlphaTest, Material),
-      "Enables alpha test when rendering the material.\n@see alphaRef\n" );
-
-   addField("alphaRef", TypeS32, Offset(mAlphaRef, Material),
-      "The alpha reference value for alpha testing.  Must be between 0 to 255.\n@see alphaTest\n" );
-
-   addField("cubemap", TypeRealString, Offset(mCubemapName, Material),
-      "The name of a CubemapData for environment mapping." );
-
-   addField("dynamicCubemap", TypeBool, Offset(mDynamicCubemap, Material),
-      "Enables the material to use the dynamic cubemap from the ShapeBase object its applied to." );
-
-   addGroup( "Behavioral" );
-
-      addField( "showFootprints", TypeBool, Offset( mShowFootprints, Material ),
-         "Whether to show player footprint decals on this material.\n\n"
-         "@see PlayerData::decalData" );
-         
-      addField( "showDust", TypeBool, Offset( mShowDust, Material ),
-         "Whether to emit dust particles from a shape moving over the material.  This is, for example, used by "
-         "vehicles or players to decide whether to show dust trails." );
-         
-      addField( "effectColor", TypeColorF, Offset( mEffectColor, Material ), NUM_EFFECT_COLOR_STAGES,
-         "If #showDust is true, this is the set of colors to use for the ParticleData of the dust "
-         "emitter.\n\n"
-         "@see ParticleData::colors" );
-         
-      addField( "footstepSoundId", TypeS32, Offset( mFootstepSoundId, Material ),
-         "What sound to play from the PlayerData sound list when the player walks over the material.  -1 (default) to not play any sound.\n"
-         "\n"
-         "The IDs are:\n\n"
-         "- 0: PlayerData::FootSoftSound\n"
-         "- 1: PlayerData::FootHardSound\n"
-         "- 2: PlayerData::FootMetalSound\n"
-         "- 3: PlayerData::FootSnowSound\n"
-         "- 4: PlayerData::FootShallowSound\n"
-         "- 5: PlayerData::FootWadingSound\n"
-         "- 6: PlayerData::FootUnderwaterSound\n"
-         "- 7: PlayerData::FootBubblesSound\n"
-         "- 8: PlayerData::movingBubblesSound\n"
-         "- 9: PlayerData::waterBreathSound\n"
-         "- 10: PlayerData::impactSoftSound\n"
-         "- 11: PlayerData::impactHardSound\n"
-         "- 12: PlayerData::impactMetalSound\n"
-         "- 13: PlayerData::impactSnowSound\n"
-         "- 14: PlayerData::impactWaterEasy\n"
-         "- 15: PlayerData::impactWaterMedium\n"
-         "- 16: PlayerData::impactWaterHard\n"
-         "- 17: PlayerData::exitingWater\n" );
-         
-      addField( "customFootstepSound", TypeSFXTrackName, Offset( mFootstepSoundCustom, Material ),
-         "The sound to play when the player walks over the material.  If this is set, it overrides #footstepSoundId.  This field is "
-         "useful for directly assigning custom footstep sounds to materials without having to rely on the PlayerData sound assignment.\n\n"
-         "@warn Be aware that materials are client-side objects.  This means that the SFXTracks assigned to materials must be client-side, too." );
-      addField( "impactSoundId", TypeS32, Offset( mImpactSoundId, Material ),
-         "What sound to play from the PlayerData sound list when the player impacts on the surface with a velocity equal or greater "
-         "than PlayerData::groundImpactMinSpeed.\n\n"
-         "For a list of IDs, see #footstepSoundId" );
-      addField( "customImpactSound", TypeSFXTrackName,    Offset( mImpactSoundCustom, Material ),
-         "The sound to play when the player impacts on the surface with a velocity equal or greater than PlayerData::groundImpactMinSpeed.  "
-         "If this is set, it overrides #impactSoundId.  This field is useful for directly assigning custom impact sounds to materials "
-         "without having to rely on the PlayerData sound assignment.\n\n"
-         "@warn Be aware that materials are client-side objects.  This means that the SFXTracks assigned to materials must be client-side, too." );
-      
-      //Deactivate these for the moment as they are not used.
-      
-      #if 0
-      addField( "friction", TypeF32, Offset( mFriction, Material ) );
-      addField( "directSoundOcclusion", TypeF32, Offset( mDirectSoundOcclusion, Material ) );
-      addField( "reverbSoundOcclusion", TypeF32, Offset( mReverbSoundOcclusion, Material ) );
-      #endif
-
-   endGroup( "Behavioral" );
-
-   Parent::initPersistFields();
-}
-
-bool Material::writeField( StringTableEntry fieldname, const char *value )
-{   
-   // Never allow the old field names to be written.
-   if (  fieldname == StringTable->insert("baseTex") ||
-         fieldname == StringTable->insert("detailTex") ||
-         fieldname == StringTable->insert("overlayTex") ||
-         fieldname == StringTable->insert("bumpTex") || 
-         fieldname == StringTable->insert("envTex") ||
-         fieldname == StringTable->insert("colorMultiply") )
-      return false;
-
-   return Parent::writeField( fieldname, value );
-}
-
-bool Material::onAdd()
-{
-   if (Parent::onAdd() == false)
-      return false;
-
-   mCubemapData = dynamic_cast<CubemapData*>(Sim::findObject( mCubemapName ) );
-
-   if( mTranslucentBlendOp >= NumBlendTypes || mTranslucentBlendOp < 0 )
-   {
-      Con::errorf( "Invalid blend op in material: %s", getName() );
-      mTranslucentBlendOp = LerpAlpha;
-   }
-
-   SimSet *matSet = MATMGR->getMaterialSet();
-   if( matSet )
-      matSet->addObject( (SimObject*)this );
-
-   // save the current script path for texture lookup later
-   const String  scriptFile = Con::getVariable("$Con::File");  // current script file - local materials.cs
-
-   String::SizeType  slash = scriptFile.find( '/', scriptFile.length(), String::Right );
-   if ( slash != String::NPos )
-      mPath = scriptFile.substr( 0, slash + 1 );
-
-   _mapMaterial();
-
-   return true;
-}
-
-void Material::onRemove()
-{
-   smNormalizeCube = NULL;
-   Parent::onRemove();
-}
-
-void Material::inspectPostApply()
-{
-   Parent::inspectPostApply();
-
-   // Reload the material instances which 
-   // use this material.
-   if ( isProperlyAdded() )
-      reload();
-}
-
-
-bool Material::isLightmapped() const
-{
-   bool ret = false;
-   for( U32 i=0; i<MAX_STAGES; i++ )
-      ret |= mLightMapFilename[i].isNotEmpty() || mToneMapFilename[i].isNotEmpty() || mVertLit[i];
-   return ret;
-}
-
-void Material::updateTimeBasedParams()
-{
-   U32 lastTime = MATMGR->getLastUpdateTime();
-   F32 dt = MATMGR->getDeltaTime();
-   if (mLastUpdateTime != lastTime)
-   {
-      for (U32 i = 0; i < MAX_STAGES; i++)
-      {
-         mScrollOffset[i] += mScrollDir[i] * mScrollSpeed[i] * dt;
-         mRotPos[i] += mRotSpeed[i] * dt;
-         mWavePos[i] += mWaveFreq[i] * dt;
-      }
-      mLastUpdateTime = lastTime;
-   }
-}
-
-void Material::_mapMaterial()
-{
-   if( String(getName()).isEmpty() )
-   {
-      Con::warnf( "[Material::mapMaterial] - Cannot map unnamed Material" );
-      return;
-   }
-
-   // If mapTo not defined in script, try to use the base texture name instead
-   if( mMapTo.isEmpty() )
-   {
-      if ( mDiffuseMapFilename[0].isEmpty() )
-         return;
-
-      else
-      {
-         // extract filename from base texture
-         if ( mDiffuseMapFilename[0].isNotEmpty() )
-         {
-            U32 slashPos = mDiffuseMapFilename[0].find('/',0,String::Right);
-            if (slashPos == String::NPos)
-               // no '/' character, must be no path, just the filename
-               mMapTo = mDiffuseMapFilename[0];
-            else
-               // use everything after the last slash
-               mMapTo = mDiffuseMapFilename[0].substr(slashPos+1, mDiffuseMapFilename[0].length() - slashPos - 1);
-         }
-      }
-   }
-
-   // add mapping
-   MATMGR->mapMaterial(mMapTo,getName());
-}
-
-BaseMatInstance* Material::createMatInstance()
-{
-   return new MatInstance(*this);
-}
-
-void Material::flush()
-{
-   MATMGR->flushInstance( this );
-}
-
-void Material::reload()
-{
-   MATMGR->reInitInstance( this );
-}
-
-void Material::StageData::getFeatureSet( FeatureSet *outFeatures ) const
-{
-   TextureTable::ConstIterator iter = mTextures.begin();
-   for ( ; iter != mTextures.end(); iter++ )
-   {
-      if ( iter->value.isValid() )
-         outFeatures->addFeature( *iter->key );
-   }
-}
-
-ConsoleMethod( Material, flush, void, 2, 2, 
-   "Flushes all material instances that use this material." )
-{
-   object->flush();
-}
-
-ConsoleMethod( Material, reload, void, 2, 2, 
-   "Reloads all material instances that use this material." )
-{
-   object->reload();
-}
-
-ConsoleMethod( Material, dumpInstances, void, 2, 2, 
-   "Dumps a formatted list of the currently allocated material instances for this material to the console." )
-{
-   MATMGR->dumpMaterialInstances( object );
-}
-
-ConsoleMethod( Material, getAnimFlags, const char*, 3, 3, "" )
-{
-   char * animFlags = Con::getReturnBuffer(512);
-
-   if(object->mAnimFlags[ dAtoi(argv[2]) ] & Material::Scroll)
-   {
-	   if(dStrcmp( animFlags, "" ) == 0)
-	      dStrcpy( animFlags, "$Scroll" );
-   }
-   if(object->mAnimFlags[ dAtoi(argv[2]) ] & Material::Rotate)
-   {
-	   if(dStrcmp( animFlags, "" ) == 0)
-	      dStrcpy( animFlags, "$Rotate" );
-	   else
-			dStrcat( animFlags, " | $Rotate");
-   }
-   if(object->mAnimFlags[ dAtoi(argv[2]) ] & Material::Wave)
-   {
-	   if(dStrcmp( animFlags, "" ) == 0)
-	      dStrcpy( animFlags, "$Wave" );
-	   else
-			dStrcat( animFlags, " | $Wave");
-   }
-   if(object->mAnimFlags[ dAtoi(argv[2]) ] & Material::Scale)
-   {
-	   if(dStrcmp( animFlags, "" ) == 0)
-	      dStrcpy( animFlags, "$Scale" );
-	   else
-			dStrcat( animFlags, " | $Scale");
-   }
-   if(object->mAnimFlags[ dAtoi(argv[2]) ] & Material::Sequence)
-   {
-	   if(dStrcmp( animFlags, "" ) == 0)
-	      dStrcpy( animFlags, "$Sequence" );
-	   else
-			dStrcat( animFlags, " | $Sequence");
-   }
-
-	return animFlags;
-}
-
-ConsoleMethod(Material, getFilename, const char*, 2, 2, "Get filename of material")
-{
-	SimObject *material = static_cast<SimObject *>(object);
-   return material->getFilename();
-}
-
-ConsoleMethod( Material, isAutoGenerated, bool, 2, 2, 
-              "Returns true if this Material was automatically generated by MaterialList::mapMaterials()" )
-{
-   return object->isAutoGenerated();
-}
-
-ConsoleMethod( Material, setAutoGenerated, void, 3, 3, 
-              "setAutoGenerated(bool isAutoGenerated): Set whether or not the Material is autogenerated." )
-{
-   object->setAutoGenerated(dAtob(argv[2]));
+//-----------------------------------------------------------------------------
+// Copyright (c) 2012 GarageGames, LLC
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to
+// deal in the Software without restriction, including without limitation the
+// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+// sell copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+// IN THE SOFTWARE.
+//-----------------------------------------------------------------------------
+
+#include "platform/platform.h"
+#include "materials/materialDefinition.h"
+
+#include "console/consoleTypes.h"
+#include "math/mathTypes.h"
+#include "materials/materialManager.h"
+#include "sceneData.h"
+#include "gfx/sim/cubemapData.h"
+#include "gfx/gfxCubemap.h"
+#include "math/mathIO.h"
+#include "materials/matInstance.h"
+#include "sfx/sfxTrack.h"
+#include "sfx/sfxTypes.h"
+#include "core/util/safeDelete.h"
+
+
+IMPLEMENT_CONOBJECT( Material );
+
+ConsoleDocClass( Material,
+	"@brief A material in Torque 3D is a data structure that describes a surface.\n\n"
+
+	"It contains many different types of information for rendering properties. "
+	"Torque 3D generates shaders from Material definitions. The shaders are compiled "
+	"at runtime and output into the example/shaders directory. Any errors or warnings "
+	"generated from compiling the procedurally generated shaders are output to the console "
+	"as well as the output window in the Visual C IDE.\n\n"
+
+	"@tsexample\n"
+	"singleton Material(DECAL_scorch)\n"
+	"{\n"
+	"	baseTex[0] = \"./scorch_decal.png\";\n"
+	"	vertColor[ 0 ] = true;\n\n"
+	"	translucent = true;\n"
+	"	translucentBlendOp = None;\n"
+	"	translucentZWrite = true;\n"
+	"	alphaTest = true;\n"
+	"	alphaRef = 84;\n"
+	"};\n"
+	"@endtsexample\n\n"
+
+	"@see Rendering\n"
+	"@see ShaderData\n"
+
+	"@ingroup GFX\n");
+
+ImplementBitfieldType( MaterialAnimType,
+   "The type of animation effect to apply to this material.\n"
+   "@ingroup GFX\n\n")
+   { Material::Scroll, "Scroll", "Scroll the material along the X/Y axis.\n" },
+   { Material::Rotate, "Rotate" , "Rotate the material around a point.\n"},
+   { Material::Wave, "Wave" , "Warps the material with an animation using Sin, Triangle or Square mathematics.\n"},
+   { Material::Scale, "Scale", "Scales the material larger and smaller with a pulsing effect.\n" },
+   { Material::Sequence, "Sequence", "Enables the material to have multiple frames of animation in its imagemap.\n" }
+EndImplementBitfieldType;
+
+ImplementEnumType( MaterialBlendOp,
+   "The type of graphical blending operation to apply to this material\n"
+   "@ingroup GFX\n\n")
+   { Material::None,         "None", "Disable blending for this material." },
+   { Material::Mul,          "Mul", "Multiplicative blending." },
+   { Material::Add,          "Add", "Adds the color of the material to the frame buffer with full alpha for each pixel." },
+   { Material::AddAlpha,     "AddAlpha", "The color is modulated by the alpha channel before being added to the frame buffer." },
+   { Material::Sub,          "Sub", "Subtractive Blending. Reverses the color model, causing dark colors to have a stronger visual effect." },
+   { Material::LerpAlpha,    "LerpAlpha", "Linearly interpolates between Material color and frame buffer color based on alpha." }
+EndImplementEnumType;
+
+ImplementEnumType( MaterialWaveType,
+   "When using the Wave material animation, one of these Wave Types will be used to determine the type of wave to display.\n" 
+   "@ingroup GFX\n")
+   { Material::Sin,          "Sin", "Warps the material along a curved Sin Wave." },
+   { Material::Triangle,     "Triangle", "Warps the material along a sharp Triangle Wave." },
+   { Material::Square,       "Square", "Warps the material along a wave which transitions between two oppposite states. As a Square Wave, the transition is quick and sudden." },
+EndImplementEnumType;
+
+
+bool Material::sAllowTextureTargetAssignment = false;
+
+GFXCubemap * Material::GetNormalizeCube()
+{
+   if(smNormalizeCube)
+      return smNormalizeCube;
+   smNormalizeCube = GFX->createCubemap();
+   smNormalizeCube->initNormalize(64);
+   return smNormalizeCube;
+}
+
+GFXCubemapHandle Material::smNormalizeCube;
+
+Material::Material()
+{
+   for( U32 i=0; i<MAX_STAGES; i++ )
+   {
+      mDiffuse[i].set( 1.0f, 1.0f, 1.0f, 1.0f );
+      mSpecular[i].set( 1.0f, 1.0f, 1.0f, 1.0f );
+
+      mSpecularPower[i] = 8.0f;
+      mSpecularStrength[i] = 1.0f;
+      mPixelSpecular[i] = false;
+
+      mParallaxScale[i] = 0.0f;
+
+      mVertLit[i] = false;
+      mVertColor[ i ] = false;
+
+      mGlow[i] = false;
+      mEmissive[i] = false;
+
+      mDetailScale[i].set( 2.0f, 2.0f );
+      
+      mDetailNormalMapStrength[i] = 1.0f;
+
+      mMinnaertConstant[i] = -1.0f;
+      mSubSurface[i] = false;
+      mSubSurfaceColor[i].set( 1.0f, 0.2f, 0.2f, 1.0f );
+      mSubSurfaceRolloff[i] = 0.2f;
+      
+      mAnimFlags[i] = 0;
+
+      mScrollDir[i].set( 0.0f, 0.0f );
+      mScrollSpeed[i] = 0.0f;
+      mScrollOffset[i].set( 0.0f, 0.0f );
+      
+      mRotSpeed[i] = 0.0f;
+      mRotPivotOffset[i].set( 0.0f, 0.0f );
+      mRotPos[i] = 0.0f;
+
+      mWavePos[i] = 0.0f;
+      mWaveFreq[i] = 0.0f;
+      mWaveAmp[i] = 0.0f;
+      mWaveType[i] = 0;
+
+      mSeqFramePerSec[i] = 0.0f;
+      mSeqSegSize[i] = 0.0f;
+   }
+
+   dMemset(mCellIndex, 0, sizeof(mCellIndex));
+   dMemset(mCellLayout, 0, sizeof(mCellLayout));
+   dMemset(mCellSize, 0, sizeof(mCellSize));
+   dMemset(mNormalMapAtlas, 0, sizeof(mNormalMapAtlas));
+   dMemset(mUseAnisotropic, 0, sizeof(mUseAnisotropic));
+
+   mImposterLimits = Point4F::Zero;
+
+   mDoubleSided = false;
+
+   mTranslucent = false;
+   mTranslucentBlendOp = LerpAlpha;
+   mTranslucentZWrite = false;
+
+   mAlphaTest = false;
+   mAlphaRef = 1;
+
+   mCastShadows = true;
+
+   mPlanarReflection = false;
+
+   mCubemapData = NULL;
+   mDynamicCubemap = NULL;
+
+   mLastUpdateTime = 0;
+
+   mAutoGenerated = false;
+
+   mShowDust = false;
+   mShowFootprints = true;
+
+   dMemset( mEffectColor,     0, sizeof( mEffectColor ) );
+
+   mFootstepSoundId = -1;     mImpactSoundId = -1;
+   mFootstepSoundCustom = 0;  mImpactSoundCustom = 0;
+   mFriction = 0.0;
+   
+   mDirectSoundOcclusion = 1.f;
+   mReverbSoundOcclusion = 1.0;
+}
+
+void Material::initPersistFields()
+{
+   addField("mapTo", TypeRealString, Offset(mMapTo, Material),
+      "Used to map this material to the material name used by TSShape." );
+
+   addArray( "Stages", MAX_STAGES );
+
+      addField("diffuseColor", TypeColorF, Offset(mDiffuse, Material), MAX_STAGES,
+         "This color is multiplied against the diffuse texture color.  If no diffuse texture "
+         "is present this is the material color." );
+
+      addField("diffuseMap", TypeImageFilename, Offset(mDiffuseMapFilename, Material), MAX_STAGES,
+         "The diffuse color texture map." );
+
+      addField("overlayMap", TypeImageFilename, Offset(mOverlayMapFilename, Material), MAX_STAGES,
+         "A secondary diffuse color texture map which will use the second texcoord of a mesh." );
+
+      addField("lightMap", TypeImageFilename, Offset(mLightMapFilename, Material), MAX_STAGES,
+         "The lightmap texture used with pureLight." );
+
+      addField("toneMap", TypeImageFilename, Offset(mToneMapFilename, Material), MAX_STAGES,
+         "The tonemap texture used with pureLight.");
+
+      addField("detailMap", TypeImageFilename, Offset(mDetailMapFilename, Material), MAX_STAGES,
+         "A typically greyscale detail texture additively blended into the material." );
+
+      addField("detailScale", TypePoint2F, Offset(mDetailScale, Material), MAX_STAGES,
+         "The scale factor for the detail map." );
+
+      addField( "normalMap", TypeImageFilename, Offset(mNormalMapFilename, Material), MAX_STAGES,
+         "The normal map texture.  You can use the DXTnm format only when per-pixel "
+         "specular highlights are disabled, or a specular map is in use." );
+
+      addField( "detailNormalMap", TypeImageFilename, Offset(mDetailNormalMapFilename, Material), MAX_STAGES,
+         "A second normal map texture applied at the detail scale.  You can use the DXTnm "
+         "format only when per-pixel specular highlights are disabled." );
+
+      addField( "detailNormalMapStrength", TypeF32, Offset(mDetailNormalMapStrength, Material), MAX_STAGES,
+         "Used to scale the strength of the detail normal map when blended with the base normal map." );
+
+      addField("specular", TypeColorF, Offset(mSpecular, Material), MAX_STAGES,
+         "The color of the specular highlight when not using a specularMap." );
+
+      addField("specularPower", TypeF32, Offset(mSpecularPower, Material), MAX_STAGES,
+         "The hardness of the specular highlight when not using a specularMap." );
+
+		addField("specularStrength", TypeF32, Offset(mSpecularStrength, Material), MAX_STAGES,
+         "The strength of the specular highlight when not using a specularMap." );
+
+      addField("pixelSpecular", TypeBool, Offset(mPixelSpecular, Material), MAX_STAGES, 
+         "This enables per-pixel specular highlights controlled by the alpha channel of the "
+         "normal map texture.  Note that if pixel specular is enabled the DXTnm format will not "
+         "work with your normal map, unless you are also using a specular map." );
+
+      addField( "specularMap", TypeImageFilename, Offset(mSpecularMapFilename, Material), MAX_STAGES,
+         "The specular map texture. The RGB channels of this texture provide a per-pixel replacement for the 'specular' parameter on the material. "
+         "If this texture contains alpha information, the alpha channel of the texture will be used as the gloss map. "
+         "This provides a per-pixel replacement for the 'specularPower' on the material" );
+
+      addField( "parallaxScale", TypeF32, Offset(mParallaxScale, Material), MAX_STAGES,
+         "Enables parallax mapping and defines the scale factor for the parallax effect.  Typically "
+         "this value is less than 0.4 else the effect breaks down." );
+      
+      addField( "useAnisotropic", TypeBool, Offset(mUseAnisotropic, Material), MAX_STAGES,
+         "Use anisotropic filtering for the textures of this stage." );
+
+      addField("envMap", TypeImageFilename, Offset(mEnvMapFilename, Material), MAX_STAGES,
+         "The name of an environment map cube map to apply to this material." );
+
+      addField("vertLit", TypeBool, Offset(mVertLit, Material), MAX_STAGES,
+         "If true the vertex color is used for lighting." );
+
+      addField( "vertColor", TypeBool, Offset( mVertColor, Material ), MAX_STAGES,
+         "If enabled, vertex colors are premultiplied with diffuse colors." );
+
+      addField("minnaertConstant", TypeF32, Offset(mMinnaertConstant, Material), MAX_STAGES,
+         "The Minnaert shading constant value.  Must be greater than 0 to enable the effect." );
+
+      addField("subSurface", TypeBool, Offset(mSubSurface, Material), MAX_STAGES,
+         "Enables the subsurface scattering approximation." );
+
+      addField("subSurfaceColor", TypeColorF, Offset(mSubSurfaceColor, Material), MAX_STAGES,
+         "The color used for the subsurface scattering approximation." );
+
+      addField("subSurfaceRolloff", TypeF32, Offset(mSubSurfaceRolloff, Material), MAX_STAGES,
+         "The 0 to 1 rolloff factor used in the subsurface scattering approximation." );
+
+      addField("glow", TypeBool, Offset(mGlow, Material), MAX_STAGES,
+         "Enables rendering this material to the glow buffer." );
+
+      addField("emissive", TypeBool, Offset(mEmissive, Material), MAX_STAGES,
+         "Enables emissive lighting for the material." );
+
+      addField("doubleSided", TypeBool, Offset(mDoubleSided, Material),
+         "Disables backface culling casing surfaces to be double sided. "
+         "Note that the lighting on the backside will be a mirror of the front "
+         "side of the surface."  );
+
+      addField("animFlags", TYPEID< AnimType >(), Offset(mAnimFlags, Material), MAX_STAGES,
+         "The types of animation to play on this material." );
+
+      addField("scrollDir", TypePoint2F, Offset(mScrollDir, Material), MAX_STAGES,
+         "The scroll direction in UV space when scroll animation is enabled." );
+
+      addField("scrollSpeed", TypeF32, Offset(mScrollSpeed, Material), MAX_STAGES,
+         "The speed to scroll the texture in UVs per second when scroll animation is enabled." );
+
+      addField("rotSpeed", TypeF32, Offset(mRotSpeed, Material), MAX_STAGES,
+         "The speed to rotate the texture in degrees per second when rotation animation is enabled." );
+
+      addField("rotPivotOffset", TypePoint2F, Offset(mRotPivotOffset, Material), MAX_STAGES,
+         "The piviot position in UV coordinates to center the rotation animation." );
+
+      addField("waveType", TYPEID< WaveType >(), Offset(mWaveType, Material), MAX_STAGES,
+         "The type of wave animation to perform when wave animation is enabled." );
+
+      addField("waveFreq", TypeF32, Offset(mWaveFreq, Material), MAX_STAGES,
+         "The wave frequency when wave animation is enabled." );
+
+      addField("waveAmp", TypeF32, Offset(mWaveAmp, Material), MAX_STAGES,
+         "The wave amplitude when wave animation is enabled." );
+
+      addField("sequenceFramePerSec", TypeF32, Offset(mSeqFramePerSec, Material), MAX_STAGES,
+         "The number of frames per second for frame based sequence animations if greater than zero." );
+
+      addField("sequenceSegmentSize", TypeF32, Offset(mSeqSegSize, Material), MAX_STAGES,
+         "The size of each frame in UV units for sequence animations." );
+
+      // Texture atlasing
+      addField("cellIndex", TypePoint2I, Offset(mCellIndex, Material), MAX_STAGES,
+         "@internal" );
+      addField("cellLayout", TypePoint2I, Offset(mCellLayout, Material), MAX_STAGES,
+         "@internal");
+      addField("cellSize", TypeS32, Offset(mCellSize, Material), MAX_STAGES,
+         "@internal");
+      addField("bumpAtlas", TypeBool, Offset(mNormalMapAtlas, Material), MAX_STAGES,
+         "@internal");
+
+      // For backwards compatibility.  
+      //
+      // They point at the new 'map' fields, but reads always return
+      // an empty string and writes only apply if the value is not empty.
+      //
+      addProtectedField("baseTex",        TypeImageFilename,   Offset(mDiffuseMapFilename, Material), 
+         defaultProtectedSetNotEmptyFn, emptyStringProtectedGetFn, MAX_STAGES, 
+         "For backwards compatibility.\n@see diffuseMap\n" ); 
+      addProtectedField("detailTex",      TypeImageFilename,   Offset(mDetailMapFilename, Material), 
+         defaultProtectedSetNotEmptyFn, emptyStringProtectedGetFn, MAX_STAGES, 
+         "For backwards compatibility.\n@see detailMap\n"); 
+      addProtectedField("overlayTex",     TypeImageFilename,   Offset(mOverlayMapFilename, Material),
+         defaultProtectedSetNotEmptyFn, emptyStringProtectedGetFn, MAX_STAGES, 
+         "For backwards compatibility.\n@see overlayMap\n"); 
+      addProtectedField("bumpTex",        TypeImageFilename,   Offset(mNormalMapFilename, Material),
+         defaultProtectedSetNotEmptyFn, emptyStringProtectedGetFn, MAX_STAGES, 
+         "For backwards compatibility.\n@see normalMap\n"); 
+      addProtectedField("envTex",         TypeImageFilename,   Offset(mEnvMapFilename, Material),
+         defaultProtectedSetNotEmptyFn, emptyStringProtectedGetFn, MAX_STAGES,
+         "For backwards compatibility.\n@see envMap\n"); 
+      addProtectedField("colorMultiply",  TypeColorF,          Offset(mDiffuse, Material),
+         defaultProtectedSetNotEmptyFn, emptyStringProtectedGetFn, MAX_STAGES,
+         "For backwards compatibility.\n@see diffuseColor\n"); 
+
+   endArray( "Stages" );
+
+   addField( "castShadows", TypeBool, Offset(mCastShadows, Material),
+      "If set to false the lighting system will not cast shadows from this material." );
+
+   addField("planarReflection", TypeBool, Offset(mPlanarReflection, Material), "@internal" );
+
+   addField("translucent", TypeBool, Offset(mTranslucent, Material),
+      "If true this material is translucent blended." );
+
+   addField("translucentBlendOp", TYPEID< BlendOp >(), Offset(mTranslucentBlendOp, Material),
+      "The type of blend operation to use when the material is translucent." );
+
+   addField("translucentZWrite", TypeBool, Offset(mTranslucentZWrite, Material),
+      "If enabled and the material is translucent it will write into the depth buffer." );
+
+   addField("alphaTest", TypeBool, Offset(mAlphaTest, Material),
+      "Enables alpha test when rendering the material.\n@see alphaRef\n" );
+
+   addField("alphaRef", TypeS32, Offset(mAlphaRef, Material),
+      "The alpha reference value for alpha testing.  Must be between 0 to 255.\n@see alphaTest\n" );
+
+   addField("cubemap", TypeRealString, Offset(mCubemapName, Material),
+      "The name of a CubemapData for environment mapping." );
+
+   addField("dynamicCubemap", TypeBool, Offset(mDynamicCubemap, Material),
+      "Enables the material to use the dynamic cubemap from the ShapeBase object its applied to." );
+
+   addGroup( "Behavioral" );
+
+      addField( "showFootprints", TypeBool, Offset( mShowFootprints, Material ),
+         "Whether to show player footprint decals on this material.\n\n"
+         "@see PlayerData::decalData" );
+         
+      addField( "showDust", TypeBool, Offset( mShowDust, Material ),
+         "Whether to emit dust particles from a shape moving over the material.  This is, for example, used by "
+         "vehicles or players to decide whether to show dust trails." );
+         
+      addField( "effectColor", TypeColorF, Offset( mEffectColor, Material ), NUM_EFFECT_COLOR_STAGES,
+         "If #showDust is true, this is the set of colors to use for the ParticleData of the dust "
+         "emitter.\n\n"
+         "@see ParticleData::colors" );
+         
+      addField( "footstepSoundId", TypeS32, Offset( mFootstepSoundId, Material ),
+         "What sound to play from the PlayerData sound list when the player walks over the material.  -1 (default) to not play any sound.\n"
+         "\n"
+         "The IDs are:\n\n"
+         "- 0: PlayerData::FootSoftSound\n"
+         "- 1: PlayerData::FootHardSound\n"
+         "- 2: PlayerData::FootMetalSound\n"
+         "- 3: PlayerData::FootSnowSound\n"
+         "- 4: PlayerData::FootShallowSound\n"
+         "- 5: PlayerData::FootWadingSound\n"
+         "- 6: PlayerData::FootUnderwaterSound\n"
+         "- 7: PlayerData::FootBubblesSound\n"
+         "- 8: PlayerData::movingBubblesSound\n"
+         "- 9: PlayerData::waterBreathSound\n"
+         "- 10: PlayerData::impactSoftSound\n"
+         "- 11: PlayerData::impactHardSound\n"
+         "- 12: PlayerData::impactMetalSound\n"
+         "- 13: PlayerData::impactSnowSound\n"
+         "- 14: PlayerData::impactWaterEasy\n"
+         "- 15: PlayerData::impactWaterMedium\n"
+         "- 16: PlayerData::impactWaterHard\n"
+         "- 17: PlayerData::exitingWater\n" );
+         
+      addField( "customFootstepSound", TypeSFXTrackName, Offset( mFootstepSoundCustom, Material ),
+         "The sound to play when the player walks over the material.  If this is set, it overrides #footstepSoundId.  This field is "
+         "useful for directly assigning custom footstep sounds to materials without having to rely on the PlayerData sound assignment.\n\n"
+         "@warn Be aware that materials are client-side objects.  This means that the SFXTracks assigned to materials must be client-side, too." );
+      addField( "impactSoundId", TypeS32, Offset( mImpactSoundId, Material ),
+         "What sound to play from the PlayerData sound list when the player impacts on the surface with a velocity equal or greater "
+         "than PlayerData::groundImpactMinSpeed.\n\n"
+         "For a list of IDs, see #footstepSoundId" );
+      addField( "customImpactSound", TypeSFXTrackName,    Offset( mImpactSoundCustom, Material ),
+         "The sound to play when the player impacts on the surface with a velocity equal or greater than PlayerData::groundImpactMinSpeed.  "
+         "If this is set, it overrides #impactSoundId.  This field is useful for directly assigning custom impact sounds to materials "
+         "without having to rely on the PlayerData sound assignment.\n\n"
+         "@warn Be aware that materials are client-side objects.  This means that the SFXTracks assigned to materials must be client-side, too." );
+      
+      //Deactivate these for the moment as they are not used.
+      
+      #if 0
+      addField( "friction", TypeF32, Offset( mFriction, Material ) );
+      addField( "directSoundOcclusion", TypeF32, Offset( mDirectSoundOcclusion, Material ) );
+      addField( "reverbSoundOcclusion", TypeF32, Offset( mReverbSoundOcclusion, Material ) );
+      #endif
+
+   endGroup( "Behavioral" );
+
+   Parent::initPersistFields();
+}
+
+bool Material::writeField( StringTableEntry fieldname, const char *value )
+{   
+   // Never allow the old field names to be written.
+   if (  fieldname == StringTable->insert("baseTex") ||
+         fieldname == StringTable->insert("detailTex") ||
+         fieldname == StringTable->insert("overlayTex") ||
+         fieldname == StringTable->insert("bumpTex") || 
+         fieldname == StringTable->insert("envTex") ||
+         fieldname == StringTable->insert("colorMultiply") )
+      return false;
+
+   return Parent::writeField( fieldname, value );
+}
+
+bool Material::onAdd()
+{
+   if (Parent::onAdd() == false)
+      return false;
+
+   mCubemapData = dynamic_cast<CubemapData*>(Sim::findObject( mCubemapName ) );
+
+   if( mTranslucentBlendOp >= NumBlendTypes || mTranslucentBlendOp < 0 )
+   {
+      Con::errorf( "Invalid blend op in material: %s", getName() );
+      mTranslucentBlendOp = LerpAlpha;
+   }
+
+   SimSet *matSet = MATMGR->getMaterialSet();
+   if( matSet )
+      matSet->addObject( (SimObject*)this );
+
+   // save the current script path for texture lookup later
+   const String  scriptFile = Con::getVariable("$Con::File");  // current script file - local materials.cs
+
+   String::SizeType  slash = scriptFile.find( '/', scriptFile.length(), String::Right );
+   if ( slash != String::NPos )
+      mPath = scriptFile.substr( 0, slash + 1 );
+
+   _mapMaterial();
+
+   return true;
+}
+
+void Material::onRemove()
+{
+   smNormalizeCube = NULL;
+   Parent::onRemove();
+}
+
+void Material::inspectPostApply()
+{
+   Parent::inspectPostApply();
+
+   // Reload the material instances which 
+   // use this material.
+   if ( isProperlyAdded() )
+      reload();
+}
+
+
+bool Material::isLightmapped() const
+{
+   bool ret = false;
+   for( U32 i=0; i<MAX_STAGES; i++ )
+      ret |= mLightMapFilename[i].isNotEmpty() || mToneMapFilename[i].isNotEmpty() || mVertLit[i];
+   return ret;
+}
+
+void Material::updateTimeBasedParams()
+{
+   U32 lastTime = MATMGR->getLastUpdateTime();
+   F32 dt = MATMGR->getDeltaTime();
+   if (mLastUpdateTime != lastTime)
+   {
+      for (U32 i = 0; i < MAX_STAGES; i++)
+      {
+         mScrollOffset[i] += mScrollDir[i] * mScrollSpeed[i] * dt;
+         mRotPos[i] += mRotSpeed[i] * dt;
+         mWavePos[i] += mWaveFreq[i] * dt;
+      }
+      mLastUpdateTime = lastTime;
+   }
+}
+
+void Material::_mapMaterial()
+{
+   if( String(getName()).isEmpty() )
+   {
+      Con::warnf( "[Material::mapMaterial] - Cannot map unnamed Material" );
+      return;
+   }
+
+   // If mapTo not defined in script, try to use the base texture name instead
+   if( mMapTo.isEmpty() )
+   {
+      if ( mDiffuseMapFilename[0].isEmpty() )
+         return;
+
+      else
+      {
+         // extract filename from base texture
+         if ( mDiffuseMapFilename[0].isNotEmpty() )
+         {
+            U32 slashPos = mDiffuseMapFilename[0].find('/',0,String::Right);
+            if (slashPos == String::NPos)
+               // no '/' character, must be no path, just the filename
+               mMapTo = mDiffuseMapFilename[0];
+            else
+               // use everything after the last slash
+               mMapTo = mDiffuseMapFilename[0].substr(slashPos+1, mDiffuseMapFilename[0].length() - slashPos - 1);
+         }
+      }
+   }
+
+   // add mapping
+   MATMGR->mapMaterial(mMapTo,getName());
+}
+
+BaseMatInstance* Material::createMatInstance()
+{
+   return new MatInstance(*this);
+}
+
+void Material::flush()
+{
+   MATMGR->flushInstance( this );
+}
+
+void Material::reload()
+{
+   MATMGR->reInitInstance( this );
+}
+
+void Material::StageData::getFeatureSet( FeatureSet *outFeatures ) const
+{
+   TextureTable::ConstIterator iter = mTextures.begin();
+   for ( ; iter != mTextures.end(); iter++ )
+   {
+      if ( iter->value.isValid() )
+         outFeatures->addFeature( *iter->key );
+   }
+}
+
+ConsoleMethod( Material, flush, void, 2, 2, 
+   "Flushes all material instances that use this material." )
+{
+   object->flush();
+}
+
+ConsoleMethod( Material, reload, void, 2, 2, 
+   "Reloads all material instances that use this material." )
+{
+   object->reload();
+}
+
+ConsoleMethod( Material, dumpInstances, void, 2, 2, 
+   "Dumps a formatted list of the currently allocated material instances for this material to the console." )
+{
+   MATMGR->dumpMaterialInstances( object );
+}
+
+ConsoleMethod( Material, getAnimFlags, const char*, 3, 3, "" )
+{
+   char * animFlags = Con::getReturnBuffer(512);
+
+   if(object->mAnimFlags[ dAtoi(argv[2]) ] & Material::Scroll)
+   {
+	   if(dStrcmp( animFlags, "" ) == 0)
+	      dStrcpy( animFlags, "$Scroll" );
+   }
+   if(object->mAnimFlags[ dAtoi(argv[2]) ] & Material::Rotate)
+   {
+	   if(dStrcmp( animFlags, "" ) == 0)
+	      dStrcpy( animFlags, "$Rotate" );
+	   else
+			dStrcat( animFlags, " | $Rotate");
+   }
+   if(object->mAnimFlags[ dAtoi(argv[2]) ] & Material::Wave)
+   {
+	   if(dStrcmp( animFlags, "" ) == 0)
+	      dStrcpy( animFlags, "$Wave" );
+	   else
+			dStrcat( animFlags, " | $Wave");
+   }
+   if(object->mAnimFlags[ dAtoi(argv[2]) ] & Material::Scale)
+   {
+	   if(dStrcmp( animFlags, "" ) == 0)
+	      dStrcpy( animFlags, "$Scale" );
+	   else
+			dStrcat( animFlags, " | $Scale");
+   }
+   if(object->mAnimFlags[ dAtoi(argv[2]) ] & Material::Sequence)
+   {
+	   if(dStrcmp( animFlags, "" ) == 0)
+	      dStrcpy( animFlags, "$Sequence" );
+	   else
+			dStrcat( animFlags, " | $Sequence");
+   }
+
+	return animFlags;
+}
+
+ConsoleMethod(Material, getFilename, const char*, 2, 2, "Get filename of material")
+{
+	SimObject *material = static_cast<SimObject *>(object);
+   return material->getFilename();
+}
+
+ConsoleMethod( Material, isAutoGenerated, bool, 2, 2, 
+              "Returns true if this Material was automatically generated by MaterialList::mapMaterials()" )
+{
+   return object->isAutoGenerated();
+}
+
+ConsoleMethod( Material, setAutoGenerated, void, 3, 3, 
+              "setAutoGenerated(bool isAutoGenerated): Set whether or not the Material is autogenerated." )
+{
+   object->setAutoGenerated(dAtob(argv[2]));
 }
\ No newline at end of file
--- source/materials/materialDefinition.h	Tue Jan 20 00:26:36 1970
+++ source/materials/materialDefinition.h	Tue Jan 20 00:26:36 1970
@@ -1,409 +1,402 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2012 GarageGames, LLC
-//
-// Permission is hereby granted, free of charge, to any person obtaining a copy
-// of this software and associated documentation files (the "Software"), to
-// deal in the Software without restriction, including without limitation the
-// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
-// sell copies of the Software, and to permit persons to whom the Software is
-// furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-// IN THE SOFTWARE.
-//-----------------------------------------------------------------------------
-
-#ifndef _MATERIALDEFINITION_H_
-#define _MATERIALDEFINITION_H_
-
-#ifndef _BASEMATERIALDEFINITION_H_
-   #include "materials/baseMaterialDefinition.h"
-#endif
-#ifndef _TDICTIONARY_H_
-   #include "core/util/tDictionary.h"
-#endif
-#ifndef _GFXTEXTUREHANDLE_H_
-   #include "gfx/gfxTextureHandle.h"
-#endif
-#ifndef _GFXSTRUCTS_H_
-   #include "gfx/gfxStructs.h"
-#endif
-#ifndef _GFXCUBEMAP_H_
-   #include "gfx/gfxCubemap.h"
-#endif
-#ifndef _DYNAMIC_CONSOLETYPES_H_
-   #include "console/dynamicTypes.h"
-#endif
-
-
-class CubemapData;
-class SFXTrack;
-struct SceneData;
-class FeatureSet;
-class FeatureType;
-class MaterialSoundProfile;
-class MaterialPhysicsProfile;
-
-
-/// The basic material definition.
-class Material : public BaseMaterialDefinition
-{
-   typedef BaseMaterialDefinition Parent;
-public:
-   static GFXCubemap *GetNormalizeCube();
-
-   //-----------------------------------------------------------------------
-   // Enums
-   //-----------------------------------------------------------------------
-   enum Constants
-   {
-      MAX_TEX_PER_PASS = 8,         ///< Number of textures per pass
-      MAX_STAGES = 4,
-      NUM_EFFECT_COLOR_STAGES = 2,  ///< Number of effect color definitions for transitioning effects.
-   };
-
-   enum TexType
-   {
-      NoTexture = 0,
-      Standard = 1,
-      Detail,
-      Bump,
-      DetailBump,
-      Env,
-      Cube,
-      SGCube,  // scene graph cube - probably dynamic
-      Lightmap,
-      ToneMapTex,
-      Mask,
-      BackBuff,
-      ReflectBuff,
-      Misc,
-      DynamicLight,
-      DynamicLightMask,
-      NormalizeCube,
-      TexTarget,
-   };
-
-   enum BlendOp
-   {
-      None = 0,
-      Mul,
-      Add,
-      AddAlpha,      // add modulated with alpha channel
-      Sub,
-      LerpAlpha,     // linear interpolation modulated with alpha channel
-      ToneMap,
-      NumBlendTypes
-   };
-
-   enum AnimType
-   {
-      Scroll = 1,
-      Rotate = 2,
-      Wave   = 4,
-      Scale  = 8,
-      Sequence = 16,
-   };
-
-   enum WaveType
-   {
-      Sin = 0,
-      Triangle,
-      Square,
-   };
-
-   class StageData
-   {
-   protected:
-
-      ///
-      typedef HashTable<const FeatureType*,GFXTexHandle> TextureTable;
-
-      /// The sparse table of textures by feature index.
-      /// @see getTex
-      /// @see setTex
-      TextureTable mTextures;
-
-      /// The cubemap for this stage.
-      GFXCubemap *mCubemap;
-
-   public:
-
-      StageData()
-         : mCubemap( NULL )
-      {
-      }
-
-      /// Returns the texture object or NULL if there is no
-      /// texture entry for that feature type in the table.
-      inline GFXTextureObject* getTex( const FeatureType &type ) const
-      {
-         TextureTable::ConstIterator iter = mTextures.find( &type );
-         if ( iter == mTextures.end() )
-            return NULL;
-
-         return iter->value.getPointer();
-      }
-
-      /// Assigns a texture object by feature type.
-      inline void setTex( const FeatureType &type, GFXTextureObject *tex )
-      {
-         if ( !tex )
-         {
-            TextureTable::Iterator iter = mTextures.find( &type );
-            if ( iter != mTextures.end() )
-               mTextures.erase( iter );
-
-            return;
-         }
-
-         TextureTable::Iterator iter = mTextures.findOrInsert( &type );
-         iter->value = tex;
-      }
-
-      /// Returns true if we have a valid texture assigned to
-      /// any feature in the texture table.
-      inline bool hasValidTex() const
-      {
-         TextureTable::ConstIterator iter = mTextures.begin();
-         for ( ; iter != mTextures.end(); iter++ )
-         {
-            if ( iter->value.isValid() )
-               return true;
-         }
-
-         return false;
-      }
-
-      /// Returns the active texture features.
-      void getFeatureSet( FeatureSet *outFeatures ) const;
-
-      /// Returns the stage cubemap.
-      GFXCubemap* getCubemap() const { return mCubemap; }
-
-      /// Set the stage cubemap.
-      void setCubemap( GFXCubemap *cubemap ) { mCubemap = cubemap; }
-
-   };
-
-public:
-
-   //-----------------------------------------------------------------------
-   // Data
-   //-----------------------------------------------------------------------
-   FileName mDiffuseMapFilename[MAX_STAGES];
-   String   mAccuMapFilename[MAX_STAGES];
-   F32      mAccuScale[MAX_STAGES];
-   F32      mAccuDirection[MAX_STAGES];
-   F32      mAccuStrength[MAX_STAGES];
-   F32      mAccuCoverage[MAX_STAGES];
-   F32      mAccuSpecular[MAX_STAGES];
-   FileName mOverlayMapFilename[MAX_STAGES];
-   FileName mLightMapFilename[MAX_STAGES];
-   FileName mToneMapFilename[MAX_STAGES];
-   FileName mDetailMapFilename[MAX_STAGES];
-   FileName mNormalMapFilename[MAX_STAGES];
-
-   FileName mSpecularMapFilename[MAX_STAGES];
-
-   /// A second normal map which repeats at the detail map
-   /// scale and blended with the base normal map.
-   FileName mDetailNormalMapFilename[MAX_STAGES];
-
-   /// The strength scalar for the detail normal map.
-   F32 mDetailNormalMapStrength[MAX_STAGES];   
-
-   FileName mEnvMapFilename[MAX_STAGES];
-   
-   /// This color is the diffuse color of the material
-   /// or if it has a texture it is multiplied against 
-   /// the diffuse texture color.
-   ColorF mDiffuse[MAX_STAGES];
-
-   ColorF mSpecular[MAX_STAGES];
-
-   F32 mSpecularPower[MAX_STAGES];
-   F32 mSpecularStrength[MAX_STAGES];
-   bool mPixelSpecular[MAX_STAGES];
-
-   bool mVertLit[MAX_STAGES];
-   
-   /// If true for a stage, vertex colors are multiplied
-   /// against diffuse colors.
-   bool mVertColor[ MAX_STAGES ];
-
-   F32 mParallaxScale[MAX_STAGES];   
-  
-   F32 mMinnaertConstant[MAX_STAGES];
-   bool mSubSurface[MAX_STAGES];
-   ColorF mSubSurfaceColor[MAX_STAGES];
-   F32 mSubSurfaceRolloff[MAX_STAGES];
-
-   /// The repetition scale of the detail texture
-   /// over the base texture.
-   Point2F mDetailScale[MAX_STAGES];
-
-   U32 mAnimFlags[MAX_STAGES];
-   Point2F mScrollDir[MAX_STAGES];
-   F32 mScrollSpeed[MAX_STAGES];
-   Point2F mScrollOffset[MAX_STAGES];
-
-   F32 mRotSpeed[MAX_STAGES];
-   Point2F mRotPivotOffset[MAX_STAGES];
-   F32 mRotPos[MAX_STAGES];
-   
-   F32 mWavePos[MAX_STAGES];
-   F32 mWaveFreq[MAX_STAGES];
-   F32 mWaveAmp[MAX_STAGES];
-   U32 mWaveType[MAX_STAGES];
-   
-   F32 mSeqFramePerSec[MAX_STAGES];
-   F32 mSeqSegSize[MAX_STAGES];
-   
-   bool mGlow[MAX_STAGES];          // entire stage glows
-   bool mEmissive[MAX_STAGES];
-
-   Point2I mCellIndex[MAX_STAGES];
-   Point2I mCellLayout[MAX_STAGES];
-   U32 mCellSize[MAX_STAGES];
-   bool mNormalMapAtlas[MAX_STAGES];
-
-   /// Special array of UVs for imposter rendering.
-   /// @see TSLastDetail
-   Vector<RectF> mImposterUVs;
-
-   /// Specual imposter rendering paramters.
-   /// @see TSLastDetail
-   Point4F mImposterLimits;
-
-   /// If the stage should use anisotropic filtering.
-   bool mUseAnisotropic[MAX_STAGES];
-
-   bool mDoubleSided;
-
-   String mCubemapName;
-   CubemapData* mCubemapData;
-   bool mDynamicCubemap;
-
-   bool mTranslucent;   
-   BlendOp mTranslucentBlendOp;
-   bool mTranslucentZWrite;
-
-   /// A generic setting which tells the system to skip 
-   /// generation of shadows from this material.
-   bool mCastShadows;
-
-   bool mAlphaTest;
-   U32 mAlphaRef;
-
-   bool mPlanarReflection;
-
-   bool mAutoGenerated;
-
-   static bool sAllowTextureTargetAssignment;
-
-   ///@{
-   /// Behavioral properties.
-
-   bool mShowFootprints;            ///< If true, show footprints when walking on surface with this material.  Defaults to false.
-   bool mShowDust;                  ///< If true, show dust emitters (footpuffs, hover trails, etc) when on surface with this material.  Defaults to false.
-
-   /// Color to use for particle effects and such when located on this material.
-   ColorF mEffectColor[ NUM_EFFECT_COLOR_STAGES ];
-
-   /// Footstep sound to play when walking on surface with this material.
-   /// Numeric ID of footstep sound defined on player datablock (0 == soft,
-   /// 1 == hard, 2 == metal, 3 == snow).
-   /// Defaults to -1 which deactivates default sound.
-   /// @see mFootstepSoundCustom
-   S32 mFootstepSoundId;
-   S32 mImpactSoundId;
-
-   /// Sound effect to play when walking on surface with this material.
-   /// If defined, overrides mFootstepSoundId.
-   /// @see mFootstepSoundId
-   SFXTrack* mFootstepSoundCustom;
-   SFXTrack* mImpactSoundCustom;
-
-   F32 mFriction;                   ///< Friction coefficient when moving along surface.
-
-   F32 mDirectSoundOcclusion;       ///< Amount of volume occlusion on direct sounds.
-   F32 mReverbSoundOcclusion;       ///< Amount of volume occlusion on reverb sounds.
-
-   ///@}
-   
-   String mMapTo; // map Material to this texture name
-  
-   ///
-   /// Material interface
-   ///
-   Material();
-
-   /// Allocates and returns a BaseMatInstance for this material.  Caller is responsible
-   /// for freeing the instance
-   virtual BaseMatInstance* createMatInstance();      
-   virtual bool isTranslucent() const { return mTranslucent && mTranslucentBlendOp != Material::None; }   
-   virtual bool isDoubleSided() const { return mDoubleSided; }
-   virtual bool isAutoGenerated() const { return mAutoGenerated; }
-   virtual void setAutoGenerated(bool isAutoGenerated) { mAutoGenerated = isAutoGenerated; }
-   virtual bool isLightmapped() const;
-   virtual bool castsShadows() const { return mCastShadows; }
-   const String &getPath() const { return mPath; }
-
-   void flush();
-
-   /// Re-initializes all the material instances 
-   /// that use this material.
-   void reload();
-
-   /// Called to update time based parameters for a material.  Ensures 
-   /// that it only happens once per tick.
-   void updateTimeBasedParams();
-
-   // SimObject
-   virtual bool onAdd();
-   virtual void onRemove();
-   virtual void inspectPostApply();
-   virtual bool writeField( StringTableEntry fieldname, const char *value );
-
-   //
-   // ConsoleObject interface
-   //
-   static void initPersistFields();
-
-   DECLARE_CONOBJECT(Material);
-protected:
-
-   // Per material animation parameters
-   U32 mLastUpdateTime;
-
-   String mPath;
-
-   static EnumTable mAnimFlagTable;
-   static EnumTable mBlendOpTable;
-   static EnumTable mWaveTypeTable;
-
-   /// Map this material to the texture specified
-   /// in the "mapTo" data variable.
-   virtual void _mapMaterial();
-
-private:
-   static GFXCubemapHandle smNormalizeCube;
-};
-
-typedef Material::AnimType MaterialAnimType;
-typedef Material::BlendOp MaterialBlendOp;
-typedef Material::WaveType MaterialWaveType;
-
-DefineBitfieldType( MaterialAnimType );
-DefineEnumType( MaterialBlendOp );
-DefineEnumType( MaterialWaveType );
-
-#endif // _MATERIALDEFINITION_H_
+//-----------------------------------------------------------------------------
+// Copyright (c) 2012 GarageGames, LLC
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to
+// deal in the Software without restriction, including without limitation the
+// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+// sell copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+// IN THE SOFTWARE.
+//-----------------------------------------------------------------------------
+#ifndef _MATERIALDEFINITION_H_
+#define _MATERIALDEFINITION_H_
+
+#ifndef _BASEMATERIALDEFINITION_H_
+   #include "materials/baseMaterialDefinition.h"
+#endif
+#ifndef _TDICTIONARY_H_
+   #include "core/util/tDictionary.h"
+#endif
+#ifndef _GFXTEXTUREHANDLE_H_
+   #include "gfx/gfxTextureHandle.h"
+#endif
+#ifndef _GFXSTRUCTS_H_
+   #include "gfx/gfxStructs.h"
+#endif
+#ifndef _GFXCUBEMAP_H_
+   #include "gfx/gfxCubemap.h"
+#endif
+#ifndef _DYNAMIC_CONSOLETYPES_H_
+   #include "console/dynamicTypes.h"
+#endif
+
+
+class CubemapData;
+class SFXTrack;
+struct SceneData;
+class FeatureSet;
+class FeatureType;
+class MaterialSoundProfile;
+class MaterialPhysicsProfile;
+
+
+/// The basic material definition.
+class Material : public BaseMaterialDefinition
+{
+   typedef BaseMaterialDefinition Parent;
+public:
+   static GFXCubemap *GetNormalizeCube();
+
+   //-----------------------------------------------------------------------
+   // Enums
+   //-----------------------------------------------------------------------
+   enum Constants
+   {
+      MAX_TEX_PER_PASS = 8,         ///< Number of textures per pass
+      MAX_STAGES = 4,
+      NUM_EFFECT_COLOR_STAGES = 2,  ///< Number of effect color definitions for transitioning effects.
+   };
+
+   enum TexType
+   {
+      NoTexture = 0,
+      Standard = 1,
+      Detail,
+      Bump,
+      DetailBump,
+      Env,
+      Cube,
+      SGCube,  // scene graph cube - probably dynamic
+      Lightmap,
+      ToneMapTex,
+      Mask,
+      BackBuff,
+      ReflectBuff,
+      Misc,
+      DynamicLight,
+      DynamicLightMask,
+      NormalizeCube,
+      TexTarget,
+   };
+
+   enum BlendOp
+   {
+      None = 0,
+      Mul,
+      Add,
+      AddAlpha,      // add modulated with alpha channel
+      Sub,
+      LerpAlpha,     // linear interpolation modulated with alpha channel
+      ToneMap,
+      NumBlendTypes
+   };
+
+   enum AnimType
+   {
+      Scroll = 1,
+      Rotate = 2,
+      Wave   = 4,
+      Scale  = 8,
+      Sequence = 16,
+   };
+
+   enum WaveType
+   {
+      Sin = 0,
+      Triangle,
+      Square,
+   };
+
+   class StageData
+   {
+   protected:
+
+      ///
+      typedef HashTable<const FeatureType*,GFXTexHandle> TextureTable;
+
+      /// The sparse table of textures by feature index.
+      /// @see getTex
+      /// @see setTex
+      TextureTable mTextures;
+
+      /// The cubemap for this stage.
+      GFXCubemap *mCubemap;
+
+   public:
+
+      StageData()
+         : mCubemap( NULL )
+      {
+      }
+
+      /// Returns the texture object or NULL if there is no
+      /// texture entry for that feature type in the table.
+      inline GFXTextureObject* getTex( const FeatureType &type ) const
+      {
+         TextureTable::ConstIterator iter = mTextures.find( &type );
+         if ( iter == mTextures.end() )
+            return NULL;
+
+         return iter->value.getPointer();
+      }
+
+      /// Assigns a texture object by feature type.
+      inline void setTex( const FeatureType &type, GFXTextureObject *tex )
+      {
+         if ( !tex )
+         {
+            TextureTable::Iterator iter = mTextures.find( &type );
+            if ( iter != mTextures.end() )
+               mTextures.erase( iter );
+
+            return;
+         }
+
+         TextureTable::Iterator iter = mTextures.findOrInsert( &type );
+         iter->value = tex;
+      }
+
+      /// Returns true if we have a valid texture assigned to
+      /// any feature in the texture table.
+      inline bool hasValidTex() const
+      {
+         TextureTable::ConstIterator iter = mTextures.begin();
+         for ( ; iter != mTextures.end(); iter++ )
+         {
+            if ( iter->value.isValid() )
+               return true;
+         }
+
+         return false;
+      }
+
+      /// Returns the active texture features.
+      void getFeatureSet( FeatureSet *outFeatures ) const;
+
+      /// Returns the stage cubemap.
+      GFXCubemap* getCubemap() const { return mCubemap; }
+
+      /// Set the stage cubemap.
+      void setCubemap( GFXCubemap *cubemap ) { mCubemap = cubemap; }
+
+   };
+
+public:
+
+   //-----------------------------------------------------------------------
+   // Data
+   //-----------------------------------------------------------------------
+   FileName mDiffuseMapFilename[MAX_STAGES];
+   FileName mOverlayMapFilename[MAX_STAGES];
+   FileName mLightMapFilename[MAX_STAGES];
+   FileName mToneMapFilename[MAX_STAGES];
+   FileName mDetailMapFilename[MAX_STAGES];
+   FileName mNormalMapFilename[MAX_STAGES];
+
+   FileName mSpecularMapFilename[MAX_STAGES];
+
+   /// A second normal map which repeats at the detail map
+   /// scale and blended with the base normal map.
+   FileName mDetailNormalMapFilename[MAX_STAGES];
+
+   /// The strength scalar for the detail normal map.
+   F32 mDetailNormalMapStrength[MAX_STAGES];   
+
+   FileName mEnvMapFilename[MAX_STAGES];
+   
+   /// This color is the diffuse color of the material
+   /// or if it has a texture it is multiplied against 
+   /// the diffuse texture color.
+   ColorF mDiffuse[MAX_STAGES];
+
+   ColorF mSpecular[MAX_STAGES];
+
+   F32 mSpecularPower[MAX_STAGES];
+   F32 mSpecularStrength[MAX_STAGES];
+   bool mPixelSpecular[MAX_STAGES];
+
+   bool mVertLit[MAX_STAGES];
+   
+   /// If true for a stage, vertex colors are multiplied
+   /// against diffuse colors.
+   bool mVertColor[ MAX_STAGES ];
+
+   F32 mParallaxScale[MAX_STAGES];   
+  
+   F32 mMinnaertConstant[MAX_STAGES];
+   bool mSubSurface[MAX_STAGES];
+   ColorF mSubSurfaceColor[MAX_STAGES];
+   F32 mSubSurfaceRolloff[MAX_STAGES];
+
+   /// The repetition scale of the detail texture
+   /// over the base texture.
+   Point2F mDetailScale[MAX_STAGES];
+
+   U32 mAnimFlags[MAX_STAGES];
+   Point2F mScrollDir[MAX_STAGES];
+   F32 mScrollSpeed[MAX_STAGES];
+   Point2F mScrollOffset[MAX_STAGES];
+
+   F32 mRotSpeed[MAX_STAGES];
+   Point2F mRotPivotOffset[MAX_STAGES];
+   F32 mRotPos[MAX_STAGES];
+   
+   F32 mWavePos[MAX_STAGES];
+   F32 mWaveFreq[MAX_STAGES];
+   F32 mWaveAmp[MAX_STAGES];
+   U32 mWaveType[MAX_STAGES];
+   
+   F32 mSeqFramePerSec[MAX_STAGES];
+   F32 mSeqSegSize[MAX_STAGES];
+   
+   bool mGlow[MAX_STAGES];          // entire stage glows
+   bool mEmissive[MAX_STAGES];
+
+   Point2I mCellIndex[MAX_STAGES];
+   Point2I mCellLayout[MAX_STAGES];
+   U32 mCellSize[MAX_STAGES];
+   bool mNormalMapAtlas[MAX_STAGES];
+
+   /// Special array of UVs for imposter rendering.
+   /// @see TSLastDetail
+   Vector<RectF> mImposterUVs;
+
+   /// Specual imposter rendering paramters.
+   /// @see TSLastDetail
+   Point4F mImposterLimits;
+
+   /// If the stage should use anisotropic filtering.
+   bool mUseAnisotropic[MAX_STAGES];
+
+   bool mDoubleSided;
+
+   String mCubemapName;
+   CubemapData* mCubemapData;
+   bool mDynamicCubemap;
+
+   bool mTranslucent;   
+   BlendOp mTranslucentBlendOp;
+   bool mTranslucentZWrite;
+
+   /// A generic setting which tells the system to skip 
+   /// generation of shadows from this material.
+   bool mCastShadows;
+
+   bool mAlphaTest;
+   U32 mAlphaRef;
+
+   bool mPlanarReflection;
+
+   bool mAutoGenerated;
+
+   static bool sAllowTextureTargetAssignment;
+
+   ///@{
+   /// Behavioral properties.
+
+   bool mShowFootprints;            ///< If true, show footprints when walking on surface with this material.  Defaults to false.
+   bool mShowDust;                  ///< If true, show dust emitters (footpuffs, hover trails, etc) when on surface with this material.  Defaults to false.
+
+   /// Color to use for particle effects and such when located on this material.
+   ColorF mEffectColor[ NUM_EFFECT_COLOR_STAGES ];
+
+   /// Footstep sound to play when walking on surface with this material.
+   /// Numeric ID of footstep sound defined on player datablock (0 == soft,
+   /// 1 == hard, 2 == metal, 3 == snow).
+   /// Defaults to -1 which deactivates default sound.
+   /// @see mFootstepSoundCustom
+   S32 mFootstepSoundId;
+   S32 mImpactSoundId;
+
+   /// Sound effect to play when walking on surface with this material.
+   /// If defined, overrides mFootstepSoundId.
+   /// @see mFootstepSoundId
+   SFXTrack* mFootstepSoundCustom;
+   SFXTrack* mImpactSoundCustom;
+
+   F32 mFriction;                   ///< Friction coefficient when moving along surface.
+
+   F32 mDirectSoundOcclusion;       ///< Amount of volume occlusion on direct sounds.
+   F32 mReverbSoundOcclusion;       ///< Amount of volume occlusion on reverb sounds.
+
+   ///@}
+   
+   String mMapTo; // map Material to this texture name
+  
+   ///
+   /// Material interface
+   ///
+   Material();
+
+   /// Allocates and returns a BaseMatInstance for this material.  Caller is responsible
+   /// for freeing the instance
+   virtual BaseMatInstance* createMatInstance();      
+   virtual bool isTranslucent() const { return mTranslucent && mTranslucentBlendOp != Material::None; }   
+   virtual bool isDoubleSided() const { return mDoubleSided; }
+   virtual bool isAutoGenerated() const { return mAutoGenerated; }
+   virtual void setAutoGenerated(bool isAutoGenerated) { mAutoGenerated = isAutoGenerated; }
+   virtual bool isLightmapped() const;
+   virtual bool castsShadows() const { return mCastShadows; }
+   const String &getPath() const { return mPath; }
+
+   void flush();
+
+   /// Re-initializes all the material instances 
+   /// that use this material.
+   void reload();
+
+   /// Called to update time based parameters for a material.  Ensures 
+   /// that it only happens once per tick.
+   void updateTimeBasedParams();
+
+   // SimObject
+   virtual bool onAdd();
+   virtual void onRemove();
+   virtual void inspectPostApply();
+   virtual bool writeField( StringTableEntry fieldname, const char *value );
+
+   //
+   // ConsoleObject interface
+   //
+   static void initPersistFields();
+
+   DECLARE_CONOBJECT(Material);
+protected:
+
+   // Per material animation parameters
+   U32 mLastUpdateTime;
+
+   String mPath;
+
+   static EnumTable mAnimFlagTable;
+   static EnumTable mBlendOpTable;
+   static EnumTable mWaveTypeTable;
+
+   /// Map this material to the texture specified
+   /// in the "mapTo" data variable.
+   virtual void _mapMaterial();
+
+private:
+   static GFXCubemapHandle smNormalizeCube;
+};
+
+typedef Material::AnimType MaterialAnimType;
+typedef Material::BlendOp MaterialBlendOp;
+typedef Material::WaveType MaterialWaveType;
+
+DefineBitfieldType( MaterialAnimType );
+DefineEnumType( MaterialBlendOp );
+DefineEnumType( MaterialWaveType );
+
+#endif // _MATERIALDEFINITION_H_
--- source/materials/materialFeatureTypes.cpp	Tue Jan 20 00:26:36 1970
+++ source/materials/materialFeatureTypes.cpp	Tue Jan 20 00:26:36 1970
@@ -1,94 +1,86 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2012 GarageGames, LLC
-//
-// Permission is hereby granted, free of charge, to any person obtaining a copy
-// of this software and associated documentation files (the "Software"), to
-// deal in the Software without restriction, including without limitation the
-// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
-// sell copies of the Software, and to permit persons to whom the Software is
-// furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-// IN THE SOFTWARE.
-//-----------------------------------------------------------------------------
-
-#include "platform/platform.h"
-#include "materials/materialFeatureTypes.h"
-
-
-ImplementFeatureType( MFT_UseInstancing, U32(-1), -1, false );
-
-ImplementFeatureType( MFT_VertTransform, MFG_Transform, 0, true );
-
-ImplementFeatureType( MFT_TexAnim, MFG_PreTexture, 1.0f, true );
-ImplementFeatureType( MFT_Parallax, MFG_PreTexture, 2.0f, true );
-ImplementFeatureType( MFT_DiffuseVertColor, MFG_PreTexture, 3.0f, true );
-
-ImplementFeatureType( MFT_AccuScale, MFG_PreTexture, 4.0f, true );
-ImplementFeatureType( MFT_AccuDirection, MFG_PreTexture, 4.0f, true );
-ImplementFeatureType( MFT_AccuStrength, MFG_PreTexture, 4.0f, true );
-ImplementFeatureType( MFT_AccuCoverage, MFG_PreTexture, 4.0f, true );
-ImplementFeatureType( MFT_AccuSpecular, MFG_PreTexture, 4.0f, true );
-
-ImplementFeatureType( MFT_DiffuseMap, MFG_Texture, 2.0f, true );
-ImplementFeatureType( MFT_OverlayMap, MFG_Texture, 3.0f, true );
-ImplementFeatureType( MFT_DetailMap, MFG_Texture, 4.0f, true );
-ImplementFeatureType( MFT_DiffuseColor, MFG_Texture, 5.0f, true );
-ImplementFeatureType( MFT_AlphaTest, MFG_Texture, 7.0f, true );
-ImplementFeatureType( MFT_SpecularMap, MFG_Texture, 8.0f, true );
-ImplementFeatureType( MFT_NormalMap, MFG_Texture, 9.0f, true );
-ImplementFeatureType( MFT_DetailNormalMap, MFG_Texture, 10.0f, true );
-
-ImplementFeatureType( MFT_AccuMap, MFG_PreLighting, 2.0f, true );
-
-ImplementFeatureType( MFT_RTLighting, MFG_Lighting, 2.0f, true );
-ImplementFeatureType( MFT_SubSurface, MFG_Lighting, 3.0f, true );
-ImplementFeatureType( MFT_LightMap, MFG_Lighting, 4.0f, true );
-ImplementFeatureType( MFT_ToneMap, MFG_Lighting, 5.0f, true );
-ImplementFeatureType( MFT_VertLitTone, MFG_Lighting, 6.0f, false );
-ImplementFeatureType( MFT_VertLit, MFG_Lighting, 7.0f, true );
-ImplementFeatureType( MFT_EnvMap, MFG_Lighting, 8.0f, true );
-ImplementFeatureType( MFT_CubeMap, MFG_Lighting, 9.0f, true );
-ImplementFeatureType( MFT_PixSpecular, MFG_Lighting, 10.0f, true );
-ImplementFeatureType( MFT_MinnaertShading, MFG_Lighting, 12.0f, true );
-
-ImplementFeatureType( MFT_GlowMask, MFG_PostLighting, 1.0f, true );
-ImplementFeatureType( MFT_Visibility, MFG_PostLighting, 2.0f, true );
-ImplementFeatureType( MFT_Fog, MFG_PostProcess, 3.0f, true );
-
-ImplementFeatureType( MFT_HDROut, MFG_PostProcess, 999.0f, true );
-
-ImplementFeatureType( MFT_IsDXTnm, U32(-1), -1, true );
-ImplementFeatureType( MFT_IsTranslucent, U32(-1), -1, true );
-ImplementFeatureType( MFT_IsTranslucentZWrite, U32(-1), -1, true );
-ImplementFeatureType( MFT_IsEmissive, U32(-1), -1, true );
-ImplementFeatureType( MFT_GlossMap, U32(-1), -1, true );
-ImplementFeatureType( MFT_DiffuseMapAtlas, U32(-1), -1, true );
-ImplementFeatureType( MFT_NormalMapAtlas, U32(-1), -1, true );
-ImplementFeatureType( MFT_InterlacedPrePass, U32(-1), -1, true );
-
-ImplementFeatureType( MFT_ParaboloidVertTransform, MFG_Transform, -1, false );
-ImplementFeatureType( MFT_IsSinglePassParaboloid, U32(-1), -1, false );
-ImplementFeatureType( MFT_EyeSpaceDepthOut, MFG_PostLighting, 2.0f, false );
-ImplementFeatureType( MFT_DepthOut, MFG_PostLighting, 3.0f, false );
-ImplementFeatureType( MFT_PrePassConditioner, MFG_PostProcess, 1.0f, false );
-ImplementFeatureType( MFT_NormalsOut, MFG_PreLighting, 1.0f, false );
-
-ImplementFeatureType( MFT_LightbufferMRT, MFG_PreLighting, 1.0f, false );
-ImplementFeatureType( MFT_RenderTarget1_Zero, MFG_PreTexture, 1.0f, false );
-
-ImplementFeatureType( MFT_Foliage, MFG_PreTransform, 1.0f, false );
-
-ImplementFeatureType( MFT_ParticleNormal, MFG_PreTransform, 2.0f, false );
-
-ImplementFeatureType( MFT_ForwardShading, U32(-1), -1, true );
-
+//-----------------------------------------------------------------------------
+// Copyright (c) 2012 GarageGames, LLC
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to
+// deal in the Software without restriction, including without limitation the
+// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+// sell copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+// IN THE SOFTWARE.
+//-----------------------------------------------------------------------------
+
+#include "platform/platform.h"
+#include "materials/materialFeatureTypes.h"
+
+
+ImplementFeatureType( MFT_UseInstancing, U32(-1), -1, false );
+
+ImplementFeatureType( MFT_VertTransform, MFG_Transform, 0, true );
+
+ImplementFeatureType( MFT_TexAnim, MFG_PreTexture, 1.0f, true );
+ImplementFeatureType( MFT_Parallax, MFG_PreTexture, 2.0f, true );
+ImplementFeatureType( MFT_DiffuseVertColor, MFG_PreTexture, 3.0f, true );
+
+ImplementFeatureType( MFT_DiffuseMap, MFG_Texture, 2.0f, true );
+ImplementFeatureType( MFT_OverlayMap, MFG_Texture, 3.0f, true );
+ImplementFeatureType( MFT_DetailMap, MFG_Texture, 4.0f, true );
+ImplementFeatureType( MFT_DiffuseColor, MFG_Texture, 5.0f, true );
+ImplementFeatureType( MFT_AlphaTest, MFG_Texture, 7.0f, true );
+ImplementFeatureType( MFT_SpecularMap, MFG_Texture, 8.0f, true );
+ImplementFeatureType( MFT_NormalMap, MFG_Texture, 9.0f, true );
+ImplementFeatureType( MFT_DetailNormalMap, MFG_Texture, 10.0f, true );
+
+ImplementFeatureType( MFT_RTLighting, MFG_Lighting, 2.0f, true );
+ImplementFeatureType( MFT_SubSurface, MFG_Lighting, 3.0f, true );
+ImplementFeatureType( MFT_LightMap, MFG_Lighting, 4.0f, true );
+ImplementFeatureType( MFT_ToneMap, MFG_Lighting, 5.0f, true );
+ImplementFeatureType( MFT_VertLitTone, MFG_Lighting, 6.0f, false );
+ImplementFeatureType( MFT_VertLit, MFG_Lighting, 7.0f, true );
+ImplementFeatureType( MFT_EnvMap, MFG_Lighting, 8.0f, true );
+ImplementFeatureType( MFT_CubeMap, MFG_Lighting, 9.0f, true );
+ImplementFeatureType( MFT_PixSpecular, MFG_Lighting, 10.0f, true );
+ImplementFeatureType( MFT_MinnaertShading, MFG_Lighting, 12.0f, true );
+
+ImplementFeatureType( MFT_GlowMask, MFG_PostLighting, 1.0f, true );
+ImplementFeatureType( MFT_Visibility, MFG_PostLighting, 2.0f, true );
+ImplementFeatureType( MFT_Fog, MFG_PostProcess, 3.0f, true );
+
+ImplementFeatureType( MFT_HDROut, MFG_PostProcess, 999.0f, true );
+
+ImplementFeatureType( MFT_IsDXTnm, U32(-1), -1, true );
+ImplementFeatureType( MFT_IsTranslucent, U32(-1), -1, true );
+ImplementFeatureType( MFT_IsTranslucentZWrite, U32(-1), -1, true );
+ImplementFeatureType( MFT_IsEmissive, U32(-1), -1, true );
+ImplementFeatureType( MFT_GlossMap, U32(-1), -1, true );
+ImplementFeatureType( MFT_DiffuseMapAtlas, U32(-1), -1, true );
+ImplementFeatureType( MFT_NormalMapAtlas, U32(-1), -1, true );
+ImplementFeatureType( MFT_InterlacedPrePass, U32(-1), -1, true );
+
+ImplementFeatureType( MFT_ParaboloidVertTransform, MFG_Transform, -1, false );
+ImplementFeatureType( MFT_IsSinglePassParaboloid, U32(-1), -1, false );
+ImplementFeatureType( MFT_EyeSpaceDepthOut, MFG_PostLighting, 2.0f, false );
+ImplementFeatureType( MFT_DepthOut, MFG_PostLighting, 3.0f, false );
+ImplementFeatureType( MFT_PrePassConditioner, MFG_PostProcess, 1.0f, false );
+ImplementFeatureType( MFT_NormalsOut, MFG_PreLighting, 1.0f, false );
+
+ImplementFeatureType( MFT_LightbufferMRT, MFG_PreLighting, 1.0f, false );
+ImplementFeatureType( MFT_RenderTarget1_Zero, MFG_PreTexture, 1.0f, false );
+
+ImplementFeatureType( MFT_Foliage, MFG_PreTransform, 1.0f, false );
+
+ImplementFeatureType( MFT_ParticleNormal, MFG_PreTransform, 2.0f, false );
+
+ImplementFeatureType( MFT_ForwardShading, U32(-1), -1, true );
+
 ImplementFeatureType( MFT_ImposterVert, MFG_PreTransform, 1.0, false );
\ No newline at end of file
--- source/materials/materialFeatureTypes.h	Tue Jan 20 00:26:36 1970
+++ source/materials/materialFeatureTypes.h	Tue Jan 20 00:26:36 1970
@@ -1,181 +1,174 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2012 GarageGames, LLC
-//
-// Permission is hereby granted, free of charge, to any person obtaining a copy
-// of this software and associated documentation files (the "Software"), to
-// deal in the Software without restriction, including without limitation the
-// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
-// sell copies of the Software, and to permit persons to whom the Software is
-// furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-// IN THE SOFTWARE.
-//-----------------------------------------------------------------------------
-
-#ifndef _MATERIALFEATURETYPES_H_
-#define _MATERIALFEATURETYPES_H_
-
-#ifndef _FEATURETYPE_H_
-#include "shaderGen/featureType.h"
-#endif
-
-
-///
-enum MaterialFeatureGroup
-{
-   /// One or more pre-transform features are 
-   /// allowed at any one time and are executed
-   /// in order to each other.
-   MFG_PreTransform,
-
-   /// Only one transform feature is allowed at
-   /// any one time.
-   MFG_Transform,
-
-   /// 
-   MFG_PostTransform,
-
-   /// The features that need to occur before texturing
-   /// takes place.  Usually these are features that will
-   /// manipulate or generate texture coords.
-   MFG_PreTexture,
-
-   /// The different diffuse color features including
-   /// textures and colors.
-   MFG_Texture,
-
-   /// 
-   MFG_PreLighting,
-
-   /// 
-   MFG_Lighting,
-
-   /// 
-   MFG_PostLighting,
-
-   /// Final features like fogging.
-   MFG_PostProcess,
-
-   /// Miscellaneous features that require no specialized 
-   /// ShaderFeature object and are just queried as flags.
-   MFG_Misc = -1,
-};
-
-/// If defined then this shader should use hardware mesh instancing.
-DeclareFeatureType( MFT_UseInstancing );
-
-/// The standard vertex transform.
-DeclareFeatureType( MFT_VertTransform );
-
-/// A special transform with paraboloid warp used 
-/// in shadow and reflection rendering.
-DeclareFeatureType( MFT_ParaboloidVertTransform );
-
-/// This feature is queried from the MFT_ParaboloidVertTransform 
-/// feature to detect if it needs to generate a single pass.
-DeclareFeatureType( MFT_IsSinglePassParaboloid );
-
-/// This feature does normal map decompression for DXT1/5.
-DeclareFeatureType( MFT_IsDXTnm );
-
-DeclareFeatureType( MFT_TexAnim );
-DeclareFeatureType( MFT_Parallax );
-
-DeclareFeatureType( MFT_DiffuseMap );
-DeclareFeatureType( MFT_OverlayMap );
-DeclareFeatureType( MFT_DetailMap );
-DeclareFeatureType( MFT_DiffuseColor );
-DeclareFeatureType( MFT_DetailNormalMap );
-
-DeclareFeatureType( MFT_AccuMap );
-DeclareFeatureType( MFT_AccuScale );
-DeclareFeatureType( MFT_AccuDirection );
-DeclareFeatureType( MFT_AccuStrength );
-DeclareFeatureType( MFT_AccuCoverage );
-DeclareFeatureType( MFT_AccuSpecular );
-
-/// This feature enables vertex coloring for the diffuse channel.
-DeclareFeatureType( MFT_DiffuseVertColor );
-
-/// This feature is used to do alpha test clipping in
-/// the shader which can be faster on SM3 and is needed
-/// when the render state alpha test is not available.
-DeclareFeatureType( MFT_AlphaTest );
-
-DeclareFeatureType( MFT_NormalMap );
-DeclareFeatureType( MFT_RTLighting );
-
-DeclareFeatureType( MFT_IsEmissive );
-DeclareFeatureType( MFT_SubSurface );
-DeclareFeatureType( MFT_LightMap );
-DeclareFeatureType( MFT_ToneMap );
-DeclareFeatureType( MFT_VertLit );
-DeclareFeatureType( MFT_VertLitTone );
-
-DeclareFeatureType( MFT_EnvMap );
-DeclareFeatureType( MFT_CubeMap );
-DeclareFeatureType( MFT_PixSpecular );
-DeclareFeatureType( MFT_SpecularMap );
-DeclareFeatureType( MFT_GlossMap );
-
-/// This feature is only used to detect alpha transparency
-/// and does not have any code associtated with it. 
-DeclareFeatureType( MFT_IsTranslucent );
-
-///
-DeclareFeatureType( MFT_IsTranslucentZWrite );
-
-/// This feature causes MFT_NormalMap to set the world
-/// space normal vector to the output color rgb.
-DeclareFeatureType( MFT_NormalsOut );
-
-DeclareFeatureType( MFT_MinnaertShading );
-DeclareFeatureType( MFT_GlowMask );
-DeclareFeatureType( MFT_Visibility );
-DeclareFeatureType( MFT_EyeSpaceDepthOut );
-DeclareFeatureType( MFT_DepthOut );
-DeclareFeatureType( MFT_Fog );
-
-/// This should be the last feature of any material that
-/// renders to a HDR render target.  It converts the high
-/// dynamic range color into the correct HDR encoded format.
-DeclareFeatureType( MFT_HDROut );
-
-///
-DeclareFeatureType( MFT_PrePassConditioner );
-DeclareFeatureType( MFT_InterlacedPrePass );
-
-/// This feature causes MFT_ToneMap and MFT_LightMap to output their light color
-/// to the second render-target
-DeclareFeatureType( MFT_LightbufferMRT );
-
-/// This feature outputs black to RenderTarget1
-DeclareFeatureType( MFT_RenderTarget1_Zero );
-
-DeclareFeatureType( MFT_Foliage );
-
-// Texture atlasing features
-DeclareFeatureType( MFT_DiffuseMapAtlas );
-DeclareFeatureType( MFT_NormalMapAtlas );
-
-// Particle features
-DeclareFeatureType( MFT_ParticleNormal );
-
-/// This feature is used to indicate that the material should use forward shading
-/// instead of deferred shading (if applicable)
-DeclareFeatureType( MFT_ForwardShading );
-
-/// A special vertex feature which unpacks the imposter vertex
-/// so that the rest of the material features can work on it.
-DeclareFeatureType( MFT_ImposterVert );
-
-
-#endif // _MATERIALFEATURETYPES_H_
+//-----------------------------------------------------------------------------
+// Copyright (c) 2012 GarageGames, LLC
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to
+// deal in the Software without restriction, including without limitation the
+// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+// sell copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+// IN THE SOFTWARE.
+//-----------------------------------------------------------------------------
+
+#ifndef _MATERIALFEATURETYPES_H_
+#define _MATERIALFEATURETYPES_H_
+
+#ifndef _FEATURETYPE_H_
+#include "shaderGen/featureType.h"
+#endif
+
+
+///
+enum MaterialFeatureGroup
+{
+   /// One or more pre-transform features are 
+   /// allowed at any one time and are executed
+   /// in order to each other.
+   MFG_PreTransform,
+
+   /// Only one transform feature is allowed at
+   /// any one time.
+   MFG_Transform,
+
+   /// 
+   MFG_PostTransform,
+
+   /// The features that need to occur before texturing
+   /// takes place.  Usually these are features that will
+   /// manipulate or generate texture coords.
+   MFG_PreTexture,
+
+   /// The different diffuse color features including
+   /// textures and colors.
+   MFG_Texture,
+
+   /// 
+   MFG_PreLighting,
+
+   /// 
+   MFG_Lighting,
+
+   /// 
+   MFG_PostLighting,
+
+   /// Final features like fogging.
+   MFG_PostProcess,
+
+   /// Miscellaneous features that require no specialized 
+   /// ShaderFeature object and are just queried as flags.
+   MFG_Misc = -1,
+};
+
+/// If defined then this shader should use hardware mesh instancing.
+DeclareFeatureType( MFT_UseInstancing );
+
+/// The standard vertex transform.
+DeclareFeatureType( MFT_VertTransform );
+
+/// A special transform with paraboloid warp used 
+/// in shadow and reflection rendering.
+DeclareFeatureType( MFT_ParaboloidVertTransform );
+
+/// This feature is queried from the MFT_ParaboloidVertTransform 
+/// feature to detect if it needs to generate a single pass.
+DeclareFeatureType( MFT_IsSinglePassParaboloid );
+
+/// This feature does normal map decompression for DXT1/5.
+DeclareFeatureType( MFT_IsDXTnm );
+
+DeclareFeatureType( MFT_TexAnim );
+DeclareFeatureType( MFT_Parallax );
+
+DeclareFeatureType( MFT_DiffuseMap );
+DeclareFeatureType( MFT_OverlayMap );
+DeclareFeatureType( MFT_DetailMap );
+DeclareFeatureType( MFT_DiffuseColor );
+DeclareFeatureType( MFT_DetailNormalMap );
+
+/// This feature enables vertex coloring for the diffuse channel.
+DeclareFeatureType( MFT_DiffuseVertColor );
+
+/// This feature is used to do alpha test clipping in
+/// the shader which can be faster on SM3 and is needed
+/// when the render state alpha test is not available.
+DeclareFeatureType( MFT_AlphaTest );
+
+DeclareFeatureType( MFT_NormalMap );
+DeclareFeatureType( MFT_RTLighting );
+
+DeclareFeatureType( MFT_IsEmissive );
+DeclareFeatureType( MFT_SubSurface );
+DeclareFeatureType( MFT_LightMap );
+DeclareFeatureType( MFT_ToneMap );
+DeclareFeatureType( MFT_VertLit );
+DeclareFeatureType( MFT_VertLitTone );
+
+DeclareFeatureType( MFT_EnvMap );
+DeclareFeatureType( MFT_CubeMap );
+DeclareFeatureType( MFT_PixSpecular );
+DeclareFeatureType( MFT_SpecularMap );
+DeclareFeatureType( MFT_GlossMap );
+
+/// This feature is only used to detect alpha transparency
+/// and does not have any code associtated with it. 
+DeclareFeatureType( MFT_IsTranslucent );
+
+///
+DeclareFeatureType( MFT_IsTranslucentZWrite );
+
+/// This feature causes MFT_NormalMap to set the world
+/// space normal vector to the output color rgb.
+DeclareFeatureType( MFT_NormalsOut );
+
+DeclareFeatureType( MFT_MinnaertShading );
+DeclareFeatureType( MFT_GlowMask );
+DeclareFeatureType( MFT_Visibility );
+DeclareFeatureType( MFT_EyeSpaceDepthOut );
+DeclareFeatureType( MFT_DepthOut );
+DeclareFeatureType( MFT_Fog );
+
+/// This should be the last feature of any material that
+/// renders to a HDR render target.  It converts the high
+/// dynamic range color into the correct HDR encoded format.
+DeclareFeatureType( MFT_HDROut );
+
+///
+DeclareFeatureType( MFT_PrePassConditioner );
+DeclareFeatureType( MFT_InterlacedPrePass );
+
+/// This feature causes MFT_ToneMap and MFT_LightMap to output their light color
+/// to the second render-target
+DeclareFeatureType( MFT_LightbufferMRT );
+
+/// This feature outputs black to RenderTarget1
+DeclareFeatureType( MFT_RenderTarget1_Zero );
+
+DeclareFeatureType( MFT_Foliage );
+
+// Texture atlasing features
+DeclareFeatureType( MFT_DiffuseMapAtlas );
+DeclareFeatureType( MFT_NormalMapAtlas );
+
+// Particle features
+DeclareFeatureType( MFT_ParticleNormal );
+
+/// This feature is used to indicate that the material should use forward shading
+/// instead of deferred shading (if applicable)
+DeclareFeatureType( MFT_ForwardShading );
+
+/// A special vertex feature which unpacks the imposter vertex
+/// so that the rest of the material features can work on it.
+DeclareFeatureType( MFT_ImposterVert );
+
+
+#endif // _MATERIALFEATURETYPES_H_
--- source/materials/processedMaterial.cpp	Tue Jan 20 00:26:36 1970
+++ source/materials/processedMaterial.cpp	Tue Jan 20 00:26:36 1970
@@ -1,491 +1,483 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2012 GarageGames, LLC
-//
-// Permission is hereby granted, free of charge, to any person obtaining a copy
-// of this software and associated documentation files (the "Software"), to
-// deal in the Software without restriction, including without limitation the
-// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
-// sell copies of the Software, and to permit persons to whom the Software is
-// furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-// IN THE SOFTWARE.
-//-----------------------------------------------------------------------------
-
-#include "platform/platform.h"
-#include "materials/processedMaterial.h"
-
-#include "materials/sceneData.h"
-#include "materials/materialParameters.h"
-#include "materials/matTextureTarget.h"
-#include "materials/materialFeatureTypes.h"
-#include "materials/materialManager.h"
-#include "scene/sceneRenderState.h"
-#include "gfx/gfxPrimitiveBuffer.h"
-#include "gfx/gfxTextureManager.h"
-#include "gfx/sim/cubemapData.h"
-
-RenderPassData::RenderPassData()
-{
-   reset();
-}
-
-void RenderPassData::reset()
-{
-   for( U32 i = 0; i < Material::MAX_TEX_PER_PASS; ++ i )
-   {
-      destructInPlace( &mTexSlot[ i ] );
-      mSamplerNames[ i ].clear();
-   }
-
-   dMemset( &mTexSlot, 0, sizeof(mTexSlot) );
-   dMemset( &mTexType, 0, sizeof(mTexType) );
-
-   mCubeMap = NULL;
-   mNumTex = mNumTexReg = mStageNum = 0;
-   mGlow = false;
-   mBlendOp = Material::None;
-
-   mFeatureData.clear();
-
-   for (U32 i = 0; i < STATE_MAX; i++)
-      mRenderStates[i] = NULL;
-}
-
-String RenderPassData::describeSelf() const
-{
-   String desc;
-
-   // Now write all the textures.
-   String texName;
-   for ( U32 i=0; i < Material::MAX_TEX_PER_PASS; i++ )
-   {
-      if ( mTexType[i] == Material::TexTarget )
-         texName = ( mTexSlot[i].texTarget ) ? mTexSlot[i].texTarget->getName() : "null_texTarget";
-      else if ( mTexType[i] == Material::Cube && mCubeMap )
-         texName = mCubeMap->getPath();
-      else if ( mTexSlot[i].texObject )
-         texName = mTexSlot[i].texObject->getPath();
-      else
-         continue;
-
-      desc += String::ToString( "TexSlot %d: %d, %s\n", i, mTexType[i], texName.c_str() );
-   }
-
-   // Write out the first render state which is the
-   // basis for all the other states and shoud be
-   // enough to define the pass uniquely.
-   desc += mRenderStates[0]->getDesc().describeSelf();
-
-   return desc;
-}
-
-ProcessedMaterial::ProcessedMaterial()
-:  mMaterial( NULL ),
-   mCurrentParams( NULL ),
-   mHasSetStageData( false ),
-   mHasGlow( false ),   
-   mMaxStages( 0 ),
-   mVertexFormat( NULL ),
-   mUserObject( NULL )
-{
-   VECTOR_SET_ASSOCIATION( mPasses );
-}
-
-ProcessedMaterial::~ProcessedMaterial()
-{
-   for_each( mPasses.begin(), mPasses.end(), delete_pointer() );
-}
-
-void ProcessedMaterial::_setBlendState(Material::BlendOp blendOp, GFXStateBlockDesc& desc )
-{
-   switch( blendOp )
-   {
-   case Material::Add:
-      {
-         desc.blendSrc = GFXBlendOne;
-         desc.blendDest = GFXBlendOne;
-         break;
-      }
-   case Material::AddAlpha:
-      {
-         desc.blendSrc = GFXBlendSrcAlpha;
-         desc.blendDest = GFXBlendOne;
-         break;
-      }
-   case Material::Mul:
-      {
-         desc.blendSrc = GFXBlendDestColor;
-         desc.blendDest = GFXBlendZero;
-         break;
-      }
-   case Material::LerpAlpha:
-      {
-         desc.blendSrc = GFXBlendSrcAlpha;
-         desc.blendDest = GFXBlendInvSrcAlpha;
-         break;
-      }
-
-   default:
-      {
-         // default to LerpAlpha
-         desc.blendSrc = GFXBlendSrcAlpha;
-         desc.blendDest = GFXBlendInvSrcAlpha;
-         break;
-      }
-   }
-}
-
-void ProcessedMaterial::setBuffers(GFXVertexBufferHandleBase* vertBuffer, GFXPrimitiveBufferHandle* primBuffer)
-{
-   GFX->setVertexBuffer( *vertBuffer );
-   GFX->setPrimitiveBuffer( *primBuffer );
-}
-
-bool ProcessedMaterial::stepInstance()
-{
-   AssertFatal( false, "ProcessedMaterial::stepInstance() - This type of material doesn't support instancing!" );
-   return false;
-}
-
-String ProcessedMaterial::_getTexturePath(const String& filename)
-{
-   // if '/', then path is specified, use it.
-   if( filename.find('/') != String::NPos )
-   {
-      return filename;
-   }
-
-   // otherwise, construct path
-   return mMaterial->getPath() + filename;
-}
-
-GFXTexHandle ProcessedMaterial::_createTexture( const char* filename, GFXTextureProfile *profile)
-{
-   return GFXTexHandle( _getTexturePath(filename), profile, avar("%s() - NA (line %d)", __FUNCTION__, __LINE__) );
-}
-
-void ProcessedMaterial::addStateBlockDesc(const GFXStateBlockDesc& sb)
-{
-   mUserDefined = sb;
-}
-
-void ProcessedMaterial::_initStateBlockTemplates(GFXStateBlockDesc& stateTranslucent, GFXStateBlockDesc& stateGlow, GFXStateBlockDesc& stateReflect)
-{
-   // Translucency   
-   stateTranslucent.blendDefined = true;
-   stateTranslucent.blendEnable = mMaterial->mTranslucentBlendOp != Material::None;
-   _setBlendState(mMaterial->mTranslucentBlendOp, stateTranslucent);
-   stateTranslucent.zDefined = true;
-   stateTranslucent.zWriteEnable = mMaterial->mTranslucentZWrite;   
-   stateTranslucent.alphaDefined = true;
-   stateTranslucent.alphaTestEnable = mMaterial->mAlphaTest;
-   stateTranslucent.alphaTestRef = mMaterial->mAlphaRef;
-   stateTranslucent.alphaTestFunc = GFXCmpGreaterEqual;
-   stateTranslucent.samplersDefined = true;
-   stateTranslucent.samplers[0].textureColorOp = GFXTOPModulate;
-   stateTranslucent.samplers[0].alphaOp = GFXTOPModulate;   
-   stateTranslucent.samplers[0].alphaArg1 = GFXTATexture;
-   stateTranslucent.samplers[0].alphaArg2 = GFXTADiffuse;   
-
-   // Glow   
-   stateGlow.zDefined = true;
-   stateGlow.zWriteEnable = false;
-
-   // Reflect   
-   stateReflect.cullDefined = true;
-   stateReflect.cullMode = mMaterial->mDoubleSided ? GFXCullNone : GFXCullCW;
-}
-
-void ProcessedMaterial::_initRenderPassDataStateBlocks()
-{
-   for (U32 pass = 0; pass < mPasses.size(); pass++)
-      _initRenderStateStateBlocks( mPasses[pass] );
-}
-
-void ProcessedMaterial::_initPassStateBlock( RenderPassData *rpd, GFXStateBlockDesc &result )
-{
-   if ( rpd->mBlendOp != Material::None )
-   {
-      result.blendDefined = true;
-      result.blendEnable = true;
-      _setBlendState( rpd->mBlendOp, result );
-   }
-
-   if (mMaterial && mMaterial->isDoubleSided())
-   {
-      result.cullDefined = true;
-      result.cullMode = GFXCullNone;         
-   }
-
-   if(mMaterial && mMaterial->mAlphaTest)
-   {
-      result.alphaDefined = true;
-      result.alphaTestEnable = mMaterial->mAlphaTest;
-      result.alphaTestRef = mMaterial->mAlphaRef;
-      result.alphaTestFunc = GFXCmpGreaterEqual;
-   }
-
-   result.samplersDefined = true;
-   NamedTexTarget *texTarget;
-
-   U32 maxAnisotropy = 1;
-   if (mMaterial &&  mMaterial->mUseAnisotropic[ rpd->mStageNum ] )
-      maxAnisotropy = MATMGR->getDefaultAnisotropy();
-
-   for( U32 i=0; i < rpd->mNumTex; i++ )
-   {      
-      U32 currTexFlag = rpd->mTexType[i];
-
-      switch( currTexFlag )
-      {
-         default:
-         {
-            result.samplers[i].textureColorOp = GFXTOPModulate;
-            result.samplers[i].addressModeU = GFXAddressWrap;
-            result.samplers[i].addressModeV = GFXAddressWrap;
-
-            if ( maxAnisotropy > 1 )
-            {
-               result.samplers[i].minFilter = GFXTextureFilterAnisotropic;
-               result.samplers[i].magFilter = GFXTextureFilterAnisotropic;
-               result.samplers[i].maxAnisotropy = maxAnisotropy;
-            }
-            else
-            {
-               result.samplers[i].minFilter = GFXTextureFilterLinear;
-               result.samplers[i].magFilter = GFXTextureFilterLinear;
-            }
-            break;
-         }
-
-         case Material::Cube:
-         case Material::SGCube:
-         case Material::NormalizeCube:
-         {
-            result.samplers[i].addressModeU = GFXAddressClamp;
-            result.samplers[i].addressModeV = GFXAddressClamp;
-            result.samplers[i].addressModeW = GFXAddressClamp;
-            break;
-         }
-
-         case Material::TexTarget:
-         {
-            texTarget = mPasses[0]->mTexSlot[i].texTarget;
-            if ( texTarget )
-               texTarget->setupSamplerState( &result.samplers[i] );
-            break;
-         }
-      }
-   }
-
-   // The prepass will take care of writing to the 
-   // zbuffer, so we don't have to by default.
-   // The prepass can't write to the backbuffer's zbuffer in OpenGL.
-   if (  MATMGR->getPrePassEnabled() && 
-         !GFX->getAdapterType() == OpenGL && 
-         !mFeatures.hasFeature(MFT_ForwardShading))
-      result.setZReadWrite( result.zEnable, false );
-
-   result.addDesc(mUserDefined);
-}
-
-/// Creates the default state blocks for a list of render states
-void ProcessedMaterial::_initRenderStateStateBlocks( RenderPassData *rpd )
-{
-   GFXStateBlockDesc stateTranslucent;
-   GFXStateBlockDesc stateGlow;
-   GFXStateBlockDesc stateReflect;
-   GFXStateBlockDesc statePass;
-
-   _initStateBlockTemplates( stateTranslucent, stateGlow, stateReflect );
-   _initPassStateBlock( rpd, statePass );
-
-   // Ok, we've got our templates set up, let's combine them together based on state and
-   // create our state blocks.
-   for (U32 i = 0; i < RenderPassData::STATE_MAX; i++)
-   {
-      GFXStateBlockDesc stateFinal;
-
-      if (i & RenderPassData::STATE_REFLECT)
-         stateFinal.addDesc(stateReflect);
-      if (i & RenderPassData::STATE_TRANSLUCENT)
-         stateFinal.addDesc(stateTranslucent);
-      if (i & RenderPassData::STATE_GLOW)
-         stateFinal.addDesc(stateGlow);
-
-      stateFinal.addDesc(statePass);
-
-      if (i & RenderPassData::STATE_WIREFRAME)
-         stateFinal.fillMode = GFXFillWireframe;
-
-      GFXStateBlockRef sb = GFX->createStateBlock(stateFinal);
-      rpd->mRenderStates[i] = sb;
-   }   
-}
-
-U32 ProcessedMaterial::_getRenderStateIndex( const SceneRenderState *sceneState, 
-                                             const SceneData &sgData )
-{
-   // Based on what the state of the world is, get our render state block
-   U32 currState = 0;
-
-   // NOTE: We should only use per-material or per-pass hints to
-   // change the render state.  This is importaint because we 
-   // only change the state blocks between material passes.
-   //
-   // For example sgData.visibility would be bad to use
-   // in here without changing how RenderMeshMgr works.
-
-   if ( sgData.binType == SceneData::GlowBin )
-      currState |= RenderPassData::STATE_GLOW;
-
-   if ( sceneState && sceneState->isReflectPass() )
-      currState |= RenderPassData::STATE_REFLECT;
-
-   if ( sgData.binType != SceneData::PrePassBin &&
-        mMaterial->isTranslucent() )
-      currState |= RenderPassData::STATE_TRANSLUCENT;
-
-   if ( sgData.wireframe )
-      currState |= RenderPassData::STATE_WIREFRAME;
-
-   return currState;
-}
-
-void ProcessedMaterial::_setRenderState(  const SceneRenderState *state, 
-                                          const SceneData& sgData, 
-                                          U32 pass )
-{   
-   // Make sure we have the pass
-   if ( pass >= mPasses.size() )
-      return;
-
-   U32 currState = _getRenderStateIndex( state, sgData );
-
-   GFX->setStateBlock(mPasses[pass]->mRenderStates[currState]);   
-}
-
-
-void ProcessedMaterial::_setStageData()
-{
-   // Only do this once
-   if ( mHasSetStageData ) 
-      return;
-   mHasSetStageData = true;
-
-   U32 i;
-
-   // Load up all the textures for every possible stage
-   for( i=0; i<Material::MAX_STAGES; i++ )
-   {
-      // DiffuseMap
-      if( mMaterial->mDiffuseMapFilename[i].isNotEmpty() )
-      {
-         mStages[i].setTex( MFT_DiffuseMap, _createTexture( mMaterial->mDiffuseMapFilename[i], &GFXDefaultStaticDiffuseProfile ) );
-         if (!mStages[i].getTex( MFT_DiffuseMap ))
-         {
-            mMaterial->logError("Failed to load diffuse map %s for stage %i", _getTexturePath(mMaterial->mDiffuseMapFilename[i]).c_str(), i);
-            
-            // Load a debug texture to make it clear to the user 
-            // that the texture for this stage was missing.
-            mStages[i].setTex( MFT_DiffuseMap, _createTexture( GFXTextureManager::getMissingTexturePath().c_str(), &GFXDefaultStaticDiffuseProfile ) );
-         }
-      }
-
-      // OverlayMap
-      if( mMaterial->mOverlayMapFilename[i].isNotEmpty() )
-      {
-         mStages[i].setTex( MFT_OverlayMap, _createTexture( mMaterial->mOverlayMapFilename[i], &GFXDefaultStaticDiffuseProfile ) );
-         if(!mStages[i].getTex( MFT_OverlayMap ))
-            mMaterial->logError("Failed to load overlay map %s for stage %i", _getTexturePath(mMaterial->mOverlayMapFilename[i]).c_str(), i);
-      }
-
-      // LightMap
-      if( mMaterial->mLightMapFilename[i].isNotEmpty() )
-      {
-         mStages[i].setTex( MFT_LightMap, _createTexture( mMaterial->mLightMapFilename[i], &GFXDefaultStaticDiffuseProfile ) );
-         if(!mStages[i].getTex( MFT_LightMap ))
-            mMaterial->logError("Failed to load light map %s for stage %i", _getTexturePath(mMaterial->mLightMapFilename[i]).c_str(), i);
-      }
-
-      // ToneMap
-      if( mMaterial->mToneMapFilename[i].isNotEmpty() )
-      {
-         mStages[i].setTex( MFT_ToneMap, _createTexture( mMaterial->mToneMapFilename[i], &GFXDefaultStaticDiffuseProfile ) );
-         if(!mStages[i].getTex( MFT_ToneMap ))
-            mMaterial->logError("Failed to load tone map %s for stage %i", _getTexturePath(mMaterial->mToneMapFilename[i]).c_str(), i);
-      }
-
-      // DetailMap
-      if( mMaterial->mDetailMapFilename[i].isNotEmpty() )
-      {
-         mStages[i].setTex( MFT_DetailMap, _createTexture( mMaterial->mDetailMapFilename[i], &GFXDefaultStaticDiffuseProfile ) );
-         if(!mStages[i].getTex( MFT_DetailMap ))
-            mMaterial->logError("Failed to load detail map %s for stage %i", _getTexturePath(mMaterial->mDetailMapFilename[i]).c_str(), i);
-      }
-
-      // NormalMap
-      if( mMaterial->mNormalMapFilename[i].isNotEmpty() )
-      {
-         mStages[i].setTex( MFT_NormalMap, _createTexture( mMaterial->mNormalMapFilename[i], &GFXDefaultStaticNormalMapProfile ) );
-         if(!mStages[i].getTex( MFT_NormalMap ))
-            mMaterial->logError("Failed to load normal map %s for stage %i", _getTexturePath(mMaterial->mNormalMapFilename[i]).c_str(), i);
-      }
-
-      // Detail Normal Map
-      if( mMaterial->mDetailNormalMapFilename[i].isNotEmpty() )
-      {
-         mStages[i].setTex( MFT_DetailNormalMap, _createTexture( mMaterial->mDetailNormalMapFilename[i], &GFXDefaultStaticNormalMapProfile ) );
-         if(!mStages[i].getTex( MFT_DetailNormalMap ))
-            mMaterial->logError("Failed to load normal map %s for stage %i", _getTexturePath(mMaterial->mDetailNormalMapFilename[i]).c_str(), i);
-      }
-      
-      // SpecularMap
-      if( mMaterial->mSpecularMapFilename[i].isNotEmpty() )
-      {
-         mStages[i].setTex( MFT_SpecularMap, _createTexture( mMaterial->mSpecularMapFilename[i], &GFXDefaultStaticDiffuseProfile ) );
-         if(!mStages[i].getTex( MFT_SpecularMap ))
-            mMaterial->logError("Failed to load specular map %s for stage %i", _getTexturePath(mMaterial->mSpecularMapFilename[i]).c_str(), i);
-      }
-
-      // AccuMap
-      if( mMaterial->mAccuMapFilename[i].isNotEmpty() )
-      {
-         mStages[i].setTex( MFT_AccuMap, _createTexture( mMaterial->mAccuMapFilename[i], &GFXDefaultStaticDiffuseProfile ) );
-         if(!mStages[i].getTex( MFT_AccuMap ))
-            mMaterial->logError("Failed to load accu map %s for stage %i", _getTexturePath(mMaterial->mAccuMapFilename[i]).c_str(), i);
-      }  
-
-      // EnironmentMap
-      if( mMaterial->mEnvMapFilename[i].isNotEmpty() )
-      {
-         mStages[i].setTex( MFT_EnvMap, _createTexture( mMaterial->mEnvMapFilename[i], &GFXDefaultStaticDiffuseProfile ) );
-         if(!mStages[i].getTex( MFT_EnvMap ))
-            mMaterial->logError("Failed to load environment map %s for stage %i", _getTexturePath(mMaterial->mEnvMapFilename[i]).c_str(), i);
-      }
-   }
-
-	mMaterial->mCubemapData = dynamic_cast<CubemapData*>(Sim::findObject( mMaterial->mCubemapName ));
-	if( !mMaterial->mCubemapData )
-		mMaterial->mCubemapData = NULL;
-		
-		
-   // If we have a cubemap put it on stage 0 (cubemaps only supported on stage 0)
-   if( mMaterial->mCubemapData )
-   {
-      mMaterial->mCubemapData->createMap();
-      mStages[0].setCubemap( mMaterial->mCubemapData->mCubemap ); 
-      if ( !mStages[0].getCubemap() )
-         mMaterial->logError("Failed to load cubemap");
-   }
-}
-
+//-----------------------------------------------------------------------------
+// Copyright (c) 2012 GarageGames, LLC
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to
+// deal in the Software without restriction, including without limitation the
+// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+// sell copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+// IN THE SOFTWARE.
+//-----------------------------------------------------------------------------
+
+#include "platform/platform.h"
+#include "materials/processedMaterial.h"
+
+#include "materials/sceneData.h"
+#include "materials/materialParameters.h"
+#include "materials/matTextureTarget.h"
+#include "materials/materialFeatureTypes.h"
+#include "materials/materialManager.h"
+#include "scene/sceneRenderState.h"
+#include "gfx/gfxPrimitiveBuffer.h"
+#include "gfx/gfxTextureManager.h"
+#include "gfx/sim/cubemapData.h"
+
+RenderPassData::RenderPassData()
+{
+   reset();
+}
+
+void RenderPassData::reset()
+{
+   for( U32 i = 0; i < Material::MAX_TEX_PER_PASS; ++ i )
+   {
+      destructInPlace( &mTexSlot[ i ] );
+      mSamplerNames[ i ].clear();
+   }
+
+   dMemset( &mTexSlot, 0, sizeof(mTexSlot) );
+   dMemset( &mTexType, 0, sizeof(mTexType) );
+
+   mCubeMap = NULL;
+   mNumTex = mNumTexReg = mStageNum = 0;
+   mGlow = false;
+   mBlendOp = Material::None;
+
+   mFeatureData.clear();
+
+   for (U32 i = 0; i < STATE_MAX; i++)
+      mRenderStates[i] = NULL;
+}
+
+String RenderPassData::describeSelf() const
+{
+   String desc;
+
+   // Now write all the textures.
+   String texName;
+   for ( U32 i=0; i < Material::MAX_TEX_PER_PASS; i++ )
+   {
+      if ( mTexType[i] == Material::TexTarget )
+         texName = ( mTexSlot[i].texTarget ) ? mTexSlot[i].texTarget->getName() : "null_texTarget";
+      else if ( mTexType[i] == Material::Cube && mCubeMap )
+         texName = mCubeMap->getPath();
+      else if ( mTexSlot[i].texObject )
+         texName = mTexSlot[i].texObject->getPath();
+      else
+         continue;
+
+      desc += String::ToString( "TexSlot %d: %d, %s\n", i, mTexType[i], texName.c_str() );
+   }
+
+   // Write out the first render state which is the
+   // basis for all the other states and shoud be
+   // enough to define the pass uniquely.
+   desc += mRenderStates[0]->getDesc().describeSelf();
+
+   return desc;
+}
+
+ProcessedMaterial::ProcessedMaterial()
+:  mMaterial( NULL ),
+   mCurrentParams( NULL ),
+   mHasSetStageData( false ),
+   mHasGlow( false ),   
+   mMaxStages( 0 ),
+   mVertexFormat( NULL ),
+   mUserObject( NULL )
+{
+   VECTOR_SET_ASSOCIATION( mPasses );
+}
+
+ProcessedMaterial::~ProcessedMaterial()
+{
+   for_each( mPasses.begin(), mPasses.end(), delete_pointer() );
+}
+
+void ProcessedMaterial::_setBlendState(Material::BlendOp blendOp, GFXStateBlockDesc& desc )
+{
+   switch( blendOp )
+   {
+   case Material::Add:
+      {
+         desc.blendSrc = GFXBlendOne;
+         desc.blendDest = GFXBlendOne;
+         break;
+      }
+   case Material::AddAlpha:
+      {
+         desc.blendSrc = GFXBlendSrcAlpha;
+         desc.blendDest = GFXBlendOne;
+         break;
+      }
+   case Material::Mul:
+      {
+         desc.blendSrc = GFXBlendDestColor;
+         desc.blendDest = GFXBlendZero;
+         break;
+      }
+   case Material::LerpAlpha:
+      {
+         desc.blendSrc = GFXBlendSrcAlpha;
+         desc.blendDest = GFXBlendInvSrcAlpha;
+         break;
+      }
+
+   default:
+      {
+         // default to LerpAlpha
+         desc.blendSrc = GFXBlendSrcAlpha;
+         desc.blendDest = GFXBlendInvSrcAlpha;
+         break;
+      }
+   }
+}
+
+void ProcessedMaterial::setBuffers(GFXVertexBufferHandleBase* vertBuffer, GFXPrimitiveBufferHandle* primBuffer)
+{
+   GFX->setVertexBuffer( *vertBuffer );
+   GFX->setPrimitiveBuffer( *primBuffer );
+}
+
+bool ProcessedMaterial::stepInstance()
+{
+   AssertFatal( false, "ProcessedMaterial::stepInstance() - This type of material doesn't support instancing!" );
+   return false;
+}
+
+String ProcessedMaterial::_getTexturePath(const String& filename)
+{
+   // if '/', then path is specified, use it.
+   if( filename.find('/') != String::NPos )
+   {
+      return filename;
+   }
+
+   // otherwise, construct path
+   return mMaterial->getPath() + filename;
+}
+
+GFXTexHandle ProcessedMaterial::_createTexture( const char* filename, GFXTextureProfile *profile)
+{
+   return GFXTexHandle( _getTexturePath(filename), profile, avar("%s() - NA (line %d)", __FUNCTION__, __LINE__) );
+}
+
+void ProcessedMaterial::addStateBlockDesc(const GFXStateBlockDesc& sb)
+{
+   mUserDefined = sb;
+}
+
+void ProcessedMaterial::_initStateBlockTemplates(GFXStateBlockDesc& stateTranslucent, GFXStateBlockDesc& stateGlow, GFXStateBlockDesc& stateReflect)
+{
+   // Translucency   
+   stateTranslucent.blendDefined = true;
+   stateTranslucent.blendEnable = mMaterial->mTranslucentBlendOp != Material::None;
+   _setBlendState(mMaterial->mTranslucentBlendOp, stateTranslucent);
+   stateTranslucent.zDefined = true;
+   stateTranslucent.zWriteEnable = mMaterial->mTranslucentZWrite;   
+   stateTranslucent.alphaDefined = true;
+   stateTranslucent.alphaTestEnable = mMaterial->mAlphaTest;
+   stateTranslucent.alphaTestRef = mMaterial->mAlphaRef;
+   stateTranslucent.alphaTestFunc = GFXCmpGreaterEqual;
+   stateTranslucent.samplersDefined = true;
+   stateTranslucent.samplers[0].textureColorOp = GFXTOPModulate;
+   stateTranslucent.samplers[0].alphaOp = GFXTOPModulate;   
+   stateTranslucent.samplers[0].alphaArg1 = GFXTATexture;
+   stateTranslucent.samplers[0].alphaArg2 = GFXTADiffuse;   
+
+   // Glow   
+   stateGlow.zDefined = true;
+   stateGlow.zWriteEnable = false;
+
+   // Reflect   
+   stateReflect.cullDefined = true;
+   stateReflect.cullMode = mMaterial->mDoubleSided ? GFXCullNone : GFXCullCW;
+}
+
+void ProcessedMaterial::_initRenderPassDataStateBlocks()
+{
+   for (U32 pass = 0; pass < mPasses.size(); pass++)
+      _initRenderStateStateBlocks( mPasses[pass] );
+}
+
+void ProcessedMaterial::_initPassStateBlock( RenderPassData *rpd, GFXStateBlockDesc &result )
+{
+   if ( rpd->mBlendOp != Material::None )
+   {
+      result.blendDefined = true;
+      result.blendEnable = true;
+      _setBlendState( rpd->mBlendOp, result );
+   }
+
+   if (mMaterial && mMaterial->isDoubleSided())
+   {
+      result.cullDefined = true;
+      result.cullMode = GFXCullNone;         
+   }
+
+   if(mMaterial && mMaterial->mAlphaTest)
+   {
+      result.alphaDefined = true;
+      result.alphaTestEnable = mMaterial->mAlphaTest;
+      result.alphaTestRef = mMaterial->mAlphaRef;
+      result.alphaTestFunc = GFXCmpGreaterEqual;
+   }
+
+   result.samplersDefined = true;
+   NamedTexTarget *texTarget;
+
+   U32 maxAnisotropy = 1;
+   if (mMaterial &&  mMaterial->mUseAnisotropic[ rpd->mStageNum ] )
+      maxAnisotropy = MATMGR->getDefaultAnisotropy();
+
+   for( U32 i=0; i < rpd->mNumTex; i++ )
+   {      
+      U32 currTexFlag = rpd->mTexType[i];
+
+      switch( currTexFlag )
+      {
+         default:
+         {
+            result.samplers[i].textureColorOp = GFXTOPModulate;
+            result.samplers[i].addressModeU = GFXAddressWrap;
+            result.samplers[i].addressModeV = GFXAddressWrap;
+
+            if ( maxAnisotropy > 1 )
+            {
+               result.samplers[i].minFilter = GFXTextureFilterAnisotropic;
+               result.samplers[i].magFilter = GFXTextureFilterAnisotropic;
+               result.samplers[i].maxAnisotropy = maxAnisotropy;
+            }
+            else
+            {
+               result.samplers[i].minFilter = GFXTextureFilterLinear;
+               result.samplers[i].magFilter = GFXTextureFilterLinear;
+            }
+            break;
+         }
+
+         case Material::Cube:
+         case Material::SGCube:
+         case Material::NormalizeCube:
+         {
+            result.samplers[i].addressModeU = GFXAddressClamp;
+            result.samplers[i].addressModeV = GFXAddressClamp;
+            result.samplers[i].addressModeW = GFXAddressClamp;
+            break;
+         }
+
+         case Material::TexTarget:
+         {
+            texTarget = mPasses[0]->mTexSlot[i].texTarget;
+            if ( texTarget )
+               texTarget->setupSamplerState( &result.samplers[i] );
+            break;
+         }
+      }
+   }
+
+   // The prepass will take care of writing to the 
+   // zbuffer, so we don't have to by default.
+   // The prepass can't write to the backbuffer's zbuffer in OpenGL.
+   if (  MATMGR->getPrePassEnabled() && 
+         !GFX->getAdapterType() == OpenGL && 
+         !mFeatures.hasFeature(MFT_ForwardShading))
+      result.setZReadWrite( result.zEnable, false );
+
+   result.addDesc(mUserDefined);
+}
+
+/// Creates the default state blocks for a list of render states
+void ProcessedMaterial::_initRenderStateStateBlocks( RenderPassData *rpd )
+{
+   GFXStateBlockDesc stateTranslucent;
+   GFXStateBlockDesc stateGlow;
+   GFXStateBlockDesc stateReflect;
+   GFXStateBlockDesc statePass;
+
+   _initStateBlockTemplates( stateTranslucent, stateGlow, stateReflect );
+   _initPassStateBlock( rpd, statePass );
+
+   // Ok, we've got our templates set up, let's combine them together based on state and
+   // create our state blocks.
+   for (U32 i = 0; i < RenderPassData::STATE_MAX; i++)
+   {
+      GFXStateBlockDesc stateFinal;
+
+      if (i & RenderPassData::STATE_REFLECT)
+         stateFinal.addDesc(stateReflect);
+      if (i & RenderPassData::STATE_TRANSLUCENT)
+         stateFinal.addDesc(stateTranslucent);
+      if (i & RenderPassData::STATE_GLOW)
+         stateFinal.addDesc(stateGlow);
+
+      stateFinal.addDesc(statePass);
+
+      if (i & RenderPassData::STATE_WIREFRAME)
+         stateFinal.fillMode = GFXFillWireframe;
+
+      GFXStateBlockRef sb = GFX->createStateBlock(stateFinal);
+      rpd->mRenderStates[i] = sb;
+   }   
+}
+
+U32 ProcessedMaterial::_getRenderStateIndex( const SceneRenderState *sceneState, 
+                                             const SceneData &sgData )
+{
+   // Based on what the state of the world is, get our render state block
+   U32 currState = 0;
+
+   // NOTE: We should only use per-material or per-pass hints to
+   // change the render state.  This is importaint because we 
+   // only change the state blocks between material passes.
+   //
+   // For example sgData.visibility would be bad to use
+   // in here without changing how RenderMeshMgr works.
+
+   if ( sgData.binType == SceneData::GlowBin )
+      currState |= RenderPassData::STATE_GLOW;
+
+   if ( sceneState && sceneState->isReflectPass() )
+      currState |= RenderPassData::STATE_REFLECT;
+
+   if ( sgData.binType != SceneData::PrePassBin &&
+        mMaterial->isTranslucent() )
+      currState |= RenderPassData::STATE_TRANSLUCENT;
+
+   if ( sgData.wireframe )
+      currState |= RenderPassData::STATE_WIREFRAME;
+
+   return currState;
+}
+
+void ProcessedMaterial::_setRenderState(  const SceneRenderState *state, 
+                                          const SceneData& sgData, 
+                                          U32 pass )
+{   
+   // Make sure we have the pass
+   if ( pass >= mPasses.size() )
+      return;
+
+   U32 currState = _getRenderStateIndex( state, sgData );
+
+   GFX->setStateBlock(mPasses[pass]->mRenderStates[currState]);   
+}
+
+
+void ProcessedMaterial::_setStageData()
+{
+   // Only do this once
+   if ( mHasSetStageData ) 
+      return;
+   mHasSetStageData = true;
+
+   U32 i;
+
+   // Load up all the textures for every possible stage
+   for( i=0; i<Material::MAX_STAGES; i++ )
+   {
+      // DiffuseMap
+      if( mMaterial->mDiffuseMapFilename[i].isNotEmpty() )
+      {
+         mStages[i].setTex( MFT_DiffuseMap, _createTexture( mMaterial->mDiffuseMapFilename[i], &GFXDefaultStaticDiffuseProfile ) );
+         if (!mStages[i].getTex( MFT_DiffuseMap ))
+         {
+            mMaterial->logError("Failed to load diffuse map %s for stage %i", _getTexturePath(mMaterial->mDiffuseMapFilename[i]).c_str(), i);
+            
+            // Load a debug texture to make it clear to the user 
+            // that the texture for this stage was missing.
+            mStages[i].setTex( MFT_DiffuseMap, _createTexture( GFXTextureManager::getMissingTexturePath().c_str(), &GFXDefaultStaticDiffuseProfile ) );
+         }
+      }
+
+      // OverlayMap
+      if( mMaterial->mOverlayMapFilename[i].isNotEmpty() )
+      {
+         mStages[i].setTex( MFT_OverlayMap, _createTexture( mMaterial->mOverlayMapFilename[i], &GFXDefaultStaticDiffuseProfile ) );
+         if(!mStages[i].getTex( MFT_OverlayMap ))
+            mMaterial->logError("Failed to load overlay map %s for stage %i", _getTexturePath(mMaterial->mOverlayMapFilename[i]).c_str(), i);
+      }
+
+      // LightMap
+      if( mMaterial->mLightMapFilename[i].isNotEmpty() )
+      {
+         mStages[i].setTex( MFT_LightMap, _createTexture( mMaterial->mLightMapFilename[i], &GFXDefaultStaticDiffuseProfile ) );
+         if(!mStages[i].getTex( MFT_LightMap ))
+            mMaterial->logError("Failed to load light map %s for stage %i", _getTexturePath(mMaterial->mLightMapFilename[i]).c_str(), i);
+      }
+
+      // ToneMap
+      if( mMaterial->mToneMapFilename[i].isNotEmpty() )
+      {
+         mStages[i].setTex( MFT_ToneMap, _createTexture( mMaterial->mToneMapFilename[i], &GFXDefaultStaticDiffuseProfile ) );
+         if(!mStages[i].getTex( MFT_ToneMap ))
+            mMaterial->logError("Failed to load tone map %s for stage %i", _getTexturePath(mMaterial->mToneMapFilename[i]).c_str(), i);
+      }
+
+      // DetailMap
+      if( mMaterial->mDetailMapFilename[i].isNotEmpty() )
+      {
+         mStages[i].setTex( MFT_DetailMap, _createTexture( mMaterial->mDetailMapFilename[i], &GFXDefaultStaticDiffuseProfile ) );
+         if(!mStages[i].getTex( MFT_DetailMap ))
+            mMaterial->logError("Failed to load detail map %s for stage %i", _getTexturePath(mMaterial->mDetailMapFilename[i]).c_str(), i);
+      }
+
+      // NormalMap
+      if( mMaterial->mNormalMapFilename[i].isNotEmpty() )
+      {
+         mStages[i].setTex( MFT_NormalMap, _createTexture( mMaterial->mNormalMapFilename[i], &GFXDefaultStaticNormalMapProfile ) );
+         if(!mStages[i].getTex( MFT_NormalMap ))
+            mMaterial->logError("Failed to load normal map %s for stage %i", _getTexturePath(mMaterial->mNormalMapFilename[i]).c_str(), i);
+      }
+
+      // Detail Normal Map
+      if( mMaterial->mDetailNormalMapFilename[i].isNotEmpty() )
+      {
+         mStages[i].setTex( MFT_DetailNormalMap, _createTexture( mMaterial->mDetailNormalMapFilename[i], &GFXDefaultStaticNormalMapProfile ) );
+         if(!mStages[i].getTex( MFT_DetailNormalMap ))
+            mMaterial->logError("Failed to load normal map %s for stage %i", _getTexturePath(mMaterial->mDetailNormalMapFilename[i]).c_str(), i);
+      }
+      
+      // SpecularMap
+      if( mMaterial->mSpecularMapFilename[i].isNotEmpty() )
+      {
+         mStages[i].setTex( MFT_SpecularMap, _createTexture( mMaterial->mSpecularMapFilename[i], &GFXDefaultStaticDiffuseProfile ) );
+         if(!mStages[i].getTex( MFT_SpecularMap ))
+            mMaterial->logError("Failed to load specular map %s for stage %i", _getTexturePath(mMaterial->mSpecularMapFilename[i]).c_str(), i);
+      }
+
+      // EnironmentMap
+      if( mMaterial->mEnvMapFilename[i].isNotEmpty() )
+      {
+         mStages[i].setTex( MFT_EnvMap, _createTexture( mMaterial->mEnvMapFilename[i], &GFXDefaultStaticDiffuseProfile ) );
+         if(!mStages[i].getTex( MFT_EnvMap ))
+            mMaterial->logError("Failed to load environment map %s for stage %i", _getTexturePath(mMaterial->mEnvMapFilename[i]).c_str(), i);
+      }
+   }
+
+	mMaterial->mCubemapData = dynamic_cast<CubemapData*>(Sim::findObject( mMaterial->mCubemapName ));
+	if( !mMaterial->mCubemapData )
+		mMaterial->mCubemapData = NULL;
+		
+		
+   // If we have a cubemap put it on stage 0 (cubemaps only supported on stage 0)
+   if( mMaterial->mCubemapData )
+   {
+      mMaterial->mCubemapData->createMap();
+      mStages[0].setCubemap( mMaterial->mCubemapData->mCubemap ); 
+      if ( !mStages[0].getCubemap() )
+         mMaterial->logError("Failed to load cubemap");
+   }
+}
+
--- source/materials/processedShaderMaterial.cpp	Tue Jan 20 00:26:36 1970
+++ source/materials/processedShaderMaterial.cpp	Tue Jan 20 00:26:36 1970
@@ -1,1335 +1,1294 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2012 GarageGames, LLC
-//
-// Permission is hereby granted, free of charge, to any person obtaining a copy
-// of this software and associated documentation files (the "Software"), to
-// deal in the Software without restriction, including without limitation the
-// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
-// sell copies of the Software, and to permit persons to whom the Software is
-// furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-// IN THE SOFTWARE.
-//-----------------------------------------------------------------------------
-
-#include "platform/platform.h"
-#include "materials/processedShaderMaterial.h"
-
-#include "core/util/safeDelete.h"
-#include "gfx/sim/cubemapData.h"
-#include "gfx/gfxShader.h"
-#include "gfx/genericConstBuffer.h"
-#include "gfx/gfxPrimitiveBuffer.h"
-#include "scene/sceneRenderState.h"
-#include "shaderGen/shaderFeature.h"
-#include "shaderGen/shaderGenVars.h"
-#include "shaderGen/featureMgr.h"
-#include "shaderGen/shaderGen.h"
-#include "materials/sceneData.h"
-#include "materials/materialFeatureTypes.h"
-#include "materials/materialManager.h"
-#include "materials/shaderMaterialParameters.h"
-#include "materials/matTextureTarget.h"
-#include "gfx/util/screenspace.h"
-#include "math/util/matrixSet.h"
-
-// We need to include customMaterialDefinition for ShaderConstHandles::init
-#include "materials/customMaterialDefinition.h"
-
-///
-/// ShaderConstHandles
-///
-void ShaderConstHandles::init( GFXShader *shader, CustomMaterial* mat /*=NULL*/ )
-{
-   mDiffuseColorSC = shader->getShaderConstHandle("$diffuseMaterialColor");
-   mTexMatSC = shader->getShaderConstHandle(ShaderGenVars::texMat);
-   mToneMapTexSC = shader->getShaderConstHandle(ShaderGenVars::toneMap);
-   mSpecularColorSC = shader->getShaderConstHandle(ShaderGenVars::specularColor);
-   mSpecularPowerSC = shader->getShaderConstHandle(ShaderGenVars::specularPower);
-   mSpecularStrengthSC = shader->getShaderConstHandle(ShaderGenVars::specularStrength);
-   mAccuScaleSC = shader->getShaderConstHandle("$accuScale");
-   mAccuDirectionSC = shader->getShaderConstHandle("$accuDirection");
-   mAccuStrengthSC = shader->getShaderConstHandle("$accuStrength");
-   mAccuCoverageSC = shader->getShaderConstHandle("$accuCoverage");
-   mAccuSpecularSC = shader->getShaderConstHandle("$accuSpecular");
-   mParallaxInfoSC = shader->getShaderConstHandle("$parallaxInfo");
-   mFogDataSC = shader->getShaderConstHandle(ShaderGenVars::fogData);
-   mFogColorSC = shader->getShaderConstHandle(ShaderGenVars::fogColor);
-   mDetailScaleSC = shader->getShaderConstHandle(ShaderGenVars::detailScale);
-   mVisiblitySC = shader->getShaderConstHandle(ShaderGenVars::visibility);
-   mColorMultiplySC = shader->getShaderConstHandle(ShaderGenVars::colorMultiply);
-   mAlphaTestValueSC = shader->getShaderConstHandle(ShaderGenVars::alphaTestValue);
-   mModelViewProjSC = shader->getShaderConstHandle(ShaderGenVars::modelview);
-   mWorldViewOnlySC = shader->getShaderConstHandle(ShaderGenVars::worldViewOnly);
-   mWorldToCameraSC = shader->getShaderConstHandle(ShaderGenVars::worldToCamera);
-   mWorldToObjSC = shader->getShaderConstHandle(ShaderGenVars::worldToObj);
-   mViewToObjSC = shader->getShaderConstHandle(ShaderGenVars::viewToObj);
-   mCubeTransSC = shader->getShaderConstHandle(ShaderGenVars::cubeTrans);
-   mObjTransSC = shader->getShaderConstHandle(ShaderGenVars::objTrans);
-   mCubeEyePosSC = shader->getShaderConstHandle(ShaderGenVars::cubeEyePos);
-   mEyePosSC = shader->getShaderConstHandle(ShaderGenVars::eyePos);
-   mEyePosWorldSC = shader->getShaderConstHandle(ShaderGenVars::eyePosWorld);
-   m_vEyeSC = shader->getShaderConstHandle(ShaderGenVars::vEye);
-   mEyeMatSC = shader->getShaderConstHandle(ShaderGenVars::eyeMat);
-   mOneOverFarplane = shader->getShaderConstHandle(ShaderGenVars::oneOverFarplane);
-   mAccumTimeSC = shader->getShaderConstHandle(ShaderGenVars::accumTime);
-   mMinnaertConstantSC = shader->getShaderConstHandle(ShaderGenVars::minnaertConstant);
-   mSubSurfaceParamsSC = shader->getShaderConstHandle(ShaderGenVars::subSurfaceParams);
-   mDiffuseAtlasParamsSC = shader->getShaderConstHandle(ShaderGenVars::diffuseAtlasParams);
-   mDiffuseAtlasTileSC = shader->getShaderConstHandle(ShaderGenVars::diffuseAtlasTileParams);
-   mBumpAtlasParamsSC = shader->getShaderConstHandle(ShaderGenVars::bumpAtlasParams);
-   mBumpAtlasTileSC = shader->getShaderConstHandle(ShaderGenVars::bumpAtlasTileParams);
-   mRTSizeSC = shader->getShaderConstHandle( "$targetSize" );
-   mOneOverRTSizeSC = shader->getShaderConstHandle( "$oneOverTargetSize" );
-   mDetailBumpStrength = shader->getShaderConstHandle( "$detailBumpStrength" );
-   mViewProjSC = shader->getShaderConstHandle( "$viewProj" );
-
-   // MFT_ImposterVert
-   mImposterUVs = shader->getShaderConstHandle( "$imposterUVs" );
-   mImposterLimits = shader->getShaderConstHandle( "$imposterLimits" );
-
-   for (S32 i = 0; i < TEXTURE_STAGE_COUNT; ++i)
-      mRTParamsSC[i] = shader->getShaderConstHandle( String::ToString( "$rtParams%d", i ) );
-
-   // Clear any existing texture handles.
-   dMemset( mTexHandlesSC, 0, sizeof( mTexHandlesSC ) );
-   if(mat)
-   {
-      for (S32 i = 0; i < Material::MAX_TEX_PER_PASS; ++i)
-         mTexHandlesSC[i] = shader->getShaderConstHandle(mat->mSamplerNames[i]);
-   }
-}
-
-///
-/// ShaderRenderPassData
-///
-void ShaderRenderPassData::reset()
-{
-   Parent::reset();
-
-   shader = NULL;
-
-   for ( U32 i=0; i < featureShaderHandles.size(); i++ )
-      delete featureShaderHandles[i];
-
-   featureShaderHandles.clear();
-}
-
-String ShaderRenderPassData::describeSelf() const
-{
-   // First write the shader identification.
-   String desc = String::ToString( "%s\n", shader->describeSelf().c_str() );
-
-   // Let the parent get the rest.
-   desc += Parent::describeSelf();
-
-   return desc;
-}
-
-///
-/// ProcessedShaderMaterial
-///
-ProcessedShaderMaterial::ProcessedShaderMaterial()
-   :  mDefaultParameters( NULL ),
-      mInstancingState( NULL )
-{
-   VECTOR_SET_ASSOCIATION( mShaderConstDesc );
-   VECTOR_SET_ASSOCIATION( mParameterHandles );
-}
-
-ProcessedShaderMaterial::ProcessedShaderMaterial(Material &mat)
-   :  mDefaultParameters( NULL ),
-      mInstancingState( NULL )
-{
-   VECTOR_SET_ASSOCIATION( mShaderConstDesc );
-   VECTOR_SET_ASSOCIATION( mParameterHandles );
-   mMaterial = &mat;
-}
-
-ProcessedShaderMaterial::~ProcessedShaderMaterial()
-{
-   SAFE_DELETE(mInstancingState);
-   SAFE_DELETE(mDefaultParameters);
-   for (U32 i = 0; i < mParameterHandles.size(); i++)
-      SAFE_DELETE(mParameterHandles[i]);
-}
-
-//
-// Material init
-//
-bool ProcessedShaderMaterial::init( const FeatureSet &features, 
-                                    const GFXVertexFormat *vertexFormat,
-                                    const MatFeaturesDelegate &featuresDelegate )
-{
-   // Load our textures
-   _setStageData();
-
-   // Determine how many stages we use
-   mMaxStages = getNumStages(); 
-   mVertexFormat = vertexFormat;
-   mFeatures.clear();
-   mStateHint.clear();
-   SAFE_DELETE(mInstancingState);
-
-   for( U32 i=0; i<mMaxStages; i++ )
-   {
-      MaterialFeatureData fd;
-
-      // Determine the features of this stage
-      _determineFeatures( i, fd, features );
-   
-      // Let the delegate poke at the features.
-      if ( featuresDelegate )
-         featuresDelegate( this, i, fd, features );
-
-      // Create the passes for this stage
-      if ( fd.features.isNotEmpty() )
-         if( !_createPasses( fd, i, features ) )
-            return false;
-   }
-
-   _initRenderPassDataStateBlocks();
-   _initMaterialParameters();
-   mDefaultParameters =  allocMaterialParameters();
-   setMaterialParameters( mDefaultParameters, 0 );
-   mStateHint.init( this );   
-
-   // Enable instancing if we have it.
-   if ( mFeatures.hasFeature( MFT_UseInstancing ) )
-   {
-      mInstancingState = new InstancingState();
-      mInstancingState->setFormat( &_getRPD( 0 )->shader->mInstancingFormat, mVertexFormat );
-   }
-
-   // Check for a RenderTexTargetBin assignment
-   // *IMPORTANT NOTE* 
-   // This is a temporary solution for getting diffuse mapping working with tex targets for standard materials
-   // It should be removed once this is done properly, at that time the sAllowTextureTargetAssignment should also be removed 
-   // from Material (it is necessary for catching shadow maps/post effect this shouldn't be applied to)
-   if (Material::sAllowTextureTargetAssignment)
-      if (mMaterial && mMaterial->mDiffuseMapFilename[0].isNotEmpty() && mMaterial->mDiffuseMapFilename[0].substr( 0, 1 ).equal("#"))
-      {
-         String texTargetBufferName = mMaterial->mDiffuseMapFilename[0].substr(1, mMaterial->mDiffuseMapFilename[0].length() - 1);
-         NamedTexTarget *texTarget = NamedTexTarget::find( texTargetBufferName ); 
-
-         RenderPassData* rpd = getPass(0);      
-
-         if (rpd)
-         {
-            rpd->mTexSlot[0].texTarget = texTarget;
-            rpd->mTexType[0] = Material::TexTarget;
-         }
-      }
-
-   return true;
-}
-
-U32 ProcessedShaderMaterial::getNumStages()
-{
-   // Loops through all stages to determine how many 
-   // stages we actually use.  
-   // 
-   // The first stage is always active else we shouldn't be
-   // creating the material to begin with.
-   U32 numStages = 1;
-
-   U32 i;
-   for( i=1; i<Material::MAX_STAGES; i++ )
-   {
-      // Assume stage is inactive
-      bool stageActive = false;
-
-      // Cubemaps only on first stage
-      if( i == 0 )
-      {
-         // If we have a cubemap the stage is active
-         if( mMaterial->mCubemapData || mMaterial->mDynamicCubemap )
-         {
-            numStages++;
-            continue;
-         }
-      }
-
-      // If we have a texture for the a feature the 
-      // stage is active.
-      if ( mStages[i].hasValidTex() )
-         stageActive = true;
-
-      // If this stage has specular lighting, it's active
-      if ( mMaterial->mPixelSpecular[i] )
-         stageActive = true;
-
-      // If this stage has diffuse color, it's active
-      if (  mMaterial->mDiffuse[i].alpha > 0 &&
-            mMaterial->mDiffuse[i] != ColorF::WHITE )
-         stageActive = true;
-
-      // If we have a Material that is vertex lit
-      // then it may not have a texture
-      if( mMaterial->mVertLit[i] )
-         stageActive = true;
-
-      // Increment the number of active stages
-      numStages += stageActive;
-   }
-
-   return numStages;
-}
-
-void ProcessedShaderMaterial::_determineFeatures(  U32 stageNum, 
-                                                   MaterialFeatureData &fd, 
-                                                   const FeatureSet &features )
-{
-   PROFILE_SCOPE( ProcessedShaderMaterial_DetermineFeatures );
-
-   const F32 shaderVersion = GFX->getPixelShaderVersion();
-   AssertFatal(shaderVersion > 0.0 , "Cannot create a shader material if we don't support shaders");
-
-   bool lastStage = stageNum == (mMaxStages-1);
-
-   // First we add all the features which the 
-   // material has defined.
-
-   if ( mMaterial->isTranslucent() )
-   {
-      // Note: This is for decal blending into the prepass
-      // for AL... it probably needs to be made clearer.
-      if (  mMaterial->mTranslucentBlendOp == Material::LerpAlpha &&
-            mMaterial->mTranslucentZWrite )
-         fd.features.addFeature( MFT_IsTranslucentZWrite );
-      else
-      {
-         fd.features.addFeature( MFT_IsTranslucent );
-         fd.features.addFeature( MFT_ForwardShading );
-      }
-   }
-
-   // TODO: This sort of sucks... BL should somehow force this
-   // feature on from the outside and not this way.
-   if ( dStrcmp( LIGHTMGR->getId(), "BLM" ) == 0 )
-      fd.features.addFeature( MFT_ForwardShading );
-
-   // Disabling the InterlacedPrePass feature for now. It is not ready for prime-time
-   // and it should not be triggered off of the DoubleSided parameter. [2/5/2010 Pat]
-   /*if ( mMaterial->isDoubleSided() )
-   {
-      fd.features.addFeature( MFT_InterlacedPrePass );
-   }*/
-
-   // Allow instancing if it was requested and the card supports
-   // SM 3.0 or above.
-   //
-   // We also disable instancing for non-single pass materials
-   // and glowing materials because its untested/unimplemented.
-   //
-   if (  features.hasFeature( MFT_UseInstancing ) &&
-         mMaxStages == 1 &&
-         !mMaterial->mGlow[0] &&
-         shaderVersion >= 3.0f )
-      fd.features.addFeature( MFT_UseInstancing );
-
-   if ( mMaterial->mAlphaTest )
-      fd.features.addFeature( MFT_AlphaTest );
-
-   if ( mMaterial->mEmissive[stageNum] )
-      fd.features.addFeature( MFT_IsEmissive );
-   else
-      fd.features.addFeature( MFT_RTLighting );
-
-   if ( mMaterial->mAnimFlags[stageNum] )
-      fd.features.addFeature( MFT_TexAnim );  
-
-   if ( mMaterial->mVertLit[stageNum] )
-      fd.features.addFeature( MFT_VertLit );
-   
-   // cubemaps only available on stage 0 for now - bramage   
-   if ( stageNum < 1 && 
-         (  (  mMaterial->mCubemapData && mMaterial->mCubemapData->mCubemap ) ||
-               mMaterial->mDynamicCubemap ) )
-   fd.features.addFeature( MFT_CubeMap );
-
-   fd.features.addFeature( MFT_Visibility );
-
-   if (  lastStage && 
-         (  !gClientSceneGraph->usePostEffectFog() ||
-            fd.features.hasFeature( MFT_IsTranslucent ) ||
-            fd.features.hasFeature( MFT_ForwardShading )) )
-      fd.features.addFeature( MFT_Fog );
-
-   if ( mMaterial->mMinnaertConstant[stageNum] > 0.0f )
-      fd.features.addFeature( MFT_MinnaertShading );
-
-   if ( mMaterial->mSubSurface[stageNum] )
-      fd.features.addFeature( MFT_SubSurface );
-
-   if ( !mMaterial->mCellLayout[stageNum].isZero() )
-   {
-      fd.features.addFeature( MFT_DiffuseMapAtlas );
-
-      if ( mMaterial->mNormalMapAtlas )
-         fd.features.addFeature( MFT_NormalMapAtlas );
-   }
-
-   // Grab other features like normal maps, base texture, etc.
-   FeatureSet mergeFeatures;
-   mStages[stageNum].getFeatureSet( &mergeFeatures );
-   fd.features.merge( mergeFeatures );
-   
-   if ( fd.features[ MFT_NormalMap ] )   
-   {   
-      if (  mStages[stageNum].getTex( MFT_NormalMap )->mFormat == GFXFormatDXT5 &&   
-           !mStages[stageNum].getTex( MFT_NormalMap )->mHasTransparency )   
-         fd.features.addFeature( MFT_IsDXTnm );   
-   }
-
-   // Now for some more advanced features that we 
-   // cannot do on SM 2.0 and below.
-   if ( shaderVersion > 2.0f )
-   {
-      // Only allow parallax if we have a normal map and
-      // we're not using DXTnm compression.
-      if (  mMaterial->mParallaxScale[stageNum] > 0.0f &&
-         fd.features[ MFT_NormalMap ] &&
-         !fd.features[ MFT_IsDXTnm ] )
-         fd.features.addFeature( MFT_Parallax );
-
-      // If not parallax then allow per-pixel specular if
-      // we have real time lighting enabled.
-      else if (   fd.features[MFT_RTLighting] && 
-                  mMaterial->mPixelSpecular[stageNum] )
-         fd.features.addFeature( MFT_PixSpecular );
-   }
-
-   // Without realtime lighting and on lower end 
-   // shader models disable the specular map.
-   if (  !fd.features[ MFT_RTLighting ] || shaderVersion == 2.0 )
-      fd.features.removeFeature( MFT_SpecularMap );
-
-   // If we have a specular map then make sure we
-   // have per-pixel specular enabled.
-   if( fd.features[ MFT_SpecularMap ] )
-   {
-      fd.features.addFeature( MFT_PixSpecular );
-
-      // Check for an alpha channel on the specular map. If it has one (and it
-      // has values less than 255) than the artist has put the gloss map into
-      // the alpha channel.
-      if( mStages[stageNum].getTex( MFT_SpecularMap )->mHasTransparency )
-         fd.features.addFeature( MFT_GlossMap );
-   }
-   
-   if ( mMaterial->mAccuMapFilename[stageNum] != String::EmptyString) {
-      fd.features.addFeature( MFT_AccuMap );
-   }
-
-   // we need both diffuse and normal maps + sm3 to have an accu map
-   if(   fd.features[ MFT_AccuMap ] && 
-       ( !fd.features[ MFT_DiffuseMap ] || 
-         !fd.features[ MFT_NormalMap ] ||
-         GFX->getPixelShaderVersion() < 3.0f ) ) {
-      AssertWarn(false, "SAHARA: Using an Accu Map requires SM 3.0 and a normal map.");
-      fd.features.removeFeature( MFT_AccuMap );
-   }
-
-   // if we still have the AccuMap feature, we add all accu constant features
-   if ( fd.features[ MFT_AccuMap ] ) {
-      // add the dependencies of the accu map
-      fd.features.addFeature( MFT_AccuScale );
-      fd.features.addFeature( MFT_AccuDirection );
-      fd.features.addFeature( MFT_AccuStrength );
-      fd.features.addFeature( MFT_AccuCoverage );
-      fd.features.addFeature( MFT_AccuSpecular );
-      // now remove some features that are not compatible with this
-      fd.features.removeFeature( MFT_UseInstancing );
-   }
-
-   // Without a base texture use the diffuse color
-   // feature to ensure some sort of output.
-   if (!fd.features[MFT_DiffuseMap])
-   {
-      fd.features.addFeature( MFT_DiffuseColor );
-
-      // No texture coords... no overlay.
-      fd.features.removeFeature( MFT_OverlayMap );
-   }
-
-   // If we have a diffuse map and the alpha on the diffuse isn't
-   // zero and the color isn't pure white then multiply the color.
-   else if (   mMaterial->mDiffuse[stageNum].alpha > 0.0f && 
-               mMaterial->mDiffuse[stageNum] != ColorF::WHITE )
-      fd.features.addFeature( MFT_DiffuseColor );
-
-   // If lightmaps or tonemaps are enabled or we 
-   // don't have a second UV set then we cannot 
-   // use the overlay texture.
-   if (  fd.features[MFT_LightMap] || 
-         fd.features[MFT_ToneMap] || 
-         mVertexFormat->getTexCoordCount() < 2 )
-      fd.features.removeFeature( MFT_OverlayMap );
-
-   // If tonemaps are enabled don't use lightmap
-   if ( fd.features[MFT_ToneMap] || mVertexFormat->getTexCoordCount() < 2 )
-      fd.features.removeFeature( MFT_LightMap );
-
-   // Don't allow tonemaps if we don't have a second UV set
-   if ( mVertexFormat->getTexCoordCount() < 2 )
-      fd.features.removeFeature( MFT_ToneMap );
-
-   // Always add the HDR output feature.  
-   //
-   // It will be filtered out if it was disabled 
-   // for this material creation below.
-   //
-   // Also the shader code will evaluate to a nop
-   // if HDR is not enabled in the scene.
-   //
-   fd.features.addFeature( MFT_HDROut );
-
-   // If vertex color is enabled on the material's stage and
-   // color is present in vertex format, add diffuse vertex
-   // color feature.
-   
-   if (  mMaterial->mVertColor[ stageNum ] &&
-         mVertexFormat->hasColor() )
-      fd.features.addFeature( MFT_DiffuseVertColor );
-
-   // Allow features to add themselves.
-   for ( U32 i = 0; i < FEATUREMGR->getFeatureCount(); i++ )
-   {
-      const FeatureInfo &info = FEATUREMGR->getAt( i );
-      info.feature->determineFeature(  mMaterial, 
-                                       mVertexFormat, 
-                                       stageNum, 
-                                       *info.type, 
-                                       features, 
-                                       &fd );
-   }
-
-   // Now disable any features that were 
-   // not part of the input feature handle.
-   fd.features.filter( features );
-}
-
-bool ProcessedShaderMaterial::_createPasses( MaterialFeatureData &stageFeatures, U32 stageNum, const FeatureSet &features )
-{
-   // Creates passes for the given stage
-   ShaderRenderPassData passData;
-   U32 texIndex = 0;
-
-   for( U32 i=0; i < FEATUREMGR->getFeatureCount(); i++ )
-   {
-      const FeatureInfo &info = FEATUREMGR->getAt( i );
-      if ( !stageFeatures.features.hasFeature( *info.type ) ) 
-         continue;
-
-      U32 numTexReg = info.feature->getResources( stageFeatures ).numTexReg;
-
-      // adds pass if blend op changes for feature
-      _setPassBlendOp( info.feature, passData, texIndex, stageFeatures, stageNum, features );
-
-      // Add pass if num tex reg is going to be too high
-      if( passData.mNumTexReg + numTexReg > GFX->getNumSamplers() )
-      {
-         if( !_addPass( passData, texIndex, stageFeatures, stageNum, features ) )
-            return false;
-         _setPassBlendOp( info.feature, passData, texIndex, stageFeatures, stageNum, features );
-      }
-
-      passData.mNumTexReg += numTexReg;
-      passData.mFeatureData.features.addFeature( *info.type );
-      info.feature->setTexData( mStages[stageNum], stageFeatures, passData, texIndex );
-
-      // Add pass if tex units are maxed out
-      if( texIndex > GFX->getNumSamplers() )
-      {
-         if( !_addPass( passData, texIndex, stageFeatures, stageNum, features ) )
-            return false;
-         _setPassBlendOp( info.feature, passData, texIndex, stageFeatures, stageNum, features );
-      }
-   }
-
-   const FeatureSet &passFeatures = passData.mFeatureData.codify();
-   if ( passFeatures.isNotEmpty() )
-   {
-      mFeatures.merge( passFeatures );
-      if(  !_addPass( passData, texIndex, stageFeatures, stageNum, features ) )
-      {
-         mFeatures.clear();
-         return false;
-      }
-   }
-
-   return true;
-} 
-
-void ProcessedShaderMaterial::_initMaterialParameters()
-{   
-   // Cleanup anything left first.
-   SAFE_DELETE( mDefaultParameters );
-   for ( U32 i = 0; i < mParameterHandles.size(); i++ )
-      SAFE_DELETE( mParameterHandles[i] );
-
-   // Gather the shaders as they all need to be 
-   // passed to the ShaderMaterialParameterHandles.
-   Vector<GFXShader*> shaders;
-   shaders.setSize( mPasses.size() );
-   for ( U32 i = 0; i < mPasses.size(); i++ )
-      shaders[i] = _getRPD(i)->shader;
-
-   // Run through each shader and prepare its constants.
-   for ( U32 i = 0; i < mPasses.size(); i++ )
-   {
-      const Vector<GFXShaderConstDesc>& desc = shaders[i]->getShaderConstDesc();
-
-      Vector<GFXShaderConstDesc>::const_iterator p = desc.begin();
-      for ( ; p != desc.end(); p++ )
-      {
-         // Add this to our list of shader constants
-         GFXShaderConstDesc d(*p);
-         mShaderConstDesc.push_back(d);
-
-         ShaderMaterialParameterHandle* smph = new ShaderMaterialParameterHandle(d.name, shaders);
-         mParameterHandles.push_back(smph);
-      }
-   }
-}
-
-bool ProcessedShaderMaterial::_addPass( ShaderRenderPassData &rpd, 
-                                       U32 &texIndex, 
-                                       MaterialFeatureData &fd,
-                                       U32 stageNum,
-                                       const FeatureSet &features )
-{
-   // Set number of textures, stage, glow, etc.
-   rpd.mNumTex = texIndex;
-   rpd.mStageNum = stageNum;
-   rpd.mGlow |= mMaterial->mGlow[stageNum];
-
-   // Copy over features
-   rpd.mFeatureData.materialFeatures = fd.features;
-
-   // Generate shader
-   GFXShader::setLogging( true, true );
-   rpd.shader = SHADERGEN->getShader( rpd.mFeatureData, mVertexFormat, &mUserMacros );
-   if( !rpd.shader )
-      return false;
-   rpd.shaderHandles.init( rpd.shader );   
-
-   // If a pass glows, we glow
-   if( rpd.mGlow )
-      mHasGlow = true;
- 
-   ShaderRenderPassData *newPass = new ShaderRenderPassData( rpd );
-   mPasses.push_back( newPass );
-
-   // Give each active feature a chance to create specialized shader consts.
-   for( U32 i=0; i < FEATUREMGR->getFeatureCount(); i++ )
-   {
-      const FeatureInfo &info = FEATUREMGR->getAt( i );
-      if ( !fd.features.hasFeature( *info.type ) ) 
-         continue;
-
-      ShaderFeatureConstHandles *fh = info.feature->createConstHandles( rpd.shader, mUserObject );
-      if ( fh )
-         newPass->featureShaderHandles.push_back( fh );
-   }
-
-   rpd.reset();
-   texIndex = 0;
-   
-   return true;
-}
-
-void ProcessedShaderMaterial::_setPassBlendOp( ShaderFeature *sf,
-                                              ShaderRenderPassData &passData,
-                                              U32 &texIndex,
-                                              MaterialFeatureData &stageFeatures,
-                                              U32 stageNum,
-                                              const FeatureSet &features )
-{
-   if( sf->getBlendOp() == Material::None )
-   {
-      return;
-   }
-
-   // set up the current blend operation for multi-pass materials
-   if( mPasses.size() > 0)
-   {
-      // If passData.numTexReg is 0, this is a brand new pass, so set the
-      // blend operation to the first feature.
-      if( passData.mNumTexReg == 0 )
-      {
-         passData.mBlendOp = sf->getBlendOp();
-      }
-      else
-      {
-         // numTegReg is more than zero, if this feature
-         // doesn't have the same blend operation, then
-         // we need to create yet another pass 
-         if( sf->getBlendOp() != passData.mBlendOp && mPasses[mPasses.size()-1]->mStageNum == stageNum)
-         {
-            _addPass( passData, texIndex, stageFeatures, stageNum, features );
-            passData.mBlendOp = sf->getBlendOp();
-         }
-      }
-   }
-} 
-
-//
-// Runtime / rendering
-//
-bool ProcessedShaderMaterial::setupPass( SceneRenderState *state, const SceneData &sgData, U32 pass )
-{
-   PROFILE_SCOPE( ProcessedShaderMaterial_SetupPass );
-
-   // Make sure we have the pass
-   if(pass >= mPasses.size())
-   {
-      // If we were rendering instanced data tell
-      // the device to reset that vb stream.
-      if ( mInstancingState )
-         GFX->setVertexBuffer( NULL, 1 );
-
-      return false;
-   }
-
-   _setRenderState( state, sgData, pass );
-
-   // Set shaders
-   ShaderRenderPassData* rpd = _getRPD(pass);
-   if( rpd->shader )
-   {
-      GFX->setShader( rpd->shader );
-      GFX->setShaderConstBuffer(_getShaderConstBuffer(pass));      
-      _setShaderConstants(state, sgData, pass);      
-
-      // If we're instancing then do the initial step to get
-      // set the vb pointer to the const buffer.
-      if ( mInstancingState )
-         stepInstance();
-   }
-   else
-   {
-      GFX->disableShaders();
-      GFX->setShaderConstBuffer(NULL);
-   } 
-
-   // Set our textures
-   setTextureStages( state, sgData, pass );
-   _setTextureTransforms(pass);
-
-   return true;
-}
-
-void ProcessedShaderMaterial::setTextureStages( SceneRenderState *state, const SceneData &sgData, U32 pass )
-{
-   PROFILE_SCOPE( ProcessedShaderMaterial_SetTextureStages );
-
-   ShaderConstHandles *handles = _getShaderConstHandles(pass);
-
-   // Set all of the textures we need to render the give pass.
-#ifdef TORQUE_DEBUG
-   AssertFatal( pass<mPasses.size(), "Pass out of bounds" );
-#endif
-
-   RenderPassData *rpd = mPasses[pass];
-   GFXShaderConstBuffer* shaderConsts = _getShaderConstBuffer(pass);
-   NamedTexTarget *texTarget;
-   GFXTextureObject *texObject; 
-
-   for( U32 i=0; i<rpd->mNumTex; i++ )
-   {
-      U32 currTexFlag = rpd->mTexType[i];
-      if (!LIGHTMGR || !LIGHTMGR->setTextureStage(sgData, currTexFlag, i, shaderConsts, handles))
-      {
-         switch( currTexFlag )
-         {
-         // If the flag is unset then assume its just
-         // a regular texture to set... nothing special.
-         case 0:
-         default:
-            GFX->setTexture(i, rpd->mTexSlot[i].texObject);
-            break;
-
-         case Material::NormalizeCube:
-            GFX->setCubeTexture(i, Material::GetNormalizeCube());
-            break;
-
-         case Material::Lightmap:
-            GFX->setTexture( i, sgData.lightmap );
-            break;
-
-         case Material::ToneMapTex:
-            shaderConsts->setSafe(handles->mToneMapTexSC, (S32)i);
-            GFX->setTexture(i, rpd->mTexSlot[i].texObject);
-            break;
-
-         case Material::Cube:
-            GFX->setCubeTexture( i, rpd->mCubeMap );
-            break;
-
-         case Material::SGCube:
-            GFX->setCubeTexture( i, sgData.cubemap );
-            break;
-
-         case Material::BackBuff:
-            GFX->setTexture( i, sgData.backBuffTex );
-            break;
-            
-         case Material::TexTarget:
-            {
-               texTarget = rpd->mTexSlot[i].texTarget;
-               if ( !texTarget )
-               {
-                  GFX->setTexture( i, NULL );
-                  break;
-               }
-            
-               texObject = texTarget->getTexture();
-
-               // If no texture is available then map the default 2x2
-               // black texture to it.  This at least will ensure that
-               // we get consistant behavior across GPUs and platforms.
-               if ( !texObject )
-                  texObject = GFXTexHandle::ZERO;
-
-               if ( handles->mRTParamsSC[i]->isValid() && texObject )
-               {
-                  const Point3I &targetSz = texObject->getSize();
-                  const RectI &targetVp = texTarget->getViewport();
-                  Point4F rtParams;
-
-                  ScreenSpace::RenderTargetParameters(targetSz, targetVp, rtParams);
-
-                  shaderConsts->set(handles->mRTParamsSC[i], rtParams);
-               }
-
-               GFX->setTexture( i, texObject );
-               break;
-            }
-         }
-      }
-   }
-}
-
-void ProcessedShaderMaterial::_setTextureTransforms(const U32 pass)
-{
-   PROFILE_SCOPE( ProcessedShaderMaterial_SetTextureTransforms );
-
-   ShaderConstHandles* handles = _getShaderConstHandles(pass);
-   if (handles->mTexMatSC->isValid())
-   {   
-      MatrixF texMat( true );
-
-      mMaterial->updateTimeBasedParams();
-      F32 waveOffset = _getWaveOffset( pass ); // offset is between 0.0 and 1.0
-
-      // handle scroll anim type
-      if(  mMaterial->mAnimFlags[pass] & Material::Scroll )
-      {
-         if( mMaterial->mAnimFlags[pass] & Material::Wave )
-         {
-            Point3F scrollOffset;
-            scrollOffset.x = mMaterial->mScrollDir[pass].x * waveOffset;
-            scrollOffset.y = mMaterial->mScrollDir[pass].y * waveOffset;
-            scrollOffset.z = 1.0;
-
-            texMat.setColumn( 3, scrollOffset );
-         }
-         else
-         {
-            Point3F offset( mMaterial->mScrollOffset[pass].x, 
-               mMaterial->mScrollOffset[pass].y, 
-               1.0 );
-
-            texMat.setColumn( 3, offset );
-         }
-
-      }
-
-      // handle rotation
-      if( mMaterial->mAnimFlags[pass] & Material::Rotate )
-      {
-         if( mMaterial->mAnimFlags[pass] & Material::Wave )
-         {
-            F32 rotPos = waveOffset * M_2PI;
-            texMat.set( EulerF( 0.0, 0.0, rotPos ) );
-            texMat.setColumn( 3, Point3F( 0.5, 0.5, 0.0 ) );
-
-            MatrixF test( true );
-            test.setColumn( 3, Point3F( mMaterial->mRotPivotOffset[pass].x, 
-               mMaterial->mRotPivotOffset[pass].y,
-               0.0 ) );
-            texMat.mul( test );
-         }
-         else
-         {
-            texMat.set( EulerF( 0.0, 0.0, mMaterial->mRotPos[pass] ) );
-
-            texMat.setColumn( 3, Point3F( 0.5, 0.5, 0.0 ) );
-
-            MatrixF test( true );
-            test.setColumn( 3, Point3F( mMaterial->mRotPivotOffset[pass].x, 
-               mMaterial->mRotPivotOffset[pass].y,
-               0.0 ) );
-            texMat.mul( test );
-         }
-      }
-
-      // Handle scale + wave offset
-      if(  mMaterial->mAnimFlags[pass] & Material::Scale &&
-         mMaterial->mAnimFlags[pass] & Material::Wave )
-      {
-         F32 wOffset = fabs( waveOffset );
-
-         texMat.setColumn( 3, Point3F( 0.5, 0.5, 0.0 ) );
-
-         MatrixF temp( true );
-         temp.setRow( 0, Point3F( wOffset,  0.0,  0.0 ) );
-         temp.setRow( 1, Point3F( 0.0,  wOffset,  0.0 ) );
-         temp.setRow( 2, Point3F( 0.0,  0.0,  wOffset ) );
-         temp.setColumn( 3, Point3F( -wOffset * 0.5, -wOffset * 0.5, 0.0 ) );
-         texMat.mul( temp );
-      }
-
-      // handle sequence
-      if( mMaterial->mAnimFlags[pass] & Material::Sequence )
-      {
-         U32 frameNum = (U32)(MATMGR->getTotalTime() * mMaterial->mSeqFramePerSec[pass]);
-         F32 offset = frameNum * mMaterial->mSeqSegSize[pass];
-
-         if ( mMaterial->mAnimFlags[pass] & Material::Scale )
-            texMat.scale( Point3F( mMaterial->mSeqSegSize[pass], 1.0f, 1.0f ) );
-
-         Point3F texOffset = texMat.getPosition();
-         texOffset.x += offset;
-         texMat.setPosition( texOffset );
-      }
-
-      GFXShaderConstBuffer* shaderConsts = _getShaderConstBuffer(pass);
-      shaderConsts->setSafe(handles->mTexMatSC, texMat);
-   }
-}
-
-//--------------------------------------------------------------------------
-// Get wave offset for texture animations using a wave transform
-//--------------------------------------------------------------------------
-F32 ProcessedShaderMaterial::_getWaveOffset( U32 stage )
-{
-   switch( mMaterial->mWaveType[stage] )
-   {
-   case Material::Sin:
-      {
-         return mMaterial->mWaveAmp[stage] * mSin( M_2PI * mMaterial->mWavePos[stage] );
-         break;
-      }
-
-   case Material::Triangle:
-      {
-         F32 frac = mMaterial->mWavePos[stage] - mFloor( mMaterial->mWavePos[stage] );
-         if( frac > 0.0 && frac <= 0.25 )
-         {
-            return mMaterial->mWaveAmp[stage] * frac * 4.0;
-         }
-
-         if( frac > 0.25 && frac <= 0.5 )
-         {
-            return mMaterial->mWaveAmp[stage] * ( 1.0 - ((frac-0.25)*4.0) );
-         }
-
-         if( frac > 0.5 && frac <= 0.75 )
-         {
-            return mMaterial->mWaveAmp[stage] * (frac-0.5) * -4.0;
-         }
-
-         if( frac > 0.75 && frac <= 1.0 )
-         {
-            return -mMaterial->mWaveAmp[stage] * ( 1.0 - ((frac-0.75)*4.0) );
-         }
-
-         break;
-      }
-
-   case Material::Square:
-      {
-         F32 frac = mMaterial->mWavePos[stage] - mFloor( mMaterial->mWavePos[stage] );
-         if( frac > 0.0 && frac <= 0.5 )
-         {
-            return 0.0;
-         }
-         else
-         {
-            return mMaterial->mWaveAmp[stage];
-         }
-         break;
-      }
-
-   }
-
-   return 0.0;
-}
-
-void ProcessedShaderMaterial::_setShaderConstants(SceneRenderState * state, const SceneData &sgData, U32 pass)
-{
-   PROFILE_SCOPE( ProcessedShaderMaterial_SetShaderConstants );
-
-   GFXShaderConstBuffer* shaderConsts = _getShaderConstBuffer(pass);
-   ShaderConstHandles* handles = _getShaderConstHandles(pass);
-   U32 stageNum = getStageFromPass(pass);
-
-   // First we do all the constants which are not
-   // controlled via the material... we have to
-   // set these all the time as they could change.
-
-   if ( handles->mFogDataSC->isValid() )
-   {
-      Point3F fogData;
-      fogData.x = sgData.fogDensity;
-      fogData.y = sgData.fogDensityOffset;
-      fogData.z = sgData.fogHeightFalloff;     
-      shaderConsts->set( handles->mFogDataSC, fogData );
-   }
-
-   shaderConsts->setSafe(handles->mFogColorSC, sgData.fogColor);
-
-   if( handles->mOneOverFarplane->isValid() )
-   {
-      const F32 &invfp = 1.0f / state->getFarPlane();
-      Point4F oneOverFP(invfp, invfp, invfp, invfp);
-      shaderConsts->set( handles->mOneOverFarplane, oneOverFP );
-   }
-
-   shaderConsts->setSafe( handles->mAccumTimeSC, MATMGR->getTotalTime() );
-
-   // If the shader constants have not been lost then
-   // they contain the content from a previous render pass.
-   //
-   // In this case we can skip updating the material constants
-   // which do not change frame to frame.
-   //
-   // NOTE: This assumes we're not animating material parameters
-   // in a way that doesn't cause a shader reload... this isn't
-   // being done now, but it could change in the future.
-   // 
-   if ( !shaderConsts->wasLost() )
-      return;
-
-   shaderConsts->setSafe(handles->mSpecularColorSC, mMaterial->mSpecular[stageNum]);   
-   shaderConsts->setSafe(handles->mSpecularPowerSC, mMaterial->mSpecularPower[stageNum]);
-   shaderConsts->setSafe(handles->mSpecularStrengthSC, mMaterial->mSpecularStrength[stageNum]);
-
-   shaderConsts->setSafe(handles->mParallaxInfoSC, mMaterial->mParallaxScale[stageNum]);   
-   shaderConsts->setSafe(handles->mMinnaertConstantSC, mMaterial->mMinnaertConstant[stageNum]);
-
-   if ( handles->mSubSurfaceParamsSC->isValid() )
-   {
-      Point4F subSurfParams;
-      dMemcpy( &subSurfParams, &mMaterial->mSubSurfaceColor[stageNum], sizeof(ColorF) );
-      subSurfParams.w = mMaterial->mSubSurfaceRolloff[stageNum];
-      shaderConsts->set(handles->mSubSurfaceParamsSC, subSurfParams);
-   }
-
-   if ( handles->mRTSizeSC->isValid() )
-   {
-      const Point2I &resolution = GFX->getActiveRenderTarget()->getSize();
-      Point2F pixelShaderConstantData;
-
-      pixelShaderConstantData.x = resolution.x;
-      pixelShaderConstantData.y = resolution.y;
-
-      shaderConsts->set( handles->mRTSizeSC, pixelShaderConstantData );
-   }
-
-   if ( handles->mOneOverRTSizeSC->isValid() )
-   {
-      const Point2I &resolution = GFX->getActiveRenderTarget()->getSize();
-      Point2F oneOverTargetSize( 1.0f / (F32)resolution.x, 1.0f / (F32)resolution.y );
-
-      shaderConsts->set( handles->mOneOverRTSizeSC, oneOverTargetSize );
-   }
-
-   // set detail scale
-   shaderConsts->setSafe(handles->mDetailScaleSC, mMaterial->mDetailScale[stageNum]);
-   shaderConsts->setSafe(handles->mDetailBumpStrength, mMaterial->mDetailNormalMapStrength[stageNum]);
-
-   // MFT_ImposterVert
-   if ( handles->mImposterUVs->isValid() )
-   {
-      U32 uvCount = getMin( mMaterial->mImposterUVs.size(), 64 ); // See imposter.hlsl   
-      AlignedArray<Point4F> imposterUVs( uvCount, sizeof( Point4F ), (U8*)mMaterial->mImposterUVs.address(), false );
-      shaderConsts->set( handles->mImposterUVs, imposterUVs );
-   }
-   shaderConsts->setSafe( handles->mImposterLimits, mMaterial->mImposterLimits );
-
-   // Diffuse
-   shaderConsts->setSafe(handles->mDiffuseColorSC, mMaterial->mDiffuse[stageNum]);
-
-   shaderConsts->setSafe( handles->mAlphaTestValueSC, mClampF( (F32)mMaterial->mAlphaRef / 255.0f, 0.0f, 1.0f ) );      
-
-   if(handles->mDiffuseAtlasParamsSC)
-   {
-      Point4F atlasParams(1.0f / mMaterial->mCellLayout[stageNum].x, // 1 / num_horizontal
-         1.0f / mMaterial->mCellLayout[stageNum].y, // 1 / num_vertical
-         mMaterial->mCellSize[stageNum],            // tile size in pixels
-         getBinLog2(mMaterial->mCellSize[stageNum]) );    // pow of 2 of tile size in pixels 2^9 = 512, 2^10=1024 etc
-      shaderConsts->setSafe(handles->mDiffuseAtlasParamsSC, atlasParams);
-   }
-
-   if(handles->mBumpAtlasParamsSC)
-   {
-      Point4F atlasParams(1.0f / mMaterial->mCellLayout[stageNum].x, // 1 / num_horizontal
-         1.0f / mMaterial->mCellLayout[stageNum].y, // 1 / num_vertical
-         mMaterial->mCellSize[stageNum],            // tile size in pixels
-         getBinLog2(mMaterial->mCellSize[stageNum]) );    // pow of 2 of tile size in pixels 2^9 = 512, 2^10=1024 etc
-      shaderConsts->setSafe(handles->mBumpAtlasParamsSC, atlasParams);
-   }
-
-   if(handles->mDiffuseAtlasTileSC)
-   {
-      // Sanity check the wrap flags
-      //AssertWarn(mMaterial->mTextureAddressModeU == mMaterial->mTextureAddressModeV, "Addresing mode mismatch, texture atlasing will be confused");
-      Point4F atlasTileParams( mMaterial->mCellIndex[stageNum].x, // Tile co-ordinate, ie: [0, 3]
-         mMaterial->mCellIndex[stageNum].y, 
-         0.0f, 0.0f ); // TODO: Wrap mode flags?
-      shaderConsts->setSafe(handles->mDiffuseAtlasTileSC, atlasTileParams);
-   }
-
-   if(handles->mBumpAtlasTileSC)
-   {
-      // Sanity check the wrap flags
-      //AssertWarn(mMaterial->mTextureAddressModeU == mMaterial->mTextureAddressModeV, "Addresing mode mismatch, texture atlasing will be confused");
-      Point4F atlasTileParams( mMaterial->mCellIndex[stageNum].x, // Tile co-ordinate, ie: [0, 3]
-         mMaterial->mCellIndex[stageNum].y, 
-         0.0f, 0.0f ); // TODO: Wrap mode flags?
-      shaderConsts->setSafe(handles->mBumpAtlasTileSC, atlasTileParams);
-   }
-   
-   if( handles->mAccuScaleSC->isValid() )
-      shaderConsts->set( handles->mAccuScaleSC, mMaterial->mAccuScale[stageNum] );
-   if( handles->mAccuDirectionSC->isValid() )
-      shaderConsts->set( handles->mAccuDirectionSC, mMaterial->mAccuDirection[stageNum] );
-   if( handles->mAccuStrengthSC->isValid() )
-      shaderConsts->set( handles->mAccuStrengthSC, mMaterial->mAccuStrength[stageNum] );
-   if( handles->mAccuCoverageSC->isValid() )
-      shaderConsts->set( handles->mAccuCoverageSC, mMaterial->mAccuCoverage[stageNum] );
-   if( handles->mAccuSpecularSC->isValid() )
-      shaderConsts->set( handles->mAccuSpecularSC, mMaterial->mAccuSpecular[stageNum] );
-}
-
-bool ProcessedShaderMaterial::_hasCubemap(U32 pass)
-{
-   // Only support cubemap on the first stage
-   if( mPasses[pass]->mStageNum > 0 )
-      return false;
-
-   if( mPasses[pass]->mCubeMap )
-      return true;
-
-   return false;
-}
-
-void ProcessedShaderMaterial::setTransforms(const MatrixSet &matrixSet, SceneRenderState *state, const U32 pass)
-{
-   PROFILE_SCOPE( ProcessedShaderMaterial_setTransforms );
-
-   GFXShaderConstBuffer* shaderConsts = _getShaderConstBuffer(pass);
-   ShaderConstHandles* handles = _getShaderConstHandles(pass);
-
-   // The MatrixSet will lazily generate a matrix under the
-   // various 'get' methods, so inline the test for a valid
-   // shader constant handle to avoid that work when we can.
-   if ( handles->mModelViewProjSC->isValid() )
-      shaderConsts->set( handles->mModelViewProjSC, matrixSet.getWorldViewProjection() );
-   if ( handles->mObjTransSC->isValid() )
-      shaderConsts->set( handles->mObjTransSC, matrixSet.getObjectToWorld() );      
-   if ( handles->mWorldToObjSC->isValid() )
-      shaderConsts->set( handles->mWorldToObjSC, matrixSet.getWorldToObject() );
-   if ( handles->mWorldToCameraSC->isValid() )
-      shaderConsts->set( handles->mWorldToCameraSC, matrixSet.getWorldToCamera() );
-   if ( handles->mWorldViewOnlySC->isValid() )
-      shaderConsts->set( handles->mWorldViewOnlySC, matrixSet.getObjectToCamera() );
-   if ( handles->mViewToObjSC->isValid() )
-      shaderConsts->set( handles->mViewToObjSC, matrixSet.getCameraToObject() );
-   if ( handles->mViewProjSC->isValid() )
-      shaderConsts->set( handles->mViewProjSC, matrixSet.getWorldToScreen() );
-
-   if (  handles->mCubeTransSC->isValid() &&
-         ( _hasCubemap(pass) || mMaterial->mDynamicCubemap ) )
-   {
-      // TODO: Could we not remove this constant?  Use mObjTransSC and cast to float3x3 instead?
-      shaderConsts->set(handles->mCubeTransSC, matrixSet.getObjectToWorld(), GFXSCT_Float3x3);
-   }
-
-   if ( handles->m_vEyeSC->isValid() )
-      shaderConsts->set( handles->m_vEyeSC, state->getVectorEye() );
-}
-
-void ProcessedShaderMaterial::setSceneInfo(SceneRenderState * state, const SceneData& sgData, U32 pass)
-{
-   PROFILE_SCOPE( ProcessedShaderMaterial_setSceneInfo );
-
-   GFXShaderConstBuffer* shaderConsts = _getShaderConstBuffer(pass);
-   ShaderConstHandles* handles = _getShaderConstHandles(pass);
-
-   // Set cubemap stuff here (it's convenient!)
-   const Point3F &eyePosWorld = state->getCameraPosition();
-   if ( handles->mCubeEyePosSC->isValid() )
-   {
-      if(_hasCubemap(pass) || mMaterial->mDynamicCubemap)
-      {
-         Point3F cubeEyePos = eyePosWorld - sgData.objTrans->getPosition();
-         shaderConsts->set(handles->mCubeEyePosSC, cubeEyePos);      
-      }
-   }
-
-   shaderConsts->setSafe(handles->mVisiblitySC, sgData.visibility);
-
-   shaderConsts->setSafe(handles->mEyePosWorldSC, eyePosWorld);   
-
-   if ( handles->mEyePosSC->isValid() )
-   {
-      MatrixF tempMat( *sgData.objTrans );
-      tempMat.inverse();
-      Point3F eyepos;
-      tempMat.mulP( eyePosWorld, &eyepos );
-      shaderConsts->set(handles->mEyePosSC, eyepos);   
-   }
-
-   shaderConsts->setSafe(handles->mEyeMatSC, state->getCameraTransform());   
-
-   ShaderRenderPassData *rpd = _getRPD( pass );
-   for ( U32 i=0; i < rpd->featureShaderHandles.size(); i++ )
-      rpd->featureShaderHandles[i]->setConsts( state, sgData, shaderConsts );
-
-   LIGHTMGR->setLightInfo( this, mMaterial, sgData, state, pass, shaderConsts );
-}
-
-void ProcessedShaderMaterial::setBuffers( GFXVertexBufferHandleBase *vertBuffer, GFXPrimitiveBufferHandle *primBuffer )
-{
-   PROFILE_SCOPE(ProcessedShaderMaterial_setBuffers);
-
-   // If we're not instanced then just call the parent.
-   if ( !mInstancingState )
-   {
-      Parent::setBuffers( vertBuffer, primBuffer );
-      return;
-   }
-
-   PROFILE_SCOPE(ProcessedShaderMaterial_setBuffers_instancing);
-
-   const S32 instCount = mInstancingState->getCount();
-   AssertFatal( instCount > 0,
-      "ProcessedShaderMaterial::setBuffers - No instances rendered!" );
-
-   // Nothing special here.
-   GFX->setPrimitiveBuffer( *primBuffer );
-
-   // Set the first stream the the normal VB and set the
-   // correct frequency for the number of instances to render.
-   GFX->setVertexBuffer( *vertBuffer, 0, instCount );
-
-   // Get a volatile VB and fill it with the vertex data.
-   const GFXVertexFormat *instFormat = mInstancingState->getFormat();
-   GFXVertexBufferDataHandle instVB;
-   instVB.set( GFX, instFormat->getSizeInBytes(), instFormat, instCount, GFXBufferTypeVolatile );
-   U8 *dest = instVB.lock();
-   if(!dest) return;
-   dMemcpy( dest, mInstancingState->getBuffer(), instFormat->getSizeInBytes() * instCount );
-   instVB.unlock();
-
-   // Set the instance vb for streaming.
-   GFX->setVertexBuffer( instVB, 1, 1 );
-
-   // Finally set the vertex format which defines
-   // both of the streams.
-   GFX->setVertexFormat( mInstancingState->getDeclFormat() );
-
-   // Done... reset the count.
-   mInstancingState->resetStep();
-}
-
-bool ProcessedShaderMaterial::stepInstance()
-{
-   PROFILE_SCOPE(ProcessedShaderMaterial_stepInstance);
-   AssertFatal( mInstancingState, "ProcessedShaderMaterial::stepInstance - This material isn't instanced!" );  
-   return mInstancingState->step( &_getShaderConstBuffer( 0 )->mInstPtr );
-}
-
-MaterialParameters* ProcessedShaderMaterial::allocMaterialParameters()
-{
-   ShaderMaterialParameters* smp = new ShaderMaterialParameters();
-   Vector<GFXShaderConstBufferRef> buffers( __FILE__, __LINE__ );
-   buffers.setSize(mPasses.size());
-   for (U32 i = 0; i < mPasses.size(); i++)
-      buffers[i] = _getRPD(i)->shader->allocConstBuffer();
-   // smp now owns these buffers.
-   smp->setBuffers(mShaderConstDesc, buffers);
-   return smp;   
-}
-
-MaterialParameterHandle* ProcessedShaderMaterial::getMaterialParameterHandle(const String& name)
-{
-   // Search our list
-   for (U32 i = 0; i < mParameterHandles.size(); i++)
-   {
-      if (mParameterHandles[i]->getName().equal(name))
-         return mParameterHandles[i];
-   }
-   
-   // If we didn't find it, we have to add it to support shader reloading.
-
-   Vector<GFXShader*> shaders;
-   shaders.setSize(mPasses.size());
-   for (U32 i = 0; i < mPasses.size(); i++)
-      shaders[i] = _getRPD(i)->shader;
-
-   ShaderMaterialParameterHandle* smph = new ShaderMaterialParameterHandle( name, shaders );
-   mParameterHandles.push_back(smph);
-
-   return smph;
-}
-
-/// This is here to deal with the differences between ProcessedCustomMaterials and ProcessedShaderMaterials.
-GFXShaderConstBuffer* ProcessedShaderMaterial::_getShaderConstBuffer( const U32 pass )
-{   
-   if (mCurrentParams && pass < mPasses.size())
-   {
-      return static_cast<ShaderMaterialParameters*>(mCurrentParams)->getBuffer(pass);
-   }
-   return NULL;
-}
-
-ShaderConstHandles* ProcessedShaderMaterial::_getShaderConstHandles(const U32 pass)
-{
-   if (pass < mPasses.size())
-   {
-      return &_getRPD(pass)->shaderHandles;
-   }
-   return NULL;
-}
-
-void ProcessedShaderMaterial::dumpMaterialInfo()
-{
-   for ( U32 i = 0; i < getNumPasses(); i++ )
-   {
-      const ShaderRenderPassData *passData = _getRPD( i );
-
-      if ( passData == NULL )
-         continue;
-
-      const GFXShader      *shader = passData->shader;
-
-      if ( shader == NULL )
-         Con::printf( "  [%i] [NULL shader]", i );
-      else
-         Con::printf( "  [%i] %s", i, shader->describeSelf().c_str() );
-   }
-}
+//-----------------------------------------------------------------------------
+// Copyright (c) 2012 GarageGames, LLC
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to
+// deal in the Software without restriction, including without limitation the
+// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+// sell copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+// IN THE SOFTWARE.
+//-----------------------------------------------------------------------------
+
+#include "platform/platform.h"
+#include "materials/processedShaderMaterial.h"
+
+#include "core/util/safeDelete.h"
+#include "gfx/sim/cubemapData.h"
+#include "gfx/gfxShader.h"
+#include "gfx/genericConstBuffer.h"
+#include "gfx/gfxPrimitiveBuffer.h"
+#include "scene/sceneRenderState.h"
+#include "shaderGen/shaderFeature.h"
+#include "shaderGen/shaderGenVars.h"
+#include "shaderGen/featureMgr.h"
+#include "shaderGen/shaderGen.h"
+#include "materials/sceneData.h"
+#include "materials/materialFeatureTypes.h"
+#include "materials/materialManager.h"
+#include "materials/shaderMaterialParameters.h"
+#include "materials/matTextureTarget.h"
+#include "gfx/util/screenspace.h"
+#include "math/util/matrixSet.h"
+
+// We need to include customMaterialDefinition for ShaderConstHandles::init
+#include "materials/customMaterialDefinition.h"
+
+///
+/// ShaderConstHandles
+///
+void ShaderConstHandles::init( GFXShader *shader, CustomMaterial* mat /*=NULL*/ )
+{
+   mDiffuseColorSC = shader->getShaderConstHandle("$diffuseMaterialColor");
+   mTexMatSC = shader->getShaderConstHandle(ShaderGenVars::texMat);
+   mToneMapTexSC = shader->getShaderConstHandle(ShaderGenVars::toneMap);
+   mSpecularColorSC = shader->getShaderConstHandle(ShaderGenVars::specularColor);
+   mSpecularPowerSC = shader->getShaderConstHandle(ShaderGenVars::specularPower);
+   mSpecularStrengthSC = shader->getShaderConstHandle(ShaderGenVars::specularStrength);
+   mParallaxInfoSC = shader->getShaderConstHandle("$parallaxInfo");
+   mFogDataSC = shader->getShaderConstHandle(ShaderGenVars::fogData);
+   mFogColorSC = shader->getShaderConstHandle(ShaderGenVars::fogColor);
+   mDetailScaleSC = shader->getShaderConstHandle(ShaderGenVars::detailScale);
+   mVisiblitySC = shader->getShaderConstHandle(ShaderGenVars::visibility);
+   mColorMultiplySC = shader->getShaderConstHandle(ShaderGenVars::colorMultiply);
+   mAlphaTestValueSC = shader->getShaderConstHandle(ShaderGenVars::alphaTestValue);
+   mModelViewProjSC = shader->getShaderConstHandle(ShaderGenVars::modelview);
+   mWorldViewOnlySC = shader->getShaderConstHandle(ShaderGenVars::worldViewOnly);
+   mWorldToCameraSC = shader->getShaderConstHandle(ShaderGenVars::worldToCamera);
+   mWorldToObjSC = shader->getShaderConstHandle(ShaderGenVars::worldToObj);
+   mViewToObjSC = shader->getShaderConstHandle(ShaderGenVars::viewToObj);
+   mCubeTransSC = shader->getShaderConstHandle(ShaderGenVars::cubeTrans);
+   mObjTransSC = shader->getShaderConstHandle(ShaderGenVars::objTrans);
+   mCubeEyePosSC = shader->getShaderConstHandle(ShaderGenVars::cubeEyePos);
+   mEyePosSC = shader->getShaderConstHandle(ShaderGenVars::eyePos);
+   mEyePosWorldSC = shader->getShaderConstHandle(ShaderGenVars::eyePosWorld);
+   m_vEyeSC = shader->getShaderConstHandle(ShaderGenVars::vEye);
+   mEyeMatSC = shader->getShaderConstHandle(ShaderGenVars::eyeMat);
+   mOneOverFarplane = shader->getShaderConstHandle(ShaderGenVars::oneOverFarplane);
+   mAccumTimeSC = shader->getShaderConstHandle(ShaderGenVars::accumTime);
+   mMinnaertConstantSC = shader->getShaderConstHandle(ShaderGenVars::minnaertConstant);
+   mSubSurfaceParamsSC = shader->getShaderConstHandle(ShaderGenVars::subSurfaceParams);
+   mDiffuseAtlasParamsSC = shader->getShaderConstHandle(ShaderGenVars::diffuseAtlasParams);
+   mDiffuseAtlasTileSC = shader->getShaderConstHandle(ShaderGenVars::diffuseAtlasTileParams);
+   mBumpAtlasParamsSC = shader->getShaderConstHandle(ShaderGenVars::bumpAtlasParams);
+   mBumpAtlasTileSC = shader->getShaderConstHandle(ShaderGenVars::bumpAtlasTileParams);
+   mRTSizeSC = shader->getShaderConstHandle( "$targetSize" );
+   mOneOverRTSizeSC = shader->getShaderConstHandle( "$oneOverTargetSize" );
+   mDetailBumpStrength = shader->getShaderConstHandle( "$detailBumpStrength" );
+   mViewProjSC = shader->getShaderConstHandle( "$viewProj" );
+
+   // MFT_ImposterVert
+   mImposterUVs = shader->getShaderConstHandle( "$imposterUVs" );
+   mImposterLimits = shader->getShaderConstHandle( "$imposterLimits" );
+
+   for (S32 i = 0; i < TEXTURE_STAGE_COUNT; ++i)
+      mRTParamsSC[i] = shader->getShaderConstHandle( String::ToString( "$rtParams%d", i ) );
+
+   // Clear any existing texture handles.
+   dMemset( mTexHandlesSC, 0, sizeof( mTexHandlesSC ) );
+   if(mat)
+   {
+      for (S32 i = 0; i < Material::MAX_TEX_PER_PASS; ++i)
+         mTexHandlesSC[i] = shader->getShaderConstHandle(mat->mSamplerNames[i]);
+   }
+}
+
+///
+/// ShaderRenderPassData
+///
+void ShaderRenderPassData::reset()
+{
+   Parent::reset();
+
+   shader = NULL;
+
+   for ( U32 i=0; i < featureShaderHandles.size(); i++ )
+      delete featureShaderHandles[i];
+
+   featureShaderHandles.clear();
+}
+
+String ShaderRenderPassData::describeSelf() const
+{
+   // First write the shader identification.
+   String desc = String::ToString( "%s\n", shader->describeSelf().c_str() );
+
+   // Let the parent get the rest.
+   desc += Parent::describeSelf();
+
+   return desc;
+}
+
+///
+/// ProcessedShaderMaterial
+///
+ProcessedShaderMaterial::ProcessedShaderMaterial()
+   :  mDefaultParameters( NULL ),
+      mInstancingState( NULL )
+{
+   VECTOR_SET_ASSOCIATION( mShaderConstDesc );
+   VECTOR_SET_ASSOCIATION( mParameterHandles );
+}
+
+ProcessedShaderMaterial::ProcessedShaderMaterial(Material &mat)
+   :  mDefaultParameters( NULL ),
+      mInstancingState( NULL )
+{
+   VECTOR_SET_ASSOCIATION( mShaderConstDesc );
+   VECTOR_SET_ASSOCIATION( mParameterHandles );
+   mMaterial = &mat;
+}
+
+ProcessedShaderMaterial::~ProcessedShaderMaterial()
+{
+   SAFE_DELETE(mInstancingState);
+   SAFE_DELETE(mDefaultParameters);
+   for (U32 i = 0; i < mParameterHandles.size(); i++)
+      SAFE_DELETE(mParameterHandles[i]);
+}
+
+//
+// Material init
+//
+bool ProcessedShaderMaterial::init( const FeatureSet &features, 
+                                    const GFXVertexFormat *vertexFormat,
+                                    const MatFeaturesDelegate &featuresDelegate )
+{
+   // Load our textures
+   _setStageData();
+
+   // Determine how many stages we use
+   mMaxStages = getNumStages(); 
+   mVertexFormat = vertexFormat;
+   mFeatures.clear();
+   mStateHint.clear();
+   SAFE_DELETE(mInstancingState);
+
+   for( U32 i=0; i<mMaxStages; i++ )
+   {
+      MaterialFeatureData fd;
+
+      // Determine the features of this stage
+      _determineFeatures( i, fd, features );
+   
+      // Let the delegate poke at the features.
+      if ( featuresDelegate )
+         featuresDelegate( this, i, fd, features );
+
+      // Create the passes for this stage
+      if ( fd.features.isNotEmpty() )
+         if( !_createPasses( fd, i, features ) )
+            return false;
+   }
+
+   _initRenderPassDataStateBlocks();
+   _initMaterialParameters();
+   mDefaultParameters =  allocMaterialParameters();
+   setMaterialParameters( mDefaultParameters, 0 );
+   mStateHint.init( this );   
+
+   // Enable instancing if we have it.
+   if ( mFeatures.hasFeature( MFT_UseInstancing ) )
+   {
+      mInstancingState = new InstancingState();
+      mInstancingState->setFormat( &_getRPD( 0 )->shader->mInstancingFormat, mVertexFormat );
+   }
+
+   // Check for a RenderTexTargetBin assignment
+   // *IMPORTANT NOTE* 
+   // This is a temporary solution for getting diffuse mapping working with tex targets for standard materials
+   // It should be removed once this is done properly, at that time the sAllowTextureTargetAssignment should also be removed 
+   // from Material (it is necessary for catching shadow maps/post effect this shouldn't be applied to)
+   if (Material::sAllowTextureTargetAssignment)
+      if (mMaterial && mMaterial->mDiffuseMapFilename[0].isNotEmpty() && mMaterial->mDiffuseMapFilename[0].substr( 0, 1 ).equal("#"))
+      {
+         String texTargetBufferName = mMaterial->mDiffuseMapFilename[0].substr(1, mMaterial->mDiffuseMapFilename[0].length() - 1);
+         NamedTexTarget *texTarget = NamedTexTarget::find( texTargetBufferName ); 
+
+         RenderPassData* rpd = getPass(0);      
+
+         if (rpd)
+         {
+            rpd->mTexSlot[0].texTarget = texTarget;
+            rpd->mTexType[0] = Material::TexTarget;
+         }
+      }
+
+   return true;
+}
+
+U32 ProcessedShaderMaterial::getNumStages()
+{
+   // Loops through all stages to determine how many 
+   // stages we actually use.  
+   // 
+   // The first stage is always active else we shouldn't be
+   // creating the material to begin with.
+   U32 numStages = 1;
+
+   U32 i;
+   for( i=1; i<Material::MAX_STAGES; i++ )
+   {
+      // Assume stage is inactive
+      bool stageActive = false;
+
+      // Cubemaps only on first stage
+      if( i == 0 )
+      {
+         // If we have a cubemap the stage is active
+         if( mMaterial->mCubemapData || mMaterial->mDynamicCubemap )
+         {
+            numStages++;
+            continue;
+         }
+      }
+
+      // If we have a texture for the a feature the 
+      // stage is active.
+      if ( mStages[i].hasValidTex() )
+         stageActive = true;
+
+      // If this stage has specular lighting, it's active
+      if ( mMaterial->mPixelSpecular[i] )
+         stageActive = true;
+
+      // If this stage has diffuse color, it's active
+      if (  mMaterial->mDiffuse[i].alpha > 0 &&
+            mMaterial->mDiffuse[i] != ColorF::WHITE )
+         stageActive = true;
+
+      // If we have a Material that is vertex lit
+      // then it may not have a texture
+      if( mMaterial->mVertLit[i] )
+         stageActive = true;
+
+      // Increment the number of active stages
+      numStages += stageActive;
+   }
+
+   return numStages;
+}
+
+void ProcessedShaderMaterial::_determineFeatures(  U32 stageNum, 
+                                                   MaterialFeatureData &fd, 
+                                                   const FeatureSet &features )
+{
+   PROFILE_SCOPE( ProcessedShaderMaterial_DetermineFeatures );
+
+   const F32 shaderVersion = GFX->getPixelShaderVersion();
+   AssertFatal(shaderVersion > 0.0 , "Cannot create a shader material if we don't support shaders");
+
+   bool lastStage = stageNum == (mMaxStages-1);
+
+   // First we add all the features which the 
+   // material has defined.
+
+   if ( mMaterial->isTranslucent() )
+   {
+      // Note: This is for decal blending into the prepass
+      // for AL... it probably needs to be made clearer.
+      if (  mMaterial->mTranslucentBlendOp == Material::LerpAlpha &&
+            mMaterial->mTranslucentZWrite )
+         fd.features.addFeature( MFT_IsTranslucentZWrite );
+      else
+      {
+         fd.features.addFeature( MFT_IsTranslucent );
+         fd.features.addFeature( MFT_ForwardShading );
+      }
+   }
+
+   // TODO: This sort of sucks... BL should somehow force this
+   // feature on from the outside and not this way.
+   if ( dStrcmp( LIGHTMGR->getId(), "BLM" ) == 0 )
+      fd.features.addFeature( MFT_ForwardShading );
+
+   // Disabling the InterlacedPrePass feature for now. It is not ready for prime-time
+   // and it should not be triggered off of the DoubleSided parameter. [2/5/2010 Pat]
+   /*if ( mMaterial->isDoubleSided() )
+   {
+      fd.features.addFeature( MFT_InterlacedPrePass );
+   }*/
+
+   // Allow instancing if it was requested and the card supports
+   // SM 3.0 or above.
+   //
+   // We also disable instancing for non-single pass materials
+   // and glowing materials because its untested/unimplemented.
+   //
+   if (  features.hasFeature( MFT_UseInstancing ) &&
+         mMaxStages == 1 &&
+         !mMaterial->mGlow[0] &&
+         shaderVersion >= 3.0f )
+      fd.features.addFeature( MFT_UseInstancing );
+
+   if ( mMaterial->mAlphaTest )
+      fd.features.addFeature( MFT_AlphaTest );
+
+   if ( mMaterial->mEmissive[stageNum] )
+      fd.features.addFeature( MFT_IsEmissive );
+   else
+      fd.features.addFeature( MFT_RTLighting );
+
+   if ( mMaterial->mAnimFlags[stageNum] )
+      fd.features.addFeature( MFT_TexAnim );  
+
+   if ( mMaterial->mVertLit[stageNum] )
+      fd.features.addFeature( MFT_VertLit );
+   
+   // cubemaps only available on stage 0 for now - bramage   
+   if ( stageNum < 1 && 
+         (  (  mMaterial->mCubemapData && mMaterial->mCubemapData->mCubemap ) ||
+               mMaterial->mDynamicCubemap ) )
+   fd.features.addFeature( MFT_CubeMap );
+
+   fd.features.addFeature( MFT_Visibility );
+
+   if (  lastStage && 
+         (  !gClientSceneGraph->usePostEffectFog() ||
+            fd.features.hasFeature( MFT_IsTranslucent ) ||
+            fd.features.hasFeature( MFT_ForwardShading )) )
+      fd.features.addFeature( MFT_Fog );
+
+   if ( mMaterial->mMinnaertConstant[stageNum] > 0.0f )
+      fd.features.addFeature( MFT_MinnaertShading );
+
+   if ( mMaterial->mSubSurface[stageNum] )
+      fd.features.addFeature( MFT_SubSurface );
+
+   if ( !mMaterial->mCellLayout[stageNum].isZero() )
+   {
+      fd.features.addFeature( MFT_DiffuseMapAtlas );
+
+      if ( mMaterial->mNormalMapAtlas )
+         fd.features.addFeature( MFT_NormalMapAtlas );
+   }
+
+   // Grab other features like normal maps, base texture, etc.
+   FeatureSet mergeFeatures;
+   mStages[stageNum].getFeatureSet( &mergeFeatures );
+   fd.features.merge( mergeFeatures );
+   
+   if ( fd.features[ MFT_NormalMap ] )   
+   {   
+      if (  mStages[stageNum].getTex( MFT_NormalMap )->mFormat == GFXFormatDXT5 &&   
+           !mStages[stageNum].getTex( MFT_NormalMap )->mHasTransparency )   
+         fd.features.addFeature( MFT_IsDXTnm );   
+   }
+
+   // Now for some more advanced features that we 
+   // cannot do on SM 2.0 and below.
+   if ( shaderVersion > 2.0f )
+   {
+      // Only allow parallax if we have a normal map and
+      // we're not using DXTnm compression.
+      if (  mMaterial->mParallaxScale[stageNum] > 0.0f &&
+         fd.features[ MFT_NormalMap ] &&
+         !fd.features[ MFT_IsDXTnm ] )
+         fd.features.addFeature( MFT_Parallax );
+
+      // If not parallax then allow per-pixel specular if
+      // we have real time lighting enabled.
+      else if (   fd.features[MFT_RTLighting] && 
+                  mMaterial->mPixelSpecular[stageNum] )
+         fd.features.addFeature( MFT_PixSpecular );
+   }
+
+   // Without realtime lighting and on lower end 
+   // shader models disable the specular map.
+   if (  !fd.features[ MFT_RTLighting ] || shaderVersion == 2.0 )
+      fd.features.removeFeature( MFT_SpecularMap );
+
+   // If we have a specular map then make sure we
+   // have per-pixel specular enabled.
+   if( fd.features[ MFT_SpecularMap ] )
+   {
+      fd.features.addFeature( MFT_PixSpecular );
+
+      // Check for an alpha channel on the specular map. If it has one (and it
+      // has values less than 255) than the artist has put the gloss map into
+      // the alpha channel.
+      if( mStages[stageNum].getTex( MFT_SpecularMap )->mHasTransparency )
+         fd.features.addFeature( MFT_GlossMap );
+   }
+
+   // Without a base texture use the diffuse color
+   // feature to ensure some sort of output.
+   if (!fd.features[MFT_DiffuseMap])
+   {
+      fd.features.addFeature( MFT_DiffuseColor );
+
+      // No texture coords... no overlay.
+      fd.features.removeFeature( MFT_OverlayMap );
+   }
+
+   // If we have a diffuse map and the alpha on the diffuse isn't
+   // zero and the color isn't pure white then multiply the color.
+   else if (   mMaterial->mDiffuse[stageNum].alpha > 0.0f && 
+               mMaterial->mDiffuse[stageNum] != ColorF::WHITE )
+      fd.features.addFeature( MFT_DiffuseColor );
+
+   // If lightmaps or tonemaps are enabled or we 
+   // don't have a second UV set then we cannot 
+   // use the overlay texture.
+   if (  fd.features[MFT_LightMap] || 
+         fd.features[MFT_ToneMap] || 
+         mVertexFormat->getTexCoordCount() < 2 )
+      fd.features.removeFeature( MFT_OverlayMap );
+
+   // If tonemaps are enabled don't use lightmap
+   if ( fd.features[MFT_ToneMap] || mVertexFormat->getTexCoordCount() < 2 )
+      fd.features.removeFeature( MFT_LightMap );
+
+   // Don't allow tonemaps if we don't have a second UV set
+   if ( mVertexFormat->getTexCoordCount() < 2 )
+      fd.features.removeFeature( MFT_ToneMap );
+
+   // Always add the HDR output feature.  
+   //
+   // It will be filtered out if it was disabled 
+   // for this material creation below.
+   //
+   // Also the shader code will evaluate to a nop
+   // if HDR is not enabled in the scene.
+   //
+   fd.features.addFeature( MFT_HDROut );
+
+   // If vertex color is enabled on the material's stage and
+   // color is present in vertex format, add diffuse vertex
+   // color feature.
+   
+   if (  mMaterial->mVertColor[ stageNum ] &&
+         mVertexFormat->hasColor() )
+      fd.features.addFeature( MFT_DiffuseVertColor );
+
+   // Allow features to add themselves.
+   for ( U32 i = 0; i < FEATUREMGR->getFeatureCount(); i++ )
+   {
+      const FeatureInfo &info = FEATUREMGR->getAt( i );
+      info.feature->determineFeature(  mMaterial, 
+                                       mVertexFormat, 
+                                       stageNum, 
+                                       *info.type, 
+                                       features, 
+                                       &fd );
+   }
+
+   // Now disable any features that were 
+   // not part of the input feature handle.
+   fd.features.filter( features );
+}
+
+bool ProcessedShaderMaterial::_createPasses( MaterialFeatureData &stageFeatures, U32 stageNum, const FeatureSet &features )
+{
+   // Creates passes for the given stage
+   ShaderRenderPassData passData;
+   U32 texIndex = 0;
+
+   for( U32 i=0; i < FEATUREMGR->getFeatureCount(); i++ )
+   {
+      const FeatureInfo &info = FEATUREMGR->getAt( i );
+      if ( !stageFeatures.features.hasFeature( *info.type ) ) 
+         continue;
+
+      U32 numTexReg = info.feature->getResources( stageFeatures ).numTexReg;
+
+      // adds pass if blend op changes for feature
+      _setPassBlendOp( info.feature, passData, texIndex, stageFeatures, stageNum, features );
+
+      // Add pass if num tex reg is going to be too high
+      if( passData.mNumTexReg + numTexReg > GFX->getNumSamplers() )
+      {
+         if( !_addPass( passData, texIndex, stageFeatures, stageNum, features ) )
+            return false;
+         _setPassBlendOp( info.feature, passData, texIndex, stageFeatures, stageNum, features );
+      }
+
+      passData.mNumTexReg += numTexReg;
+      passData.mFeatureData.features.addFeature( *info.type );
+      info.feature->setTexData( mStages[stageNum], stageFeatures, passData, texIndex );
+
+      // Add pass if tex units are maxed out
+      if( texIndex > GFX->getNumSamplers() )
+      {
+         if( !_addPass( passData, texIndex, stageFeatures, stageNum, features ) )
+            return false;
+         _setPassBlendOp( info.feature, passData, texIndex, stageFeatures, stageNum, features );
+      }
+   }
+
+   const FeatureSet &passFeatures = passData.mFeatureData.codify();
+   if ( passFeatures.isNotEmpty() )
+   {
+      mFeatures.merge( passFeatures );
+      if(  !_addPass( passData, texIndex, stageFeatures, stageNum, features ) )
+      {
+         mFeatures.clear();
+         return false;
+      }
+   }
+
+   return true;
+} 
+
+void ProcessedShaderMaterial::_initMaterialParameters()
+{   
+   // Cleanup anything left first.
+   SAFE_DELETE( mDefaultParameters );
+   for ( U32 i = 0; i < mParameterHandles.size(); i++ )
+      SAFE_DELETE( mParameterHandles[i] );
+
+   // Gather the shaders as they all need to be 
+   // passed to the ShaderMaterialParameterHandles.
+   Vector<GFXShader*> shaders;
+   shaders.setSize( mPasses.size() );
+   for ( U32 i = 0; i < mPasses.size(); i++ )
+      shaders[i] = _getRPD(i)->shader;
+
+   // Run through each shader and prepare its constants.
+   for ( U32 i = 0; i < mPasses.size(); i++ )
+   {
+      const Vector<GFXShaderConstDesc>& desc = shaders[i]->getShaderConstDesc();
+
+      Vector<GFXShaderConstDesc>::const_iterator p = desc.begin();
+      for ( ; p != desc.end(); p++ )
+      {
+         // Add this to our list of shader constants
+         GFXShaderConstDesc d(*p);
+         mShaderConstDesc.push_back(d);
+
+         ShaderMaterialParameterHandle* smph = new ShaderMaterialParameterHandle(d.name, shaders);
+         mParameterHandles.push_back(smph);
+      }
+   }
+}
+
+bool ProcessedShaderMaterial::_addPass( ShaderRenderPassData &rpd, 
+                                       U32 &texIndex, 
+                                       MaterialFeatureData &fd,
+                                       U32 stageNum,
+                                       const FeatureSet &features )
+{
+   // Set number of textures, stage, glow, etc.
+   rpd.mNumTex = texIndex;
+   rpd.mStageNum = stageNum;
+   rpd.mGlow |= mMaterial->mGlow[stageNum];
+
+   // Copy over features
+   rpd.mFeatureData.materialFeatures = fd.features;
+
+   // Generate shader
+   GFXShader::setLogging( true, true );
+   rpd.shader = SHADERGEN->getShader( rpd.mFeatureData, mVertexFormat, &mUserMacros );
+   if( !rpd.shader )
+      return false;
+   rpd.shaderHandles.init( rpd.shader );   
+
+   // If a pass glows, we glow
+   if( rpd.mGlow )
+      mHasGlow = true;
+ 
+   ShaderRenderPassData *newPass = new ShaderRenderPassData( rpd );
+   mPasses.push_back( newPass );
+
+   // Give each active feature a chance to create specialized shader consts.
+   for( U32 i=0; i < FEATUREMGR->getFeatureCount(); i++ )
+   {
+      const FeatureInfo &info = FEATUREMGR->getAt( i );
+      if ( !fd.features.hasFeature( *info.type ) ) 
+         continue;
+
+      ShaderFeatureConstHandles *fh = info.feature->createConstHandles( rpd.shader, mUserObject );
+      if ( fh )
+         newPass->featureShaderHandles.push_back( fh );
+   }
+
+   rpd.reset();
+   texIndex = 0;
+   
+   return true;
+}
+
+void ProcessedShaderMaterial::_setPassBlendOp( ShaderFeature *sf,
+                                              ShaderRenderPassData &passData,
+                                              U32 &texIndex,
+                                              MaterialFeatureData &stageFeatures,
+                                              U32 stageNum,
+                                              const FeatureSet &features )
+{
+   if( sf->getBlendOp() == Material::None )
+   {
+      return;
+   }
+
+   // set up the current blend operation for multi-pass materials
+   if( mPasses.size() > 0)
+   {
+      // If passData.numTexReg is 0, this is a brand new pass, so set the
+      // blend operation to the first feature.
+      if( passData.mNumTexReg == 0 )
+      {
+         passData.mBlendOp = sf->getBlendOp();
+      }
+      else
+      {
+         // numTegReg is more than zero, if this feature
+         // doesn't have the same blend operation, then
+         // we need to create yet another pass 
+         if( sf->getBlendOp() != passData.mBlendOp && mPasses[mPasses.size()-1]->mStageNum == stageNum)
+         {
+            _addPass( passData, texIndex, stageFeatures, stageNum, features );
+            passData.mBlendOp = sf->getBlendOp();
+         }
+      }
+   }
+} 
+
+//
+// Runtime / rendering
+//
+bool ProcessedShaderMaterial::setupPass( SceneRenderState *state, const SceneData &sgData, U32 pass )
+{
+   PROFILE_SCOPE( ProcessedShaderMaterial_SetupPass );
+
+   // Make sure we have the pass
+   if(pass >= mPasses.size())
+   {
+      // If we were rendering instanced data tell
+      // the device to reset that vb stream.
+      if ( mInstancingState )
+         GFX->setVertexBuffer( NULL, 1 );
+
+      return false;
+   }
+
+   _setRenderState( state, sgData, pass );
+
+   // Set shaders
+   ShaderRenderPassData* rpd = _getRPD(pass);
+   if( rpd->shader )
+   {
+      GFX->setShader( rpd->shader );
+      GFX->setShaderConstBuffer(_getShaderConstBuffer(pass));      
+      _setShaderConstants(state, sgData, pass);      
+
+      // If we're instancing then do the initial step to get
+      // set the vb pointer to the const buffer.
+      if ( mInstancingState )
+         stepInstance();
+   }
+   else
+   {
+      GFX->disableShaders();
+      GFX->setShaderConstBuffer(NULL);
+   } 
+
+   // Set our textures
+   setTextureStages( state, sgData, pass );
+   _setTextureTransforms(pass);
+
+   return true;
+}
+
+void ProcessedShaderMaterial::setTextureStages( SceneRenderState *state, const SceneData &sgData, U32 pass )
+{
+   PROFILE_SCOPE( ProcessedShaderMaterial_SetTextureStages );
+
+   ShaderConstHandles *handles = _getShaderConstHandles(pass);
+
+   // Set all of the textures we need to render the give pass.
+#ifdef TORQUE_DEBUG
+   AssertFatal( pass<mPasses.size(), "Pass out of bounds" );
+#endif
+
+   RenderPassData *rpd = mPasses[pass];
+   GFXShaderConstBuffer* shaderConsts = _getShaderConstBuffer(pass);
+   NamedTexTarget *texTarget;
+   GFXTextureObject *texObject; 
+
+   for( U32 i=0; i<rpd->mNumTex; i++ )
+   {
+      U32 currTexFlag = rpd->mTexType[i];
+      if (!LIGHTMGR || !LIGHTMGR->setTextureStage(sgData, currTexFlag, i, shaderConsts, handles))
+      {
+         switch( currTexFlag )
+         {
+         // If the flag is unset then assume its just
+         // a regular texture to set... nothing special.
+         case 0:
+         default:
+            GFX->setTexture(i, rpd->mTexSlot[i].texObject);
+            break;
+
+         case Material::NormalizeCube:
+            GFX->setCubeTexture(i, Material::GetNormalizeCube());
+            break;
+
+         case Material::Lightmap:
+            GFX->setTexture( i, sgData.lightmap );
+            break;
+
+         case Material::ToneMapTex:
+            shaderConsts->setSafe(handles->mToneMapTexSC, (S32)i);
+            GFX->setTexture(i, rpd->mTexSlot[i].texObject);
+            break;
+
+         case Material::Cube:
+            GFX->setCubeTexture( i, rpd->mCubeMap );
+            break;
+
+         case Material::SGCube:
+            GFX->setCubeTexture( i, sgData.cubemap );
+            break;
+
+         case Material::BackBuff:
+            GFX->setTexture( i, sgData.backBuffTex );
+            break;
+            
+         case Material::TexTarget:
+            {
+               texTarget = rpd->mTexSlot[i].texTarget;
+               if ( !texTarget )
+               {
+                  GFX->setTexture( i, NULL );
+                  break;
+               }
+            
+               texObject = texTarget->getTexture();
+
+               // If no texture is available then map the default 2x2
+               // black texture to it.  This at least will ensure that
+               // we get consistant behavior across GPUs and platforms.
+               if ( !texObject )
+                  texObject = GFXTexHandle::ZERO;
+
+               if ( handles->mRTParamsSC[i]->isValid() && texObject )
+               {
+                  const Point3I &targetSz = texObject->getSize();
+                  const RectI &targetVp = texTarget->getViewport();
+                  Point4F rtParams;
+
+                  ScreenSpace::RenderTargetParameters(targetSz, targetVp, rtParams);
+
+                  shaderConsts->set(handles->mRTParamsSC[i], rtParams);
+               }
+
+               GFX->setTexture( i, texObject );
+               break;
+            }
+         }
+      }
+   }
+}
+
+void ProcessedShaderMaterial::_setTextureTransforms(const U32 pass)
+{
+   PROFILE_SCOPE( ProcessedShaderMaterial_SetTextureTransforms );
+
+   ShaderConstHandles* handles = _getShaderConstHandles(pass);
+   if (handles->mTexMatSC->isValid())
+   {   
+      MatrixF texMat( true );
+
+      mMaterial->updateTimeBasedParams();
+      F32 waveOffset = _getWaveOffset( pass ); // offset is between 0.0 and 1.0
+
+      // handle scroll anim type
+      if(  mMaterial->mAnimFlags[pass] & Material::Scroll )
+      {
+         if( mMaterial->mAnimFlags[pass] & Material::Wave )
+         {
+            Point3F scrollOffset;
+            scrollOffset.x = mMaterial->mScrollDir[pass].x * waveOffset;
+            scrollOffset.y = mMaterial->mScrollDir[pass].y * waveOffset;
+            scrollOffset.z = 1.0;
+
+            texMat.setColumn( 3, scrollOffset );
+         }
+         else
+         {
+            Point3F offset( mMaterial->mScrollOffset[pass].x, 
+               mMaterial->mScrollOffset[pass].y, 
+               1.0 );
+
+            texMat.setColumn( 3, offset );
+         }
+
+      }
+
+      // handle rotation
+      if( mMaterial->mAnimFlags[pass] & Material::Rotate )
+      {
+         if( mMaterial->mAnimFlags[pass] & Material::Wave )
+         {
+            F32 rotPos = waveOffset * M_2PI;
+            texMat.set( EulerF( 0.0, 0.0, rotPos ) );
+            texMat.setColumn( 3, Point3F( 0.5, 0.5, 0.0 ) );
+
+            MatrixF test( true );
+            test.setColumn( 3, Point3F( mMaterial->mRotPivotOffset[pass].x, 
+               mMaterial->mRotPivotOffset[pass].y,
+               0.0 ) );
+            texMat.mul( test );
+         }
+         else
+         {
+            texMat.set( EulerF( 0.0, 0.0, mMaterial->mRotPos[pass] ) );
+
+            texMat.setColumn( 3, Point3F( 0.5, 0.5, 0.0 ) );
+
+            MatrixF test( true );
+            test.setColumn( 3, Point3F( mMaterial->mRotPivotOffset[pass].x, 
+               mMaterial->mRotPivotOffset[pass].y,
+               0.0 ) );
+            texMat.mul( test );
+         }
+      }
+
+      // Handle scale + wave offset
+      if(  mMaterial->mAnimFlags[pass] & Material::Scale &&
+         mMaterial->mAnimFlags[pass] & Material::Wave )
+      {
+         F32 wOffset = fabs( waveOffset );
+
+         texMat.setColumn( 3, Point3F( 0.5, 0.5, 0.0 ) );
+
+         MatrixF temp( true );
+         temp.setRow( 0, Point3F( wOffset,  0.0,  0.0 ) );
+         temp.setRow( 1, Point3F( 0.0,  wOffset,  0.0 ) );
+         temp.setRow( 2, Point3F( 0.0,  0.0,  wOffset ) );
+         temp.setColumn( 3, Point3F( -wOffset * 0.5, -wOffset * 0.5, 0.0 ) );
+         texMat.mul( temp );
+      }
+
+      // handle sequence
+      if( mMaterial->mAnimFlags[pass] & Material::Sequence )
+      {
+         U32 frameNum = (U32)(MATMGR->getTotalTime() * mMaterial->mSeqFramePerSec[pass]);
+         F32 offset = frameNum * mMaterial->mSeqSegSize[pass];
+
+         if ( mMaterial->mAnimFlags[pass] & Material::Scale )
+            texMat.scale( Point3F( mMaterial->mSeqSegSize[pass], 1.0f, 1.0f ) );
+
+         Point3F texOffset = texMat.getPosition();
+         texOffset.x += offset;
+         texMat.setPosition( texOffset );
+      }
+
+      GFXShaderConstBuffer* shaderConsts = _getShaderConstBuffer(pass);
+      shaderConsts->setSafe(handles->mTexMatSC, texMat);
+   }
+}
+
+//--------------------------------------------------------------------------
+// Get wave offset for texture animations using a wave transform
+//--------------------------------------------------------------------------
+F32 ProcessedShaderMaterial::_getWaveOffset( U32 stage )
+{
+   switch( mMaterial->mWaveType[stage] )
+   {
+   case Material::Sin:
+      {
+         return mMaterial->mWaveAmp[stage] * mSin( M_2PI * mMaterial->mWavePos[stage] );
+         break;
+      }
+
+   case Material::Triangle:
+      {
+         F32 frac = mMaterial->mWavePos[stage] - mFloor( mMaterial->mWavePos[stage] );
+         if( frac > 0.0 && frac <= 0.25 )
+         {
+            return mMaterial->mWaveAmp[stage] * frac * 4.0;
+         }
+
+         if( frac > 0.25 && frac <= 0.5 )
+         {
+            return mMaterial->mWaveAmp[stage] * ( 1.0 - ((frac-0.25)*4.0) );
+         }
+
+         if( frac > 0.5 && frac <= 0.75 )
+         {
+            return mMaterial->mWaveAmp[stage] * (frac-0.5) * -4.0;
+         }
+
+         if( frac > 0.75 && frac <= 1.0 )
+         {
+            return -mMaterial->mWaveAmp[stage] * ( 1.0 - ((frac-0.75)*4.0) );
+         }
+
+         break;
+      }
+
+   case Material::Square:
+      {
+         F32 frac = mMaterial->mWavePos[stage] - mFloor( mMaterial->mWavePos[stage] );
+         if( frac > 0.0 && frac <= 0.5 )
+         {
+            return 0.0;
+         }
+         else
+         {
+            return mMaterial->mWaveAmp[stage];
+         }
+         break;
+      }
+
+   }
+
+   return 0.0;
+}
+
+void ProcessedShaderMaterial::_setShaderConstants(SceneRenderState * state, const SceneData &sgData, U32 pass)
+{
+   PROFILE_SCOPE( ProcessedShaderMaterial_SetShaderConstants );
+
+   GFXShaderConstBuffer* shaderConsts = _getShaderConstBuffer(pass);
+   ShaderConstHandles* handles = _getShaderConstHandles(pass);
+   U32 stageNum = getStageFromPass(pass);
+
+   // First we do all the constants which are not
+   // controlled via the material... we have to
+   // set these all the time as they could change.
+
+   if ( handles->mFogDataSC->isValid() )
+   {
+      Point3F fogData;
+      fogData.x = sgData.fogDensity;
+      fogData.y = sgData.fogDensityOffset;
+      fogData.z = sgData.fogHeightFalloff;     
+      shaderConsts->set( handles->mFogDataSC, fogData );
+   }
+
+   shaderConsts->setSafe(handles->mFogColorSC, sgData.fogColor);
+
+   if( handles->mOneOverFarplane->isValid() )
+   {
+      const F32 &invfp = 1.0f / state->getFarPlane();
+      Point4F oneOverFP(invfp, invfp, invfp, invfp);
+      shaderConsts->set( handles->mOneOverFarplane, oneOverFP );
+   }
+
+   shaderConsts->setSafe( handles->mAccumTimeSC, MATMGR->getTotalTime() );
+
+   // If the shader constants have not been lost then
+   // they contain the content from a previous render pass.
+   //
+   // In this case we can skip updating the material constants
+   // which do not change frame to frame.
+   //
+   // NOTE: This assumes we're not animating material parameters
+   // in a way that doesn't cause a shader reload... this isn't
+   // being done now, but it could change in the future.
+   // 
+   if ( !shaderConsts->wasLost() )
+      return;
+
+   shaderConsts->setSafe(handles->mSpecularColorSC, mMaterial->mSpecular[stageNum]);   
+   shaderConsts->setSafe(handles->mSpecularPowerSC, mMaterial->mSpecularPower[stageNum]);
+   shaderConsts->setSafe(handles->mSpecularStrengthSC, mMaterial->mSpecularStrength[stageNum]);
+
+   shaderConsts->setSafe(handles->mParallaxInfoSC, mMaterial->mParallaxScale[stageNum]);   
+   shaderConsts->setSafe(handles->mMinnaertConstantSC, mMaterial->mMinnaertConstant[stageNum]);
+
+   if ( handles->mSubSurfaceParamsSC->isValid() )
+   {
+      Point4F subSurfParams;
+      dMemcpy( &subSurfParams, &mMaterial->mSubSurfaceColor[stageNum], sizeof(ColorF) );
+      subSurfParams.w = mMaterial->mSubSurfaceRolloff[stageNum];
+      shaderConsts->set(handles->mSubSurfaceParamsSC, subSurfParams);
+   }
+
+   if ( handles->mRTSizeSC->isValid() )
+   {
+      const Point2I &resolution = GFX->getActiveRenderTarget()->getSize();
+      Point2F pixelShaderConstantData;
+
+      pixelShaderConstantData.x = resolution.x;
+      pixelShaderConstantData.y = resolution.y;
+
+      shaderConsts->set( handles->mRTSizeSC, pixelShaderConstantData );
+   }
+
+   if ( handles->mOneOverRTSizeSC->isValid() )
+   {
+      const Point2I &resolution = GFX->getActiveRenderTarget()->getSize();
+      Point2F oneOverTargetSize( 1.0f / (F32)resolution.x, 1.0f / (F32)resolution.y );
+
+      shaderConsts->set( handles->mOneOverRTSizeSC, oneOverTargetSize );
+   }
+
+   // set detail scale
+   shaderConsts->setSafe(handles->mDetailScaleSC, mMaterial->mDetailScale[stageNum]);
+   shaderConsts->setSafe(handles->mDetailBumpStrength, mMaterial->mDetailNormalMapStrength[stageNum]);
+
+   // MFT_ImposterVert
+   if ( handles->mImposterUVs->isValid() )
+   {
+      U32 uvCount = getMin( mMaterial->mImposterUVs.size(), 64 ); // See imposter.hlsl   
+      AlignedArray<Point4F> imposterUVs( uvCount, sizeof( Point4F ), (U8*)mMaterial->mImposterUVs.address(), false );
+      shaderConsts->set( handles->mImposterUVs, imposterUVs );
+   }
+   shaderConsts->setSafe( handles->mImposterLimits, mMaterial->mImposterLimits );
+
+   // Diffuse
+   shaderConsts->setSafe(handles->mDiffuseColorSC, mMaterial->mDiffuse[stageNum]);
+
+   shaderConsts->setSafe( handles->mAlphaTestValueSC, mClampF( (F32)mMaterial->mAlphaRef / 255.0f, 0.0f, 1.0f ) );      
+
+   if(handles->mDiffuseAtlasParamsSC)
+   {
+      Point4F atlasParams(1.0f / mMaterial->mCellLayout[stageNum].x, // 1 / num_horizontal
+         1.0f / mMaterial->mCellLayout[stageNum].y, // 1 / num_vertical
+         mMaterial->mCellSize[stageNum],            // tile size in pixels
+         getBinLog2(mMaterial->mCellSize[stageNum]) );    // pow of 2 of tile size in pixels 2^9 = 512, 2^10=1024 etc
+      shaderConsts->setSafe(handles->mDiffuseAtlasParamsSC, atlasParams);
+   }
+
+   if(handles->mBumpAtlasParamsSC)
+   {
+      Point4F atlasParams(1.0f / mMaterial->mCellLayout[stageNum].x, // 1 / num_horizontal
+         1.0f / mMaterial->mCellLayout[stageNum].y, // 1 / num_vertical
+         mMaterial->mCellSize[stageNum],            // tile size in pixels
+         getBinLog2(mMaterial->mCellSize[stageNum]) );    // pow of 2 of tile size in pixels 2^9 = 512, 2^10=1024 etc
+      shaderConsts->setSafe(handles->mBumpAtlasParamsSC, atlasParams);
+   }
+
+   if(handles->mDiffuseAtlasTileSC)
+   {
+      // Sanity check the wrap flags
+      //AssertWarn(mMaterial->mTextureAddressModeU == mMaterial->mTextureAddressModeV, "Addresing mode mismatch, texture atlasing will be confused");
+      Point4F atlasTileParams( mMaterial->mCellIndex[stageNum].x, // Tile co-ordinate, ie: [0, 3]
+         mMaterial->mCellIndex[stageNum].y, 
+         0.0f, 0.0f ); // TODO: Wrap mode flags?
+      shaderConsts->setSafe(handles->mDiffuseAtlasTileSC, atlasTileParams);
+   }
+
+   if(handles->mBumpAtlasTileSC)
+   {
+      // Sanity check the wrap flags
+      //AssertWarn(mMaterial->mTextureAddressModeU == mMaterial->mTextureAddressModeV, "Addresing mode mismatch, texture atlasing will be confused");
+      Point4F atlasTileParams( mMaterial->mCellIndex[stageNum].x, // Tile co-ordinate, ie: [0, 3]
+         mMaterial->mCellIndex[stageNum].y, 
+         0.0f, 0.0f ); // TODO: Wrap mode flags?
+      shaderConsts->setSafe(handles->mBumpAtlasTileSC, atlasTileParams);
+   }
+}
+
+bool ProcessedShaderMaterial::_hasCubemap(U32 pass)
+{
+   // Only support cubemap on the first stage
+   if( mPasses[pass]->mStageNum > 0 )
+      return false;
+
+   if( mPasses[pass]->mCubeMap )
+      return true;
+
+   return false;
+}
+
+void ProcessedShaderMaterial::setTransforms(const MatrixSet &matrixSet, SceneRenderState *state, const U32 pass)
+{
+   PROFILE_SCOPE( ProcessedShaderMaterial_setTransforms );
+
+   GFXShaderConstBuffer* shaderConsts = _getShaderConstBuffer(pass);
+   ShaderConstHandles* handles = _getShaderConstHandles(pass);
+
+   // The MatrixSet will lazily generate a matrix under the
+   // various 'get' methods, so inline the test for a valid
+   // shader constant handle to avoid that work when we can.
+   if ( handles->mModelViewProjSC->isValid() )
+      shaderConsts->set( handles->mModelViewProjSC, matrixSet.getWorldViewProjection() );
+   if ( handles->mObjTransSC->isValid() )
+      shaderConsts->set( handles->mObjTransSC, matrixSet.getObjectToWorld() );      
+   if ( handles->mWorldToObjSC->isValid() )
+      shaderConsts->set( handles->mWorldToObjSC, matrixSet.getWorldToObject() );
+   if ( handles->mWorldToCameraSC->isValid() )
+      shaderConsts->set( handles->mWorldToCameraSC, matrixSet.getWorldToCamera() );
+   if ( handles->mWorldViewOnlySC->isValid() )
+      shaderConsts->set( handles->mWorldViewOnlySC, matrixSet.getObjectToCamera() );
+   if ( handles->mViewToObjSC->isValid() )
+      shaderConsts->set( handles->mViewToObjSC, matrixSet.getCameraToObject() );
+   if ( handles->mViewProjSC->isValid() )
+      shaderConsts->set( handles->mViewProjSC, matrixSet.getWorldToScreen() );
+
+   if (  handles->mCubeTransSC->isValid() &&
+         ( _hasCubemap(pass) || mMaterial->mDynamicCubemap ) )
+   {
+      // TODO: Could we not remove this constant?  Use mObjTransSC and cast to float3x3 instead?
+      shaderConsts->set(handles->mCubeTransSC, matrixSet.getObjectToWorld(), GFXSCT_Float3x3);
+   }
+
+   if ( handles->m_vEyeSC->isValid() )
+      shaderConsts->set( handles->m_vEyeSC, state->getVectorEye() );
+}
+
+void ProcessedShaderMaterial::setSceneInfo(SceneRenderState * state, const SceneData& sgData, U32 pass)
+{
+   PROFILE_SCOPE( ProcessedShaderMaterial_setSceneInfo );
+
+   GFXShaderConstBuffer* shaderConsts = _getShaderConstBuffer(pass);
+   ShaderConstHandles* handles = _getShaderConstHandles(pass);
+
+   // Set cubemap stuff here (it's convenient!)
+   const Point3F &eyePosWorld = state->getCameraPosition();
+   if ( handles->mCubeEyePosSC->isValid() )
+   {
+      if(_hasCubemap(pass) || mMaterial->mDynamicCubemap)
+      {
+         Point3F cubeEyePos = eyePosWorld - sgData.objTrans->getPosition();
+         shaderConsts->set(handles->mCubeEyePosSC, cubeEyePos);      
+      }
+   }
+
+   shaderConsts->setSafe(handles->mVisiblitySC, sgData.visibility);
+
+   shaderConsts->setSafe(handles->mEyePosWorldSC, eyePosWorld);   
+
+   if ( handles->mEyePosSC->isValid() )
+   {
+      MatrixF tempMat( *sgData.objTrans );
+      tempMat.inverse();
+      Point3F eyepos;
+      tempMat.mulP( eyePosWorld, &eyepos );
+      shaderConsts->set(handles->mEyePosSC, eyepos);   
+   }
+
+   shaderConsts->setSafe(handles->mEyeMatSC, state->getCameraTransform());   
+
+   ShaderRenderPassData *rpd = _getRPD( pass );
+   for ( U32 i=0; i < rpd->featureShaderHandles.size(); i++ )
+      rpd->featureShaderHandles[i]->setConsts( state, sgData, shaderConsts );
+
+   LIGHTMGR->setLightInfo( this, mMaterial, sgData, state, pass, shaderConsts );
+}
+
+void ProcessedShaderMaterial::setBuffers( GFXVertexBufferHandleBase *vertBuffer, GFXPrimitiveBufferHandle *primBuffer )
+{
+   PROFILE_SCOPE(ProcessedShaderMaterial_setBuffers);
+
+   // If we're not instanced then just call the parent.
+   if ( !mInstancingState )
+   {
+      Parent::setBuffers( vertBuffer, primBuffer );
+      return;
+   }
+
+   PROFILE_SCOPE(ProcessedShaderMaterial_setBuffers_instancing);
+
+   const S32 instCount = mInstancingState->getCount();
+   AssertFatal( instCount > 0,
+      "ProcessedShaderMaterial::setBuffers - No instances rendered!" );
+
+   // Nothing special here.
+   GFX->setPrimitiveBuffer( *primBuffer );
+
+   // Set the first stream the the normal VB and set the
+   // correct frequency for the number of instances to render.
+   GFX->setVertexBuffer( *vertBuffer, 0, instCount );
+
+   // Get a volatile VB and fill it with the vertex data.
+   const GFXVertexFormat *instFormat = mInstancingState->getFormat();
+   GFXVertexBufferDataHandle instVB;
+   instVB.set( GFX, instFormat->getSizeInBytes(), instFormat, instCount, GFXBufferTypeVolatile );
+   U8 *dest = instVB.lock();
+   if(!dest) return;
+   dMemcpy( dest, mInstancingState->getBuffer(), instFormat->getSizeInBytes() * instCount );
+   instVB.unlock();
+
+   // Set the instance vb for streaming.
+   GFX->setVertexBuffer( instVB, 1, 1 );
+
+   // Finally set the vertex format which defines
+   // both of the streams.
+   GFX->setVertexFormat( mInstancingState->getDeclFormat() );
+
+   // Done... reset the count.
+   mInstancingState->resetStep();
+}
+
+bool ProcessedShaderMaterial::stepInstance()
+{
+   PROFILE_SCOPE(ProcessedShaderMaterial_stepInstance);
+   AssertFatal( mInstancingState, "ProcessedShaderMaterial::stepInstance - This material isn't instanced!" );  
+   return mInstancingState->step( &_getShaderConstBuffer( 0 )->mInstPtr );
+}
+
+MaterialParameters* ProcessedShaderMaterial::allocMaterialParameters()
+{
+   ShaderMaterialParameters* smp = new ShaderMaterialParameters();
+   Vector<GFXShaderConstBufferRef> buffers( __FILE__, __LINE__ );
+   buffers.setSize(mPasses.size());
+   for (U32 i = 0; i < mPasses.size(); i++)
+      buffers[i] = _getRPD(i)->shader->allocConstBuffer();
+   // smp now owns these buffers.
+   smp->setBuffers(mShaderConstDesc, buffers);
+   return smp;   
+}
+
+MaterialParameterHandle* ProcessedShaderMaterial::getMaterialParameterHandle(const String& name)
+{
+   // Search our list
+   for (U32 i = 0; i < mParameterHandles.size(); i++)
+   {
+      if (mParameterHandles[i]->getName().equal(name))
+         return mParameterHandles[i];
+   }
+   
+   // If we didn't find it, we have to add it to support shader reloading.
+
+   Vector<GFXShader*> shaders;
+   shaders.setSize(mPasses.size());
+   for (U32 i = 0; i < mPasses.size(); i++)
+      shaders[i] = _getRPD(i)->shader;
+
+   ShaderMaterialParameterHandle* smph = new ShaderMaterialParameterHandle( name, shaders );
+   mParameterHandles.push_back(smph);
+
+   return smph;
+}
+
+/// This is here to deal with the differences between ProcessedCustomMaterials and ProcessedShaderMaterials.
+GFXShaderConstBuffer* ProcessedShaderMaterial::_getShaderConstBuffer( const U32 pass )
+{   
+   if (mCurrentParams && pass < mPasses.size())
+   {
+      return static_cast<ShaderMaterialParameters*>(mCurrentParams)->getBuffer(pass);
+   }
+   return NULL;
+}
+
+ShaderConstHandles* ProcessedShaderMaterial::_getShaderConstHandles(const U32 pass)
+{
+   if (pass < mPasses.size())
+   {
+      return &_getRPD(pass)->shaderHandles;
+   }
+   return NULL;
+}
+
+void ProcessedShaderMaterial::dumpMaterialInfo()
+{
+   for ( U32 i = 0; i < getNumPasses(); i++ )
+   {
+      const ShaderRenderPassData *passData = _getRPD( i );
+
+      if ( passData == NULL )
+         continue;
+
+      const GFXShader      *shader = passData->shader;
+
+      if ( shader == NULL )
+         Con::printf( "  [%i] [NULL shader]", i );
+      else
+         Con::printf( "  [%i] %s", i, shader->describeSelf().c_str() );
+   }
+}
--- source/materials/processedShaderMaterial.h	Tue Jan 20 00:26:36 1970
+++ source/materials/processedShaderMaterial.h	Tue Jan 20 00:26:36 1970
@@ -1,268 +1,263 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2012 GarageGames, LLC
-//
-// Permission is hereby granted, free of charge, to any person obtaining a copy
-// of this software and associated documentation files (the "Software"), to
-// deal in the Software without restriction, including without limitation the
-// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
-// sell copies of the Software, and to permit persons to whom the Software is
-// furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-// IN THE SOFTWARE.
-//-----------------------------------------------------------------------------
-
-#ifndef _MATERIALS_PROCESSEDSHADERMATERIAL_H_
-#define _MATERIALS_PROCESSEDSHADERMATERIAL_H_
-
-#ifndef _MATERIALS_PROCESSEDMATERIAL_H_
-#include "processedMaterial.h"
-#endif
-#ifndef _GFXSHADER_H_
-#include "gfx/gfxShader.h"
-#endif
-
-class GenericConstBufferLayout;
-class ShaderData;
-class LightInfo;
-class ShaderMaterialParameterHandle;
-class ShaderFeatureConstHandles;
-class CustomMaterial;
-
-
-class ShaderConstHandles
-{
-public:
-   GFXShaderConstHandle* mDiffuseColorSC;
-   GFXShaderConstHandle* mToneMapTexSC;
-   GFXShaderConstHandle* mTexMatSC;
-   GFXShaderConstHandle* mSpecularColorSC;
-   GFXShaderConstHandle* mSpecularPowerSC;
-   GFXShaderConstHandle* mSpecularStrengthSC;
-   GFXShaderConstHandle* mParallaxInfoSC;
-   GFXShaderConstHandle* mAccuScaleSC;
-   GFXShaderConstHandle* mAccuDirectionSC;
-   GFXShaderConstHandle* mAccuStrengthSC;
-   GFXShaderConstHandle* mAccuCoverageSC;
-   GFXShaderConstHandle* mAccuSpecularSC;
-   GFXShaderConstHandle* mFogDataSC;
-   GFXShaderConstHandle* mFogColorSC;   
-   GFXShaderConstHandle* mDetailScaleSC;
-   GFXShaderConstHandle* mVisiblitySC;
-   GFXShaderConstHandle* mColorMultiplySC;
-   GFXShaderConstHandle* mAlphaTestValueSC;
-   GFXShaderConstHandle* mModelViewProjSC;
-   GFXShaderConstHandle* mWorldViewOnlySC;     
-   GFXShaderConstHandle* mWorldToCameraSC;
-   GFXShaderConstHandle* mWorldToObjSC;         
-   GFXShaderConstHandle* mViewToObjSC;         
-   GFXShaderConstHandle* mCubeTransSC;
-   GFXShaderConstHandle* mObjTransSC;
-   GFXShaderConstHandle* mCubeEyePosSC;
-   GFXShaderConstHandle* mEyePosSC;
-   GFXShaderConstHandle* mEyePosWorldSC;
-   GFXShaderConstHandle* m_vEyeSC;
-   GFXShaderConstHandle* mEyeMatSC;
-   GFXShaderConstHandle* mOneOverFarplane;
-   GFXShaderConstHandle* mAccumTimeSC;
-   GFXShaderConstHandle* mMinnaertConstantSC;
-   GFXShaderConstHandle* mSubSurfaceParamsSC;
-   GFXShaderConstHandle* mDiffuseAtlasParamsSC;
-   GFXShaderConstHandle* mBumpAtlasParamsSC;
-   GFXShaderConstHandle* mDiffuseAtlasTileSC;
-   GFXShaderConstHandle* mBumpAtlasTileSC;
-   GFXShaderConstHandle *mRTSizeSC;
-   GFXShaderConstHandle *mOneOverRTSizeSC;
-   GFXShaderConstHandle* mDetailBumpStrength;
-   GFXShaderConstHandle* mViewProjSC;
-
-   GFXShaderConstHandle *mImposterUVs;
-   GFXShaderConstHandle *mImposterLimits;
-
-   GFXShaderConstHandle* mTexHandlesSC[Material::MAX_TEX_PER_PASS];
-   GFXShaderConstHandle* mRTParamsSC[TEXTURE_STAGE_COUNT];
-
-   void init( GFXShader* shader, CustomMaterial* mat = NULL );
-};
-
-class ShaderRenderPassData : public RenderPassData
-{
-   typedef RenderPassData Parent;
-
-public:
-
-   virtual ~ShaderRenderPassData() { reset(); }
-
-   GFXShaderRef         shader;
-   ShaderConstHandles   shaderHandles;
-   Vector<ShaderFeatureConstHandles*> featureShaderHandles;
-
-   virtual void reset();
-   virtual String describeSelf() const;
-};
-
-class ProcessedShaderMaterial : public ProcessedMaterial
-{
-   typedef ProcessedMaterial Parent;
-public:
-
-   ProcessedShaderMaterial();
-   ProcessedShaderMaterial(Material &mat);
-   ~ProcessedShaderMaterial();
-
-   // ProcessedMaterial
-   virtual bool init(   const FeatureSet &features, 
-                        const GFXVertexFormat *vertexFormat,
-                        const MatFeaturesDelegate &featuresDelegate );
-   virtual bool setupPass(SceneRenderState *, const SceneData& sgData, U32 pass);
-   virtual void setTextureStages(SceneRenderState *, const SceneData &sgData, U32 pass );
-   virtual void setTransforms(const MatrixSet &matrixSet, SceneRenderState *state, const U32 pass);
-   virtual void setSceneInfo(SceneRenderState *, const SceneData& sgData, U32 pass);
-   virtual void setBuffers(GFXVertexBufferHandleBase* vertBuffer, GFXPrimitiveBufferHandle* primBuffer); 
-   virtual bool stepInstance();
-   virtual void dumpMaterialInfo();
-   virtual MaterialParameters* allocMaterialParameters();    
-   virtual MaterialParameters* getDefaultMaterialParameters() { return mDefaultParameters; }   
-   virtual MaterialParameterHandle* getMaterialParameterHandle(const String& name);
-   virtual U32 getNumStages();
-
-protected:
-
-   Vector<GFXShaderConstDesc> mShaderConstDesc;
-   MaterialParameters* mDefaultParameters;
-   Vector<ShaderMaterialParameterHandle*> mParameterHandles;
-
-   /// Hold the instancing state data for the material.   
-   class InstancingState
-   {
-      const static U32 COUNT = 200;
-
-   public:
-
-      InstancingState()
-         :  mInstFormat( NULL ),
-            mBuffer( NULL ),
-            mCount( -1 )
-      {
-      }
-
-      ~InstancingState()
-      {
-         delete [] mBuffer;
-      }
-
-      void setFormat( const GFXVertexFormat *instFormat, const GFXVertexFormat *vertexFormat )
-      {
-         mInstFormat = instFormat;
-         mDeclFormat.copy( *vertexFormat );
-         mDeclFormat.append( *mInstFormat, 1 );
-         mDeclFormat.getDecl();
-
-         delete [] mBuffer;
-         mBuffer = new U8[ mInstFormat->getSizeInBytes() * COUNT ];
-         mCount = -1;
-      }
-
-      bool step( U8 **outPtr )
-      {
-         // Are we starting a new draw call?
-         if ( mCount < 0 )
-         {
-            *outPtr = mBuffer;
-            mCount = 0;
-         }
-         else
-         {
-            // Increment to the next instance.
-            *outPtr += mInstFormat->getSizeInBytes();
-            mCount++;
-         }
-
-         return mCount < COUNT;
-      }
-
-      void resetStep() { mCount = -1; }
-
-      U8* getBuffer() const { return mBuffer; }
-
-      S32 getCount() const { return mCount; }
-
-      const GFXVertexFormat* getFormat() const { return mInstFormat; }
-
-      const GFXVertexFormat* getDeclFormat() const { return &mDeclFormat; }
-
-   protected:
-
-      GFXVertexFormat mDeclFormat;
-      const GFXVertexFormat *mInstFormat;  
-      U8 *mBuffer;
-      S32 mCount;
-
-   };
-
-   /// The instancing state if this material
-   /// supports instancing.
-   InstancingState *mInstancingState;
-   
-   /// @name Internal functions
-   ///
-   /// @{
-
-   /// Adds a pass for the given stage.
-   virtual bool _addPass( ShaderRenderPassData &rpd, 
-      U32 &texIndex, 
-      MaterialFeatureData &fd,
-      U32 stageNum,
-      const FeatureSet &features);
-
-   /// Chooses a blend op for the given pass
-   virtual void _setPassBlendOp( ShaderFeature *sf,
-      ShaderRenderPassData &passData,
-      U32 &texIndex,
-      MaterialFeatureData &stageFeatures,
-      U32 stageNum,
-      const FeatureSet &features);
-
-   /// Creates passes for the given stage
-   virtual bool _createPasses( MaterialFeatureData &fd, U32 stageNum, const FeatureSet &features );
-
-   /// Fills in the MaterialFeatureData for the given stage
-   virtual void _determineFeatures( U32 stageNum, 
-                                    MaterialFeatureData &fd, 
-                                    const FeatureSet &features );
-
-   /// Do we have a cubemap on pass?
-   virtual bool _hasCubemap(U32 pass);
-
-   /// Used by setTextureTransforms
-   F32 _getWaveOffset( U32 stage );
-
-   /// Sets texture transformation matrices for texture animations such as scale and wave
-   virtual void _setTextureTransforms(const U32 pass);
-
-   /// Sets all of the necessary shader constants for the given pass
-   virtual void _setShaderConstants(SceneRenderState *, const SceneData &sgData, U32 pass);
-
-   /// @}
-
-   void _setPrimaryLightConst(const LightInfo* light, const MatrixF& objTrans, const U32 stageNum);
-
-   /// This is here to deal with the differences between ProcessedCustomMaterials and ProcessedShaderMaterials.
-   virtual GFXShaderConstBuffer* _getShaderConstBuffer(const U32 pass);
-   virtual ShaderConstHandles* _getShaderConstHandles(const U32 pass);
-
-   ///
-   virtual void _initMaterialParameters();
-
-   ShaderRenderPassData* _getRPD(const U32 pass) { return static_cast<ShaderRenderPassData*>(mPasses[pass]); }
-};
-
-#endif // _MATERIALS_PROCESSEDSHADERMATERIAL_H_
+//-----------------------------------------------------------------------------
+// Copyright (c) 2012 GarageGames, LLC
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to
+// deal in the Software without restriction, including without limitation the
+// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+// sell copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+// IN THE SOFTWARE.
+//-----------------------------------------------------------------------------
+
+#ifndef _MATERIALS_PROCESSEDSHADERMATERIAL_H_
+#define _MATERIALS_PROCESSEDSHADERMATERIAL_H_
+
+#ifndef _MATERIALS_PROCESSEDMATERIAL_H_
+#include "processedMaterial.h"
+#endif
+#ifndef _GFXSHADER_H_
+#include "gfx/gfxShader.h"
+#endif
+
+class GenericConstBufferLayout;
+class ShaderData;
+class LightInfo;
+class ShaderMaterialParameterHandle;
+class ShaderFeatureConstHandles;
+class CustomMaterial;
+
+
+class ShaderConstHandles
+{
+public:
+   GFXShaderConstHandle* mDiffuseColorSC;
+   GFXShaderConstHandle* mToneMapTexSC;
+   GFXShaderConstHandle* mTexMatSC;
+   GFXShaderConstHandle* mSpecularColorSC;
+   GFXShaderConstHandle* mSpecularPowerSC;
+   GFXShaderConstHandle* mSpecularStrengthSC;
+   GFXShaderConstHandle* mParallaxInfoSC;
+   GFXShaderConstHandle* mFogDataSC;
+   GFXShaderConstHandle* mFogColorSC;   
+   GFXShaderConstHandle* mDetailScaleSC;
+   GFXShaderConstHandle* mVisiblitySC;
+   GFXShaderConstHandle* mColorMultiplySC;
+   GFXShaderConstHandle* mAlphaTestValueSC;
+   GFXShaderConstHandle* mModelViewProjSC;
+   GFXShaderConstHandle* mWorldViewOnlySC;     
+   GFXShaderConstHandle* mWorldToCameraSC;
+   GFXShaderConstHandle* mWorldToObjSC;         
+   GFXShaderConstHandle* mViewToObjSC;         
+   GFXShaderConstHandle* mCubeTransSC;
+   GFXShaderConstHandle* mObjTransSC;
+   GFXShaderConstHandle* mCubeEyePosSC;
+   GFXShaderConstHandle* mEyePosSC;
+   GFXShaderConstHandle* mEyePosWorldSC;
+   GFXShaderConstHandle* m_vEyeSC;
+   GFXShaderConstHandle* mEyeMatSC;
+   GFXShaderConstHandle* mOneOverFarplane;
+   GFXShaderConstHandle* mAccumTimeSC;
+   GFXShaderConstHandle* mMinnaertConstantSC;
+   GFXShaderConstHandle* mSubSurfaceParamsSC;
+   GFXShaderConstHandle* mDiffuseAtlasParamsSC;
+   GFXShaderConstHandle* mBumpAtlasParamsSC;
+   GFXShaderConstHandle* mDiffuseAtlasTileSC;
+   GFXShaderConstHandle* mBumpAtlasTileSC;
+   GFXShaderConstHandle *mRTSizeSC;
+   GFXShaderConstHandle *mOneOverRTSizeSC;
+   GFXShaderConstHandle* mDetailBumpStrength;
+   GFXShaderConstHandle* mViewProjSC;
+
+   GFXShaderConstHandle *mImposterUVs;
+   GFXShaderConstHandle *mImposterLimits;
+
+   GFXShaderConstHandle* mTexHandlesSC[Material::MAX_TEX_PER_PASS];
+   GFXShaderConstHandle* mRTParamsSC[TEXTURE_STAGE_COUNT];
+
+   void init( GFXShader* shader, CustomMaterial* mat = NULL );
+};
+
+class ShaderRenderPassData : public RenderPassData
+{
+   typedef RenderPassData Parent;
+
+public:
+
+   virtual ~ShaderRenderPassData() { reset(); }
+
+   GFXShaderRef         shader;
+   ShaderConstHandles   shaderHandles;
+   Vector<ShaderFeatureConstHandles*> featureShaderHandles;
+
+   virtual void reset();
+   virtual String describeSelf() const;
+};
+
+class ProcessedShaderMaterial : public ProcessedMaterial
+{
+   typedef ProcessedMaterial Parent;
+public:
+
+   ProcessedShaderMaterial();
+   ProcessedShaderMaterial(Material &mat);
+   ~ProcessedShaderMaterial();
+
+   // ProcessedMaterial
+   virtual bool init(   const FeatureSet &features, 
+                        const GFXVertexFormat *vertexFormat,
+                        const MatFeaturesDelegate &featuresDelegate );
+   virtual bool setupPass(SceneRenderState *, const SceneData& sgData, U32 pass);
+   virtual void setTextureStages(SceneRenderState *, const SceneData &sgData, U32 pass );
+   virtual void setTransforms(const MatrixSet &matrixSet, SceneRenderState *state, const U32 pass);
+   virtual void setSceneInfo(SceneRenderState *, const SceneData& sgData, U32 pass);
+   virtual void setBuffers(GFXVertexBufferHandleBase* vertBuffer, GFXPrimitiveBufferHandle* primBuffer); 
+   virtual bool stepInstance();
+   virtual void dumpMaterialInfo();
+   virtual MaterialParameters* allocMaterialParameters();    
+   virtual MaterialParameters* getDefaultMaterialParameters() { return mDefaultParameters; }   
+   virtual MaterialParameterHandle* getMaterialParameterHandle(const String& name);
+   virtual U32 getNumStages();
+
+protected:
+
+   Vector<GFXShaderConstDesc> mShaderConstDesc;
+   MaterialParameters* mDefaultParameters;
+   Vector<ShaderMaterialParameterHandle*> mParameterHandles;
+
+   /// Hold the instancing state data for the material.   
+   class InstancingState
+   {
+      const static U32 COUNT = 200;
+
+   public:
+
+      InstancingState()
+         :  mInstFormat( NULL ),
+            mBuffer( NULL ),
+            mCount( -1 )
+      {
+      }
+
+      ~InstancingState()
+      {
+         delete [] mBuffer;
+      }
+
+      void setFormat( const GFXVertexFormat *instFormat, const GFXVertexFormat *vertexFormat )
+      {
+         mInstFormat = instFormat;
+         mDeclFormat.copy( *vertexFormat );
+         mDeclFormat.append( *mInstFormat, 1 );
+         mDeclFormat.getDecl();
+
+         delete [] mBuffer;
+         mBuffer = new U8[ mInstFormat->getSizeInBytes() * COUNT ];
+         mCount = -1;
+      }
+
+      bool step( U8 **outPtr )
+      {
+         // Are we starting a new draw call?
+         if ( mCount < 0 )
+         {
+            *outPtr = mBuffer;
+            mCount = 0;
+         }
+         else
+         {
+            // Increment to the next instance.
+            *outPtr += mInstFormat->getSizeInBytes();
+            mCount++;
+         }
+
+         return mCount < COUNT;
+      }
+
+      void resetStep() { mCount = -1; }
+
+      U8* getBuffer() const { return mBuffer; }
+
+      S32 getCount() const { return mCount; }
+
+      const GFXVertexFormat* getFormat() const { return mInstFormat; }
+
+      const GFXVertexFormat* getDeclFormat() const { return &mDeclFormat; }
+
+   protected:
+
+      GFXVertexFormat mDeclFormat;
+      const GFXVertexFormat *mInstFormat;  
+      U8 *mBuffer;
+      S32 mCount;
+
+   };
+
+   /// The instancing state if this material
+   /// supports instancing.
+   InstancingState *mInstancingState;
+   
+   /// @name Internal functions
+   ///
+   /// @{
+
+   /// Adds a pass for the given stage.
+   virtual bool _addPass( ShaderRenderPassData &rpd, 
+      U32 &texIndex, 
+      MaterialFeatureData &fd,
+      U32 stageNum,
+      const FeatureSet &features);
+
+   /// Chooses a blend op for the given pass
+   virtual void _setPassBlendOp( ShaderFeature *sf,
+      ShaderRenderPassData &passData,
+      U32 &texIndex,
+      MaterialFeatureData &stageFeatures,
+      U32 stageNum,
+      const FeatureSet &features);
+
+   /// Creates passes for the given stage
+   virtual bool _createPasses( MaterialFeatureData &fd, U32 stageNum, const FeatureSet &features );
+
+   /// Fills in the MaterialFeatureData for the given stage
+   virtual void _determineFeatures( U32 stageNum, 
+                                    MaterialFeatureData &fd, 
+                                    const FeatureSet &features );
+
+   /// Do we have a cubemap on pass?
+   virtual bool _hasCubemap(U32 pass);
+
+   /// Used by setTextureTransforms
+   F32 _getWaveOffset( U32 stage );
+
+   /// Sets texture transformation matrices for texture animations such as scale and wave
+   virtual void _setTextureTransforms(const U32 pass);
+
+   /// Sets all of the necessary shader constants for the given pass
+   virtual void _setShaderConstants(SceneRenderState *, const SceneData &sgData, U32 pass);
+
+   /// @}
+
+   void _setPrimaryLightConst(const LightInfo* light, const MatrixF& objTrans, const U32 stageNum);
+
+   /// This is here to deal with the differences between ProcessedCustomMaterials and ProcessedShaderMaterials.
+   virtual GFXShaderConstBuffer* _getShaderConstBuffer(const U32 pass);
+   virtual ShaderConstHandles* _getShaderConstHandles(const U32 pass);
+
+   ///
+   virtual void _initMaterialParameters();
+
+   ShaderRenderPassData* _getRPD(const U32 pass) { return static_cast<ShaderRenderPassData*>(mPasses[pass]); }
+};
+
+#endif // _MATERIALS_PROCESSEDSHADERMATERIAL_H_
--- source/shaderGen/HLSL/shaderGenHLSLInit.cpp	Tue Jan 20 00:26:36 1970
+++ source/shaderGen/HLSL/shaderGenHLSLInit.cpp	Tue Jan 20 00:26:36 1970
@@ -1,111 +1,110 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2012 GarageGames, LLC
-//
-// Permission is hereby granted, free of charge, to any person obtaining a copy
-// of this software and associated documentation files (the "Software"), to
-// deal in the Software without restriction, including without limitation the
-// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
-// sell copies of the Software, and to permit persons to whom the Software is
-// furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-// IN THE SOFTWARE.
-//-----------------------------------------------------------------------------
-
-#include "platform/platform.h"
-
-#include "shaderGen/shaderGen.h"
-#include "shaderGen/HLSL/shaderGenHLSL.h"
-#include "shaderGen/HLSL/shaderFeatureHLSL.h"
-#include "shaderGen/featureMgr.h"
-#include "shaderGen/HLSL/bumpHLSL.h"
-#include "shaderGen/HLSL/pixSpecularHLSL.h"
-#include "shaderGen/HLSL/depthHLSL.h"
-#include "shaderGen/HLSL/paraboloidHLSL.h"
-#include "materials/materialFeatureTypes.h"
-#include "core/module.h"
-#include "shaderGen/accuFeature.h"
-
-static ShaderGen::ShaderGenInitDelegate sInitDelegate;
-
-void _initShaderGenHLSL( ShaderGen *shaderGen )
-{
-   shaderGen->setPrinter( new ShaderGenPrinterHLSL );
-   shaderGen->setComponentFactory( new ShaderGenComponentFactoryHLSL );
-   shaderGen->setFileEnding( "hlsl" );
-
-   FEATUREMGR->registerFeature( MFT_VertTransform, new VertPositionHLSL );
-   FEATUREMGR->registerFeature( MFT_RTLighting, new RTLightingFeatHLSL );
-   FEATUREMGR->registerFeature( MFT_IsDXTnm, new NamedFeatureHLSL( "DXTnm" ) );
-   FEATUREMGR->registerFeature( MFT_TexAnim, new TexAnimHLSL );
-   FEATUREMGR->registerFeature( MFT_DiffuseMap, new DiffuseMapFeatHLSL );
-   FEATUREMGR->registerFeature( MFT_OverlayMap, new OverlayTexFeatHLSL );
-   FEATUREMGR->registerFeature( MFT_DiffuseColor, new DiffuseFeatureHLSL );
-   FEATUREMGR->registerFeature( MFT_DiffuseVertColor, new DiffuseVertColorFeatureHLSL );
-   FEATUREMGR->registerFeature( MFT_AlphaTest, new AlphaTestHLSL );
-   FEATUREMGR->registerFeature( MFT_GlowMask, new GlowMaskHLSL );
-   FEATUREMGR->registerFeature( MFT_LightMap, new LightmapFeatHLSL );
-   FEATUREMGR->registerFeature( MFT_ToneMap, new TonemapFeatHLSL );
-   FEATUREMGR->registerFeature( MFT_VertLit, new VertLitHLSL );
-   FEATUREMGR->registerFeature( MFT_Parallax, new ParallaxFeatHLSL );
-   FEATUREMGR->registerFeature( MFT_NormalMap, new BumpFeatHLSL );
-   FEATUREMGR->registerFeature( MFT_DetailNormalMap, new NamedFeatureHLSL( "Detail Normal Map" ) );
-   FEATUREMGR->registerFeature( MFT_DetailMap, new DetailFeatHLSL );
-   FEATUREMGR->registerFeature( MFT_CubeMap, new ReflectCubeFeatHLSL );
-   FEATUREMGR->registerFeature( MFT_PixSpecular, new PixelSpecularHLSL );
-   FEATUREMGR->registerFeature( MFT_IsTranslucent, new NamedFeatureHLSL( "Translucent" ) );
-   FEATUREMGR->registerFeature( MFT_IsTranslucentZWrite, new NamedFeatureHLSL( "Translucent ZWrite" ) );
-   FEATUREMGR->registerFeature( MFT_Visibility, new VisibilityFeatHLSL );
-   FEATUREMGR->registerFeature( MFT_Fog, new FogFeatHLSL );
-   FEATUREMGR->registerFeature( MFT_SpecularMap, new SpecularMapHLSL );
-   FEATUREMGR->registerFeature( MFT_AccuMap, new AccuTexFeatHLSL );
-   FEATUREMGR->registerFeature( MFT_GlossMap, new NamedFeatureHLSL( "Gloss Map" ) );
-   FEATUREMGR->registerFeature( MFT_LightbufferMRT, new NamedFeatureHLSL( "Lightbuffer MRT" ) );
-   FEATUREMGR->registerFeature( MFT_RenderTarget1_Zero, new RenderTargetZeroHLSL( ShaderFeature::RenderTarget1 ) );
-
-   FEATUREMGR->registerFeature( MFT_DiffuseMapAtlas, new NamedFeatureHLSL( "Diffuse Map Atlas" ) );
-   FEATUREMGR->registerFeature( MFT_NormalMapAtlas, new NamedFeatureHLSL( "Normal Map Atlas" ) );
-
-   FEATUREMGR->registerFeature( MFT_NormalsOut, new NormalsOutFeatHLSL );
-   
-   FEATUREMGR->registerFeature( MFT_DepthOut, new DepthOutHLSL );
-   FEATUREMGR->registerFeature( MFT_EyeSpaceDepthOut, new EyeSpaceDepthOutHLSL() );
-
-   FEATUREMGR->registerFeature( MFT_HDROut, new HDROutHLSL );
-
-   FEATUREMGR->registerFeature( MFT_ParaboloidVertTransform, new ParaboloidVertTransformHLSL );
-   FEATUREMGR->registerFeature( MFT_IsSinglePassParaboloid, new NamedFeatureHLSL( "Single Pass Paraboloid" ) );
-   FEATUREMGR->registerFeature( MFT_UseInstancing, new NamedFeatureHLSL( "Hardware Instancing" ) );
-
-   FEATUREMGR->registerFeature( MFT_Foliage, new FoliageFeatureHLSL );
-
-   FEATUREMGR->registerFeature( MFT_ParticleNormal, new ParticleNormalFeatureHLSL );
-
-   FEATUREMGR->registerFeature( MFT_InterlacedPrePass, new NamedFeatureHLSL( "Interlaced Pre Pass" ) );
-
-   FEATUREMGR->registerFeature( MFT_ForwardShading, new NamedFeatureHLSL( "Forward Shaded Material" ) );
-
-   FEATUREMGR->registerFeature( MFT_ImposterVert, new ImposterVertFeatureHLSL );
-}
-
-MODULE_BEGIN( ShaderGenHLSL )
-
-   MODULE_INIT_AFTER( ShaderGen )
-   MODULE_INIT_AFTER( ShaderGenFeatureMgr )
-   
-   MODULE_INIT
-   {
-      sInitDelegate.bind(_initShaderGenHLSL);
-      SHADERGEN->registerInitDelegate(Direct3D9, sInitDelegate);
-      SHADERGEN->registerInitDelegate(Direct3D9_360, sInitDelegate);
-   }
-   
-MODULE_END;
+//-----------------------------------------------------------------------------
+// Copyright (c) 2012 GarageGames, LLC
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to
+// deal in the Software without restriction, including without limitation the
+// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+// sell copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+// IN THE SOFTWARE.
+//-----------------------------------------------------------------------------
+
+#include "platform/platform.h"
+
+#include "shaderGen/shaderGen.h"
+#include "shaderGen/HLSL/shaderGenHLSL.h"
+#include "shaderGen/HLSL/shaderFeatureHLSL.h"
+#include "shaderGen/featureMgr.h"
+#include "shaderGen/HLSL/bumpHLSL.h"
+#include "shaderGen/HLSL/pixSpecularHLSL.h"
+#include "shaderGen/HLSL/depthHLSL.h"
+#include "shaderGen/HLSL/paraboloidHLSL.h"
+#include "materials/materialFeatureTypes.h"
+#include "core/module.h"
+
+
+static ShaderGen::ShaderGenInitDelegate sInitDelegate;
+
+void _initShaderGenHLSL( ShaderGen *shaderGen )
+{
+   shaderGen->setPrinter( new ShaderGenPrinterHLSL );
+   shaderGen->setComponentFactory( new ShaderGenComponentFactoryHLSL );
+   shaderGen->setFileEnding( "hlsl" );
+
+   FEATUREMGR->registerFeature( MFT_VertTransform, new VertPositionHLSL );
+   FEATUREMGR->registerFeature( MFT_RTLighting, new RTLightingFeatHLSL );
+   FEATUREMGR->registerFeature( MFT_IsDXTnm, new NamedFeatureHLSL( "DXTnm" ) );
+   FEATUREMGR->registerFeature( MFT_TexAnim, new TexAnimHLSL );
+   FEATUREMGR->registerFeature( MFT_DiffuseMap, new DiffuseMapFeatHLSL );
+   FEATUREMGR->registerFeature( MFT_OverlayMap, new OverlayTexFeatHLSL );
+   FEATUREMGR->registerFeature( MFT_DiffuseColor, new DiffuseFeatureHLSL );
+   FEATUREMGR->registerFeature( MFT_DiffuseVertColor, new DiffuseVertColorFeatureHLSL );
+   FEATUREMGR->registerFeature( MFT_AlphaTest, new AlphaTestHLSL );
+   FEATUREMGR->registerFeature( MFT_GlowMask, new GlowMaskHLSL );
+   FEATUREMGR->registerFeature( MFT_LightMap, new LightmapFeatHLSL );
+   FEATUREMGR->registerFeature( MFT_ToneMap, new TonemapFeatHLSL );
+   FEATUREMGR->registerFeature( MFT_VertLit, new VertLitHLSL );
+   FEATUREMGR->registerFeature( MFT_Parallax, new ParallaxFeatHLSL );
+   FEATUREMGR->registerFeature( MFT_NormalMap, new BumpFeatHLSL );
+   FEATUREMGR->registerFeature( MFT_DetailNormalMap, new NamedFeatureHLSL( "Detail Normal Map" ) );
+   FEATUREMGR->registerFeature( MFT_DetailMap, new DetailFeatHLSL );
+   FEATUREMGR->registerFeature( MFT_CubeMap, new ReflectCubeFeatHLSL );
+   FEATUREMGR->registerFeature( MFT_PixSpecular, new PixelSpecularHLSL );
+   FEATUREMGR->registerFeature( MFT_IsTranslucent, new NamedFeatureHLSL( "Translucent" ) );
+   FEATUREMGR->registerFeature( MFT_IsTranslucentZWrite, new NamedFeatureHLSL( "Translucent ZWrite" ) );
+   FEATUREMGR->registerFeature( MFT_Visibility, new VisibilityFeatHLSL );
+   FEATUREMGR->registerFeature( MFT_Fog, new FogFeatHLSL );
+   FEATUREMGR->registerFeature( MFT_SpecularMap, new SpecularMapHLSL );
+   FEATUREMGR->registerFeature( MFT_GlossMap, new NamedFeatureHLSL( "Gloss Map" ) );
+   FEATUREMGR->registerFeature( MFT_LightbufferMRT, new NamedFeatureHLSL( "Lightbuffer MRT" ) );
+   FEATUREMGR->registerFeature( MFT_RenderTarget1_Zero, new RenderTargetZeroHLSL( ShaderFeature::RenderTarget1 ) );
+
+   FEATUREMGR->registerFeature( MFT_DiffuseMapAtlas, new NamedFeatureHLSL( "Diffuse Map Atlas" ) );
+   FEATUREMGR->registerFeature( MFT_NormalMapAtlas, new NamedFeatureHLSL( "Normal Map Atlas" ) );
+
+   FEATUREMGR->registerFeature( MFT_NormalsOut, new NormalsOutFeatHLSL );
+   
+   FEATUREMGR->registerFeature( MFT_DepthOut, new DepthOutHLSL );
+   FEATUREMGR->registerFeature( MFT_EyeSpaceDepthOut, new EyeSpaceDepthOutHLSL() );
+
+   FEATUREMGR->registerFeature( MFT_HDROut, new HDROutHLSL );
+
+   FEATUREMGR->registerFeature( MFT_ParaboloidVertTransform, new ParaboloidVertTransformHLSL );
+   FEATUREMGR->registerFeature( MFT_IsSinglePassParaboloid, new NamedFeatureHLSL( "Single Pass Paraboloid" ) );
+   FEATUREMGR->registerFeature( MFT_UseInstancing, new NamedFeatureHLSL( "Hardware Instancing" ) );
+
+   FEATUREMGR->registerFeature( MFT_Foliage, new FoliageFeatureHLSL );
+
+   FEATUREMGR->registerFeature( MFT_ParticleNormal, new ParticleNormalFeatureHLSL );
+
+   FEATUREMGR->registerFeature( MFT_InterlacedPrePass, new NamedFeatureHLSL( "Interlaced Pre Pass" ) );
+
+   FEATUREMGR->registerFeature( MFT_ForwardShading, new NamedFeatureHLSL( "Forward Shaded Material" ) );
+
+   FEATUREMGR->registerFeature( MFT_ImposterVert, new ImposterVertFeatureHLSL );
+}
+
+MODULE_BEGIN( ShaderGenHLSL )
+
+   MODULE_INIT_AFTER( ShaderGen )
+   MODULE_INIT_AFTER( ShaderGenFeatureMgr )
+   
+   MODULE_INIT
+   {
+      sInitDelegate.bind(_initShaderGenHLSL);
+      SHADERGEN->registerInitDelegate(Direct3D9, sInitDelegate);
+      SHADERGEN->registerInitDelegate(Direct3D9_360, sInitDelegate);
+   }
+   
+MODULE_END;
--- source/util/imposterCapture.cpp	Tue Jan 20 00:26:36 1970
+++ source/util/imposterCapture.cpp	Tue Jan 20 00:26:36 1970
@@ -1,523 +1,522 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2012 GarageGames, LLC
-//
-// Permission is hereby granted, free of charge, to any person obtaining a copy
-// of this software and associated documentation files (the "Software"), to
-// deal in the Software without restriction, including without limitation the
-// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
-// sell copies of the Software, and to permit persons to whom the Software is
-// furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-// IN THE SOFTWARE.
-//-----------------------------------------------------------------------------
-
-#include "platform/platform.h"
-#include "util/imposterCapture.h"
-
-#include "gfx/bitmap/gBitmap.h"
-#include "core/color.h"
-#include "renderInstance/renderPassManager.h"
-#include "renderInstance/renderMeshMgr.h"
-#include "materials/materialManager.h"
-#include "materials/materialFeatureTypes.h"
-#include "materials/customMaterialDefinition.h"
-#include "ts/tsShapeInstance.h"
-#include "scene/sceneManager.h"
-#include "scene/sceneRenderState.h"
-#include "lighting/lightInfo.h"
-#include "gfx/gfxTransformSaver.h"
-#include "gfx/gfxDebugEvent.h"
-#include "core/stream/fileStream.h"
-
-
-/// A material hook used to hold imposter generation 
-/// rendering materials for an object.
-class ImposterCaptureMaterialHook : public MatInstanceHook
-{
-public:
-
-   ImposterCaptureMaterialHook();
-
-   // MatInstanceHook
-   virtual ~ImposterCaptureMaterialHook();
-   virtual const MatInstanceHookType& getType() const { return Type; }
-
-   /// The material hook type.
-   static const MatInstanceHookType Type;
-
-   void init( BaseMatInstance *mat );
-
-   static BaseMatInstance* getDiffuseInst( BaseMatInstance *inMat ) 
-      { return _getOrCreateHook( inMat )->mDiffuseMatInst; }
-
-   static BaseMatInstance* getNormalsInst( BaseMatInstance *inMat ) 
-      { return _getOrCreateHook( inMat )->mNormalsMatInst; }
-
-protected:
-
-   static void _overrideFeatures(   ProcessedMaterial *mat,
-                                    U32 stageNum,
-                                    MaterialFeatureData &fd, 
-                                    const FeatureSet &features );
-
-   static ImposterCaptureMaterialHook* _getOrCreateHook( BaseMatInstance *inMat );
-
-   /// 
-   BaseMatInstance *mDiffuseMatInst;
-
-   ///
-   BaseMatInstance *mNormalsMatInst;
-};
-
-
-const MatInstanceHookType ImposterCaptureMaterialHook::Type( "ImposterCapture" );
-
-
-ImposterCaptureMaterialHook::ImposterCaptureMaterialHook()
-   :  mDiffuseMatInst( NULL ),
-      mNormalsMatInst( NULL )
-{
-}
-
-ImposterCaptureMaterialHook::~ImposterCaptureMaterialHook()
-{
-   SAFE_DELETE( mDiffuseMatInst );
-   SAFE_DELETE( mNormalsMatInst );
-}
-
-void ImposterCaptureMaterialHook::init( BaseMatInstance *inMat )
-{
-   // We cannot capture impostors on custom materials
-   // as we don't know how to get just diffuse and just
-   // normals rendering.
-   if ( dynamic_cast<CustomMaterial*>( inMat->getMaterial() ) )
-      return;
-
-   // Tweak the feature data to include just what we need.
-   FeatureSet features;
-   features.addFeature( MFT_VertTransform );
-   features.addFeature( MFT_DiffuseMap );
-   features.addFeature( MFT_OverlayMap );
-   features.addFeature( MFT_DetailMap );
-   features.addFeature( MFT_DiffuseColor );
-   features.addFeature( MFT_AlphaTest );
-   features.addFeature( MFT_IsTranslucent );
-
-   const String &matName = inMat->getMaterial()->getName();
-
-   mDiffuseMatInst = MATMGR->createMatInstance( matName );
-   mDiffuseMatInst->getFeaturesDelegate().bind( &ImposterCaptureMaterialHook::_overrideFeatures );
-   mDiffuseMatInst->init( features, inMat->getVertexFormat() );
-   
-   features.addFeature( MFT_IsDXTnm );
-   features.addFeature( MFT_NormalMap );
-   features.addFeature( MFT_NormalsOut );
-   features.addFeature( MFT_AccuMap );
-   mNormalsMatInst = MATMGR->createMatInstance( matName );
-   mNormalsMatInst->getFeaturesDelegate().bind( &ImposterCaptureMaterialHook::_overrideFeatures );
-   mNormalsMatInst->init( features, inMat->getVertexFormat() );
-}
-
-void ImposterCaptureMaterialHook::_overrideFeatures(  ProcessedMaterial *mat,
-                                                      U32 stageNum,
-                                                      MaterialFeatureData &fd, 
-                                                      const FeatureSet &features )
-{
-   if ( features.hasFeature( MFT_NormalsOut) )
-      fd.features.addFeature( MFT_NormalsOut );
-
-   fd.features.addFeature( MFT_ForwardShading );
-}
-
-ImposterCaptureMaterialHook* ImposterCaptureMaterialHook::_getOrCreateHook( BaseMatInstance *inMat )
-{
-   ImposterCaptureMaterialHook *hook = inMat->getHook<ImposterCaptureMaterialHook>();
-   if ( !hook )
-   {
-      // Create a hook and initialize it using the incoming material.
-      hook = new ImposterCaptureMaterialHook;
-      hook->init( inMat );
-      inMat->addHook( hook );
-   }
-
-   return hook;
-}
-
-
-ImposterCapture::ImposterCapture()
-:  mShapeInstance( NULL ),
-   mDl( 0 ),
-   mDim( 0 ),
-   mRadius( 0.0f ),
-   mCenter( Point3F( 0, 0, 0 ) ),
-   mRenderPass( NULL ),
-   mMeshRenderBin( NULL ),
-   mBlackBmp( NULL ),
-   mWhiteBmp( NULL ),
-   mState( NULL ),
-   mRenderTarget( NULL )
-{     
-}                                   
-
-ImposterCapture::~ImposterCapture()
-{
-   AssertFatal( !mShapeInstance, "ImposterCapture destructor - TSShapeInstance hasn't been cleared!" );
-}
-
-void ImposterCapture::_colorAverageFilter( U32 dimensions, const U8 *inBmpBits, U8 *outBmpBits )
-{
-   ColorF color;
-   U32 count = 0;
-   U32 index, index2;
-
-   for ( S32 y = 0; y < dimensions; y++ )
-   {
-      for( S32 x = 0; x < dimensions; x++ )
-      {
-         // We only blend on transparent pixels.
-         index = ( ( y * dimensions ) + x ) * 4;
-         if ( inBmpBits[index+3] > 84 )
-         {
-            outBmpBits[index+0] = inBmpBits[index+0];
-            outBmpBits[index+1] = inBmpBits[index+1];
-            outBmpBits[index+2] = inBmpBits[index+2];
-            outBmpBits[index+3] = inBmpBits[index+3]; //hack
-            continue;
-         }
-
-         color.set(0,0,0);
-         count = 0;
-
-         for ( S32 fy = y-6; fy <= y+6; fy++ )
-         {
-            for ( S32 fx = x-6; fx <= x+6; fx++ )
-            {
-               if (  fy >= 0 && fy < (dimensions-1) &&
-                     fx >= 0 && fx < (dimensions-1) )
-               {
-                  index2 = ( ( fy * dimensions ) + fx ) * 4;
-                  if ( inBmpBits[index2+3] > 84 )
-                  {
-                     color.red += inBmpBits[index2+0];
-                     color.green += inBmpBits[index2+1];
-                     color.blue += inBmpBits[index2+2];
-                     ++count;
-                  }
-               }
-            }
-         }
-
-         outBmpBits[index+0] = (U8)( (F32)color.red / (F32)count );
-         outBmpBits[index+1] = (U8)( (F32)color.green / (F32)count );
-         outBmpBits[index+2] = (U8)( (F32)color.blue / (F32)count );
-         outBmpBits[index+3] = 0;
-      }
-   }
-}
-
-void ImposterCapture::_renderToTexture( GFXTexHandle texHandle, GBitmap *outBitmap, const ColorI &color )
-{
-   GFXDEBUGEVENT_SCOPE( ImposterCapture_RenderToTexture, ColorI::RED );
-   PROFILE_SCOPE( ImposterCapture_RenderToTexture );
-
-   mRenderTarget->attachTexture( GFXTextureTarget::Color0, texHandle );
-   mRenderTarget->attachTexture( GFXTextureTarget::DepthStencil, GFXTextureTarget::sDefaultDepthStencil );
-   GFX->setActiveRenderTarget( mRenderTarget );
-
-   GFX->clear( GFXClearZBuffer | GFXClearStencil | GFXClearTarget, color, 1.0f, 0 );
-
-   mShapeInstance->render( mRData, mDl, 1.0f );
-
-   mState->getRenderPass()->renderPass( mState );
-
-   mRenderTarget->resolve();
-
-   texHandle->copyToBmp( outBitmap );
-}
-
-void ImposterCapture::_separateAlpha( GBitmap *imposterOut )
-{
-   PROFILE_START(TSShapeInstance_snapshot_sb_separate);
-
-   // TODO: Remove all this when we get rid of the 'render on black/white'.
-
-      // now separate the color and alpha channels
-      GBitmap *bmp = new GBitmap;
-      bmp->allocateBitmap(mDim, mDim, false, GFXFormatR8G8B8A8);
-      U8 * wbmp = (U8*)mWhiteBmp->getBits(0);
-      U8 * bbmp = (U8*)mBlackBmp->getBits(0);
-      U8 * dst  = (U8*)bmp->getBits(0);
-
-      const U32 pixCount = mDim * mDim;
-
-      // simpler, probably faster...
-      for ( U32 i=0; i < pixCount; i++ )
-      {
-         // Shape on black background is alpha * color, shape on white 
-         // background is alpha * color + (1-alpha) * 255 we want 255 *
-         // alpha, or 255 - (white - black).
-         //
-         // JMQ: or more verbosely:
-         //  cB = alpha * color + (0 * (1 - alpha))
-         //  cB = alpha * color
-         //  cW = alpha * color + (255 * (1 - alpha))
-         //  cW = cB + (255 * (1 - alpha))
-         // solving for alpha
-         //  cW - cB = 255 * (1 - alpha)
-         //  (cW - cB)/255 = (1 - alpha)
-         //  alpha = 1 - (cW - cB)/255
-         // since we want alpha*255, multiply through by 255
-         //  alpha * 255 = 255 - cW - cB
-         U32 alpha = 255 - (wbmp[i*3+0] - bbmp[i*3+0]);
-         alpha    += 255 - (wbmp[i*3+1] - bbmp[i*3+1]);
-         alpha    += 255 - (wbmp[i*3+2] - bbmp[i*3+2]);
-
-         if ( alpha != 0 )
-         {
-            F32 floatAlpha = ((F32)alpha)/(3.0f*255.0f); 
-            dst[i*4+0] = (U8)(bbmp[i*3+0] / floatAlpha);
-            dst[i*4+1] = (U8)(bbmp[i*3+1] / floatAlpha);
-            dst[i*4+2] = (U8)(bbmp[i*3+2] / floatAlpha);
-
-            // Before we assign the alpha we "fizzle" the value
-            // if its greater than 84.  This causes the imposter
-            // to dissolve instead of popping into view.
-            alpha /= 3;
-            dst[i*4+3] = (U8)alpha;
-         }
-         else
-         {
-            dst[i*4+0] = dst[i*4+1] = dst[i*4+2] = dst[i*4+3] = 0;
-         }
-      }
-
-   PROFILE_END(); // TSShapeInstance_snapshot_sb_separate
-  
-   PROFILE_START(TSShapeInstance_snapshot_sb_filter);
-
-      // We now run a special kernel filter over the image that
-      // averages color into the transparent areas.  This should
-      // in essence give us a border around the edges of the 
-      // imposter silhouette which fixes the artifacts around the
-      // alpha test billboards.
-      U8* dst2 = (U8*)imposterOut->getBits(0);
-
-      _colorAverageFilter( mDim, dst, dst2 );
-      
-      if ( 0 )
-      {
-         FileStream fs;
-         if ( fs.open( "./imposterout.png", Torque::FS::File::Write ) )
-            imposterOut->writeBitmap( "png", fs );
-
-         fs.close();
-
-         if ( fs.open( "./temp.png", Torque::FS::File::Write ) )
-            bmp->writeBitmap( "png", fs );
-
-         fs.close();
-      }
-   
-
-   PROFILE_END(); // TSShapeInstance_snapshot_sb_filter
-
-   delete bmp;
-}
-
-
-void ImposterCapture::_convertDXT5nm( GBitmap *normalsOut )
-{
-   PROFILE_SCOPE(ImposterCapture_ConvertDXT5nm);
-
-   U8 *bits  = (U8*)normalsOut->getBits(0);
-   const U32 pixCount = mDim * mDim;
-   U8 x, y, z;
-
-   // Encoding in object space DXT5 which moves
-   // one of the coords to the alpha channel for
-   // improved precision.... in our case z.
-
-   for ( U32 i=0; i < pixCount; i++ )
-   {
-      x = bits[i*4+0];
-      y = bits[i*4+1];
-      z = bits[i*4+2];
-
-      bits[i*4+0] = x;
-      bits[i*4+1] = y;
-      bits[i*4+2] = 0;
-      bits[i*4+3] = z;
-   }
-}
-
-void ImposterCapture::begin(  TSShapeInstance *shapeInst,
-                              S32 dl, 
-                              S32 dim,
-                              F32 radius,
-                              const Point3F &center )
-{
-   mShapeInstance = shapeInst;
-   mDl = dl;
-   mDim = dim;
-   mRadius = radius;
-   mCenter = center;
-
-   mBlackTex.set( mDim, mDim, GFXFormatR8G8B8A8, &GFXDefaultRenderTargetProfile, avar( "%s() - (line %d)", __FUNCTION__, __LINE__ ) ); 
-   mWhiteTex.set( mDim, mDim, GFXFormatR8G8B8A8, &GFXDefaultRenderTargetProfile, avar( "%s() - (line %d)", __FUNCTION__, __LINE__ ) ); 
-   mNormalTex.set( mDim, mDim, GFXFormatR8G8B8A8, &GFXDefaultRenderTargetProfile, avar( "%s() - (line %d)", __FUNCTION__, __LINE__ ) ); 
-
-   // copy the black render target data into a bitmap
-   mBlackBmp = new GBitmap;
-   mBlackBmp->allocateBitmap(mDim, mDim, false, GFXFormatR8G8B8);
-
-   // copy the white target data into a bitmap
-   mWhiteBmp = new GBitmap;
-   mWhiteBmp->allocateBitmap(mDim, mDim, false, GFXFormatR8G8B8);
-
-   // Setup viewport and frustrum to do orthographic projection.
-   RectI viewport( 0, 0, mDim, mDim );
-   GFX->setViewport( viewport );
-   GFX->setOrtho( -mRadius, mRadius, -mRadius, mRadius, 1, 20.0f * mRadius );
-
-   // Position camera looking out the X axis.
-   MatrixF cameraMatrix( true );
-   cameraMatrix.setColumn( 0, Point3F( 0, 0, 1 ) );
-   cameraMatrix.setColumn( 1, Point3F( 1, 0, 0 ) );
-   cameraMatrix.setColumn( 2, Point3F( 0, 1, 0 ) );
-
-   // setup scene state required for TS mesh render...this is messy and inefficient; 
-   // should have a mode where most of this is done just once (and then 
-   // only the camera matrix changes between snapshots).
-   // note that we use getFrustum here, but we set up an ortho projection above.  
-   // it doesn't seem like the scene state object pays attention to whether the projection is 
-   // ortho or not.  this could become a problem if some code downstream tries to 
-   // reconstruct the projection matrix using the dimensions and doesn't 
-   // realize it should be ortho.  at the moment no code is doing that.
-   F32 left, right, top, bottom, nearPlane, farPlane;
-   bool isOrtho;
-   GFX->getFrustum( &left, &right, &bottom, &top, &nearPlane, &farPlane, &isOrtho );
-   Frustum frust( isOrtho, left, right, top, bottom, nearPlane, farPlane, cameraMatrix );
-
-   // Set up render pass.
-
-   mRenderPass = new RenderPassManager();
-   mRenderPass->assignName( "DiffuseRenderPass" );
-   mMeshRenderBin = new RenderMeshMgr();
-   mRenderPass->addManager( mMeshRenderBin );
-
-   // Set up scene state.
-
-   mState = new SceneRenderState(
-      gClientSceneGraph,
-      SPT_Diffuse,
-      SceneCameraState( viewport, frust, GFX->getWorldMatrix(),GFX->getProjectionMatrix() ),
-      mRenderPass,
-      false
-   );
-
-   // Set up our TS render state.
-   mRData.setSceneState( mState );
-   mRData.setCubemap( NULL );
-   mRData.setFadeOverride( 1.0f );
-
-   // set gfx up for render to texture
-   GFX->pushActiveRenderTarget();
-   mRenderTarget = GFX->allocRenderToTextureTarget();
-
-}
-
-void ImposterCapture::capture(   const MatrixF &rotMatrix, 
-                                 GBitmap **imposterOut,
-                                 GBitmap **normalMapOut )
-{
-   GFXTransformSaver saver;
-
-   // this version of the snapshot function renders the shape to a black texture, then to white, then reads bitmaps 
-   // back for both renders and combines them, restoring the alpha and color values.  this is based on the
-   // TGE implementation.  it is not fast due to the copy and software combination operations.  the generated bitmaps
-   // are upside-down (which is how TGE generated them...)
-
-   (*imposterOut) = new GBitmap( mDim, mDim, false, GFXFormatR8G8B8A8 );
-   (*normalMapOut) = new GBitmap( mDim, mDim, false, GFXFormatR8G8B8A8 );
-
-   // The object to world transform.
-   MatrixF centerMat( true );
-   centerMat.setPosition( -mCenter );
-   MatrixF objMatrix( rotMatrix );
-   objMatrix.mul( centerMat );
-   GFX->setWorldMatrix( objMatrix );
-
-   // The view transform.
-   MatrixF view( EulerF( M_PI_F / 2.0f, 0, M_PI_F ), Point3F( 0, 0, -10.0f * mRadius ) );
-   mRenderPass->assignSharedXform( RenderPassManager::View, view );
-
-   mRenderPass->assignSharedXform( RenderPassManager::Projection, GFX->getProjectionMatrix() );
-
-   // Render the diffuse pass.
-   mRenderPass->clear();
-   mMeshRenderBin->getMatOverrideDelegate().bind( ImposterCaptureMaterialHook::getDiffuseInst );
-   _renderToTexture( mBlackTex, mBlackBmp, ColorI(0, 0, 0, 0) );
-   _renderToTexture( mWhiteTex, mWhiteBmp, ColorI(255, 255, 255, 255) );
-
-   // Now render the normals.
-   mRenderPass->clear();
-   mMeshRenderBin->getMatOverrideDelegate().bind( ImposterCaptureMaterialHook::getNormalsInst );
-   _renderToTexture( mNormalTex, *normalMapOut, ColorI(0, 0, 0, 0) );
-
-
-   _separateAlpha( *imposterOut );
-   _convertDXT5nm( *normalMapOut );
-
-   if ( 0 )
-   {
-      // Render out the bitmaps for debug purposes.
-      FileStream fs;
-      if ( fs.open( "./blackbmp.png", Torque::FS::File::Write ) )
-         mBlackBmp->writeBitmap( "png", fs );
-
-      fs.close();
-
-      if ( fs.open( "./whitebmp.png", Torque::FS::File::Write ) )
-         mWhiteBmp->writeBitmap( "png", fs );
-
-      fs.close();
-
-      if ( fs.open( "./normalbmp.png", Torque::FS::File::Write ) )
-         (*normalMapOut)->writeBitmap( "png", fs );
-
-      fs.close();
-
-      if ( fs.open( "./finalimposter.png", Torque::FS::File::Write ) )
-         (*imposterOut)->writeBitmap( "png", fs );
-
-      fs.close();
-   }
-}
-
-void ImposterCapture::end()
-{
-   GFX->popActiveRenderTarget();
-
-   mBlackTex.free();
-   mWhiteTex.free(); 
-   mNormalTex.free();
-
-   mShapeInstance = NULL;
-   
-   mRenderTarget = NULL;
-   mMeshRenderBin = NULL; // Deleted by mRenderPass
-   SAFE_DELETE( mState );
-   SAFE_DELETE( mRenderPass );
-   SAFE_DELETE( mBlackBmp );
-   SAFE_DELETE( mWhiteBmp );
-}
-
+//-----------------------------------------------------------------------------
+// Copyright (c) 2012 GarageGames, LLC
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to
+// deal in the Software without restriction, including without limitation the
+// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+// sell copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+// IN THE SOFTWARE.
+//-----------------------------------------------------------------------------
+
+#include "platform/platform.h"
+#include "util/imposterCapture.h"
+
+#include "gfx/bitmap/gBitmap.h"
+#include "core/color.h"
+#include "renderInstance/renderPassManager.h"
+#include "renderInstance/renderMeshMgr.h"
+#include "materials/materialManager.h"
+#include "materials/materialFeatureTypes.h"
+#include "materials/customMaterialDefinition.h"
+#include "ts/tsShapeInstance.h"
+#include "scene/sceneManager.h"
+#include "scene/sceneRenderState.h"
+#include "lighting/lightInfo.h"
+#include "gfx/gfxTransformSaver.h"
+#include "gfx/gfxDebugEvent.h"
+#include "core/stream/fileStream.h"
+
+
+/// A material hook used to hold imposter generation 
+/// rendering materials for an object.
+class ImposterCaptureMaterialHook : public MatInstanceHook
+{
+public:
+
+   ImposterCaptureMaterialHook();
+
+   // MatInstanceHook
+   virtual ~ImposterCaptureMaterialHook();
+   virtual const MatInstanceHookType& getType() const { return Type; }
+
+   /// The material hook type.
+   static const MatInstanceHookType Type;
+
+   void init( BaseMatInstance *mat );
+
+   static BaseMatInstance* getDiffuseInst( BaseMatInstance *inMat ) 
+      { return _getOrCreateHook( inMat )->mDiffuseMatInst; }
+
+   static BaseMatInstance* getNormalsInst( BaseMatInstance *inMat ) 
+      { return _getOrCreateHook( inMat )->mNormalsMatInst; }
+
+protected:
+
+   static void _overrideFeatures(   ProcessedMaterial *mat,
+                                    U32 stageNum,
+                                    MaterialFeatureData &fd, 
+                                    const FeatureSet &features );
+
+   static ImposterCaptureMaterialHook* _getOrCreateHook( BaseMatInstance *inMat );
+
+   /// 
+   BaseMatInstance *mDiffuseMatInst;
+
+   ///
+   BaseMatInstance *mNormalsMatInst;
+};
+
+
+const MatInstanceHookType ImposterCaptureMaterialHook::Type( "ImposterCapture" );
+
+
+ImposterCaptureMaterialHook::ImposterCaptureMaterialHook()
+   :  mDiffuseMatInst( NULL ),
+      mNormalsMatInst( NULL )
+{
+}
+
+ImposterCaptureMaterialHook::~ImposterCaptureMaterialHook()
+{
+   SAFE_DELETE( mDiffuseMatInst );
+   SAFE_DELETE( mNormalsMatInst );
+}
+
+void ImposterCaptureMaterialHook::init( BaseMatInstance *inMat )
+{
+   // We cannot capture impostors on custom materials
+   // as we don't know how to get just diffuse and just
+   // normals rendering.
+   if ( dynamic_cast<CustomMaterial*>( inMat->getMaterial() ) )
+      return;
+
+   // Tweak the feature data to include just what we need.
+   FeatureSet features;
+   features.addFeature( MFT_VertTransform );
+   features.addFeature( MFT_DiffuseMap );
+   features.addFeature( MFT_OverlayMap );
+   features.addFeature( MFT_DetailMap );
+   features.addFeature( MFT_DiffuseColor );
+   features.addFeature( MFT_AlphaTest );
+   features.addFeature( MFT_IsTranslucent );
+
+   const String &matName = inMat->getMaterial()->getName();
+
+   mDiffuseMatInst = MATMGR->createMatInstance( matName );
+   mDiffuseMatInst->getFeaturesDelegate().bind( &ImposterCaptureMaterialHook::_overrideFeatures );
+   mDiffuseMatInst->init( features, inMat->getVertexFormat() );
+   
+   features.addFeature( MFT_IsDXTnm );
+   features.addFeature( MFT_NormalMap );
+   features.addFeature( MFT_NormalsOut );
+   mNormalsMatInst = MATMGR->createMatInstance( matName );
+   mNormalsMatInst->getFeaturesDelegate().bind( &ImposterCaptureMaterialHook::_overrideFeatures );
+   mNormalsMatInst->init( features, inMat->getVertexFormat() );
+}
+
+void ImposterCaptureMaterialHook::_overrideFeatures(  ProcessedMaterial *mat,
+                                                      U32 stageNum,
+                                                      MaterialFeatureData &fd, 
+                                                      const FeatureSet &features )
+{
+   if ( features.hasFeature( MFT_NormalsOut) )
+      fd.features.addFeature( MFT_NormalsOut );
+
+   fd.features.addFeature( MFT_ForwardShading );
+}
+
+ImposterCaptureMaterialHook* ImposterCaptureMaterialHook::_getOrCreateHook( BaseMatInstance *inMat )
+{
+   ImposterCaptureMaterialHook *hook = inMat->getHook<ImposterCaptureMaterialHook>();
+   if ( !hook )
+   {
+      // Create a hook and initialize it using the incoming material.
+      hook = new ImposterCaptureMaterialHook;
+      hook->init( inMat );
+      inMat->addHook( hook );
+   }
+
+   return hook;
+}
+
+
+ImposterCapture::ImposterCapture()
+:  mShapeInstance( NULL ),
+   mDl( 0 ),
+   mDim( 0 ),
+   mRadius( 0.0f ),
+   mCenter( Point3F( 0, 0, 0 ) ),
+   mRenderPass( NULL ),
+   mMeshRenderBin( NULL ),
+   mBlackBmp( NULL ),
+   mWhiteBmp( NULL ),
+   mState( NULL ),
+   mRenderTarget( NULL )
+{     
+}                                   
+
+ImposterCapture::~ImposterCapture()
+{
+   AssertFatal( !mShapeInstance, "ImposterCapture destructor - TSShapeInstance hasn't been cleared!" );
+}
+
+void ImposterCapture::_colorAverageFilter( U32 dimensions, const U8 *inBmpBits, U8 *outBmpBits )
+{
+   ColorF color;
+   U32 count = 0;
+   U32 index, index2;
+
+   for ( S32 y = 0; y < dimensions; y++ )
+   {
+      for( S32 x = 0; x < dimensions; x++ )
+      {
+         // We only blend on transparent pixels.
+         index = ( ( y * dimensions ) + x ) * 4;
+         if ( inBmpBits[index+3] > 84 )
+         {
+            outBmpBits[index+0] = inBmpBits[index+0];
+            outBmpBits[index+1] = inBmpBits[index+1];
+            outBmpBits[index+2] = inBmpBits[index+2];
+            outBmpBits[index+3] = inBmpBits[index+3]; //hack
+            continue;
+         }
+
+         color.set(0,0,0);
+         count = 0;
+
+         for ( S32 fy = y-6; fy <= y+6; fy++ )
+         {
+            for ( S32 fx = x-6; fx <= x+6; fx++ )
+            {
+               if (  fy >= 0 && fy < (dimensions-1) &&
+                     fx >= 0 && fx < (dimensions-1) )
+               {
+                  index2 = ( ( fy * dimensions ) + fx ) * 4;
+                  if ( inBmpBits[index2+3] > 84 )
+                  {
+                     color.red += inBmpBits[index2+0];
+                     color.green += inBmpBits[index2+1];
+                     color.blue += inBmpBits[index2+2];
+                     ++count;
+                  }
+               }
+            }
+         }
+
+         outBmpBits[index+0] = (U8)( (F32)color.red / (F32)count );
+         outBmpBits[index+1] = (U8)( (F32)color.green / (F32)count );
+         outBmpBits[index+2] = (U8)( (F32)color.blue / (F32)count );
+         outBmpBits[index+3] = 0;
+      }
+   }
+}
+
+void ImposterCapture::_renderToTexture( GFXTexHandle texHandle, GBitmap *outBitmap, const ColorI &color )
+{
+   GFXDEBUGEVENT_SCOPE( ImposterCapture_RenderToTexture, ColorI::RED );
+   PROFILE_SCOPE( ImposterCapture_RenderToTexture );
+
+   mRenderTarget->attachTexture( GFXTextureTarget::Color0, texHandle );
+   mRenderTarget->attachTexture( GFXTextureTarget::DepthStencil, GFXTextureTarget::sDefaultDepthStencil );
+   GFX->setActiveRenderTarget( mRenderTarget );
+
+   GFX->clear( GFXClearZBuffer | GFXClearStencil | GFXClearTarget, color, 1.0f, 0 );
+
+   mShapeInstance->render( mRData, mDl, 1.0f );
+
+   mState->getRenderPass()->renderPass( mState );
+
+   mRenderTarget->resolve();
+
+   texHandle->copyToBmp( outBitmap );
+}
+
+void ImposterCapture::_separateAlpha( GBitmap *imposterOut )
+{
+   PROFILE_START(TSShapeInstance_snapshot_sb_separate);
+
+   // TODO: Remove all this when we get rid of the 'render on black/white'.
+
+      // now separate the color and alpha channels
+      GBitmap *bmp = new GBitmap;
+      bmp->allocateBitmap(mDim, mDim, false, GFXFormatR8G8B8A8);
+      U8 * wbmp = (U8*)mWhiteBmp->getBits(0);
+      U8 * bbmp = (U8*)mBlackBmp->getBits(0);
+      U8 * dst  = (U8*)bmp->getBits(0);
+
+      const U32 pixCount = mDim * mDim;
+
+      // simpler, probably faster...
+      for ( U32 i=0; i < pixCount; i++ )
+      {
+         // Shape on black background is alpha * color, shape on white 
+         // background is alpha * color + (1-alpha) * 255 we want 255 *
+         // alpha, or 255 - (white - black).
+         //
+         // JMQ: or more verbosely:
+         //  cB = alpha * color + (0 * (1 - alpha))
+         //  cB = alpha * color
+         //  cW = alpha * color + (255 * (1 - alpha))
+         //  cW = cB + (255 * (1 - alpha))
+         // solving for alpha
+         //  cW - cB = 255 * (1 - alpha)
+         //  (cW - cB)/255 = (1 - alpha)
+         //  alpha = 1 - (cW - cB)/255
+         // since we want alpha*255, multiply through by 255
+         //  alpha * 255 = 255 - cW - cB
+         U32 alpha = 255 - (wbmp[i*3+0] - bbmp[i*3+0]);
+         alpha    += 255 - (wbmp[i*3+1] - bbmp[i*3+1]);
+         alpha    += 255 - (wbmp[i*3+2] - bbmp[i*3+2]);
+
+         if ( alpha != 0 )
+         {
+            F32 floatAlpha = ((F32)alpha)/(3.0f*255.0f); 
+            dst[i*4+0] = (U8)(bbmp[i*3+0] / floatAlpha);
+            dst[i*4+1] = (U8)(bbmp[i*3+1] / floatAlpha);
+            dst[i*4+2] = (U8)(bbmp[i*3+2] / floatAlpha);
+
+            // Before we assign the alpha we "fizzle" the value
+            // if its greater than 84.  This causes the imposter
+            // to dissolve instead of popping into view.
+            alpha /= 3;
+            dst[i*4+3] = (U8)alpha;
+         }
+         else
+         {
+            dst[i*4+0] = dst[i*4+1] = dst[i*4+2] = dst[i*4+3] = 0;
+         }
+      }
+
+   PROFILE_END(); // TSShapeInstance_snapshot_sb_separate
+  
+   PROFILE_START(TSShapeInstance_snapshot_sb_filter);
+
+      // We now run a special kernel filter over the image that
+      // averages color into the transparent areas.  This should
+      // in essence give us a border around the edges of the 
+      // imposter silhouette which fixes the artifacts around the
+      // alpha test billboards.
+      U8* dst2 = (U8*)imposterOut->getBits(0);
+
+      _colorAverageFilter( mDim, dst, dst2 );
+      
+      if ( 0 )
+      {
+         FileStream fs;
+         if ( fs.open( "./imposterout.png", Torque::FS::File::Write ) )
+            imposterOut->writeBitmap( "png", fs );
+
+         fs.close();
+
+         if ( fs.open( "./temp.png", Torque::FS::File::Write ) )
+            bmp->writeBitmap( "png", fs );
+
+         fs.close();
+      }
+   
+
+   PROFILE_END(); // TSShapeInstance_snapshot_sb_filter
+
+   delete bmp;
+}
+
+
+void ImposterCapture::_convertDXT5nm( GBitmap *normalsOut )
+{
+   PROFILE_SCOPE(ImposterCapture_ConvertDXT5nm);
+
+   U8 *bits  = (U8*)normalsOut->getBits(0);
+   const U32 pixCount = mDim * mDim;
+   U8 x, y, z;
+
+   // Encoding in object space DXT5 which moves
+   // one of the coords to the alpha channel for
+   // improved precision.... in our case z.
+
+   for ( U32 i=0; i < pixCount; i++ )
+   {
+      x = bits[i*4+0];
+      y = bits[i*4+1];
+      z = bits[i*4+2];
+
+      bits[i*4+0] = x;
+      bits[i*4+1] = y;
+      bits[i*4+2] = 0;
+      bits[i*4+3] = z;
+   }
+}
+
+void ImposterCapture::begin(  TSShapeInstance *shapeInst,
+                              S32 dl, 
+                              S32 dim,
+                              F32 radius,
+                              const Point3F &center )
+{
+   mShapeInstance = shapeInst;
+   mDl = dl;
+   mDim = dim;
+   mRadius = radius;
+   mCenter = center;
+
+   mBlackTex.set( mDim, mDim, GFXFormatR8G8B8A8, &GFXDefaultRenderTargetProfile, avar( "%s() - (line %d)", __FUNCTION__, __LINE__ ) ); 
+   mWhiteTex.set( mDim, mDim, GFXFormatR8G8B8A8, &GFXDefaultRenderTargetProfile, avar( "%s() - (line %d)", __FUNCTION__, __LINE__ ) ); 
+   mNormalTex.set( mDim, mDim, GFXFormatR8G8B8A8, &GFXDefaultRenderTargetProfile, avar( "%s() - (line %d)", __FUNCTION__, __LINE__ ) ); 
+
+   // copy the black render target data into a bitmap
+   mBlackBmp = new GBitmap;
+   mBlackBmp->allocateBitmap(mDim, mDim, false, GFXFormatR8G8B8);
+
+   // copy the white target data into a bitmap
+   mWhiteBmp = new GBitmap;
+   mWhiteBmp->allocateBitmap(mDim, mDim, false, GFXFormatR8G8B8);
+
+   // Setup viewport and frustrum to do orthographic projection.
+   RectI viewport( 0, 0, mDim, mDim );
+   GFX->setViewport( viewport );
+   GFX->setOrtho( -mRadius, mRadius, -mRadius, mRadius, 1, 20.0f * mRadius );
+
+   // Position camera looking out the X axis.
+   MatrixF cameraMatrix( true );
+   cameraMatrix.setColumn( 0, Point3F( 0, 0, 1 ) );
+   cameraMatrix.setColumn( 1, Point3F( 1, 0, 0 ) );
+   cameraMatrix.setColumn( 2, Point3F( 0, 1, 0 ) );
+
+   // setup scene state required for TS mesh render...this is messy and inefficient; 
+   // should have a mode where most of this is done just once (and then 
+   // only the camera matrix changes between snapshots).
+   // note that we use getFrustum here, but we set up an ortho projection above.  
+   // it doesn't seem like the scene state object pays attention to whether the projection is 
+   // ortho or not.  this could become a problem if some code downstream tries to 
+   // reconstruct the projection matrix using the dimensions and doesn't 
+   // realize it should be ortho.  at the moment no code is doing that.
+   F32 left, right, top, bottom, nearPlane, farPlane;
+   bool isOrtho;
+   GFX->getFrustum( &left, &right, &bottom, &top, &nearPlane, &farPlane, &isOrtho );
+   Frustum frust( isOrtho, left, right, top, bottom, nearPlane, farPlane, cameraMatrix );
+
+   // Set up render pass.
+
+   mRenderPass = new RenderPassManager();
+   mRenderPass->assignName( "DiffuseRenderPass" );
+   mMeshRenderBin = new RenderMeshMgr();
+   mRenderPass->addManager( mMeshRenderBin );
+
+   // Set up scene state.
+
+   mState = new SceneRenderState(
+      gClientSceneGraph,
+      SPT_Diffuse,
+      SceneCameraState( viewport, frust, GFX->getWorldMatrix(),GFX->getProjectionMatrix() ),
+      mRenderPass,
+      false
+   );
+
+   // Set up our TS render state.
+   mRData.setSceneState( mState );
+   mRData.setCubemap( NULL );
+   mRData.setFadeOverride( 1.0f );
+
+   // set gfx up for render to texture
+   GFX->pushActiveRenderTarget();
+   mRenderTarget = GFX->allocRenderToTextureTarget();
+
+}
+
+void ImposterCapture::capture(   const MatrixF &rotMatrix, 
+                                 GBitmap **imposterOut,
+                                 GBitmap **normalMapOut )
+{
+   GFXTransformSaver saver;
+
+   // this version of the snapshot function renders the shape to a black texture, then to white, then reads bitmaps 
+   // back for both renders and combines them, restoring the alpha and color values.  this is based on the
+   // TGE implementation.  it is not fast due to the copy and software combination operations.  the generated bitmaps
+   // are upside-down (which is how TGE generated them...)
+
+   (*imposterOut) = new GBitmap( mDim, mDim, false, GFXFormatR8G8B8A8 );
+   (*normalMapOut) = new GBitmap( mDim, mDim, false, GFXFormatR8G8B8A8 );
+
+   // The object to world transform.
+   MatrixF centerMat( true );
+   centerMat.setPosition( -mCenter );
+   MatrixF objMatrix( rotMatrix );
+   objMatrix.mul( centerMat );
+   GFX->setWorldMatrix( objMatrix );
+
+   // The view transform.
+   MatrixF view( EulerF( M_PI_F / 2.0f, 0, M_PI_F ), Point3F( 0, 0, -10.0f * mRadius ) );
+   mRenderPass->assignSharedXform( RenderPassManager::View, view );
+
+   mRenderPass->assignSharedXform( RenderPassManager::Projection, GFX->getProjectionMatrix() );
+
+   // Render the diffuse pass.
+   mRenderPass->clear();
+   mMeshRenderBin->getMatOverrideDelegate().bind( ImposterCaptureMaterialHook::getDiffuseInst );
+   _renderToTexture( mBlackTex, mBlackBmp, ColorI(0, 0, 0, 0) );
+   _renderToTexture( mWhiteTex, mWhiteBmp, ColorI(255, 255, 255, 255) );
+
+   // Now render the normals.
+   mRenderPass->clear();
+   mMeshRenderBin->getMatOverrideDelegate().bind( ImposterCaptureMaterialHook::getNormalsInst );
+   _renderToTexture( mNormalTex, *normalMapOut, ColorI(0, 0, 0, 0) );
+
+
+   _separateAlpha( *imposterOut );
+   _convertDXT5nm( *normalMapOut );
+
+   if ( 0 )
+   {
+      // Render out the bitmaps for debug purposes.
+      FileStream fs;
+      if ( fs.open( "./blackbmp.png", Torque::FS::File::Write ) )
+         mBlackBmp->writeBitmap( "png", fs );
+
+      fs.close();
+
+      if ( fs.open( "./whitebmp.png", Torque::FS::File::Write ) )
+         mWhiteBmp->writeBitmap( "png", fs );
+
+      fs.close();
+
+      if ( fs.open( "./normalbmp.png", Torque::FS::File::Write ) )
+         (*normalMapOut)->writeBitmap( "png", fs );
+
+      fs.close();
+
+      if ( fs.open( "./finalimposter.png", Torque::FS::File::Write ) )
+         (*imposterOut)->writeBitmap( "png", fs );
+
+      fs.close();
+   }
+}
+
+void ImposterCapture::end()
+{
+   GFX->popActiveRenderTarget();
+
+   mBlackTex.free();
+   mWhiteTex.free(); 
+   mNormalTex.free();
+
+   mShapeInstance = NULL;
+   
+   mRenderTarget = NULL;
+   mMeshRenderBin = NULL; // Deleted by mRenderPass
+   SAFE_DELETE( mState );
+   SAFE_DELETE( mRenderPass );
+   SAFE_DELETE( mBlackBmp );
+   SAFE_DELETE( mWhiteBmp );
+}
+
